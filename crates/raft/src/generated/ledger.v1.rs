// @generated
// This file is @generated by prost-build.
// =============================================================================
// Core Types
// =============================================================================

/// 256-bit hash (SHA-256)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Hash {
    /// 32 bytes
    #[prost(bytes="vec", tag="1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Unique namespace identifier (one per organization)
/// Sequential int64 assigned by Ledger leader from "_meta:seq:namespace"
/// Special case: namespace_id = 0 is reserved for _system
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NamespaceId {
    #[prost(int64, tag="1")]
    pub id: i64,
}
/// Unique vault identifier (relationship store within a namespace)
/// Sequential int64 assigned by Ledger leader from "_meta:seq:vault"
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VaultId {
    #[prost(int64, tag="1")]
    pub id: i64,
}
/// Unique shard identifier (Raft group hosting multiple namespaces)
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShardId {
    #[prost(uint32, tag="1")]
    pub id: u32,
}
/// Unique node identifier
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeId {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
/// Unique user identifier (global, stored in _system namespace)
/// Sequential int64 assigned by Ledger leader (see ID Generation Strategy in DESIGN.md)
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserId {
    #[prost(int64, tag="1")]
    pub id: i64,
}
/// User record (stored in _system namespace as Entity with key "user:{id}")
/// Users can have multiple email addresses via separate UserEmail entities.
/// Namespace access is derived from membership records (member:{id} in each org namespace).
/// ID assigned by Ledger leader from sequence counter "_meta:seq:user"
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct User {
    #[prost(message, optional, tag="1")]
    pub id: ::core::option::Option<UserId>,
    /// Display name (1-200 characters)
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// References UserEmail.id
    #[prost(int64, tag="3")]
    pub primary_email_id: i64,
    /// Lifecycle state
    #[prost(enumeration="UserStatus", tag="4")]
    pub status: i32,
    #[prost(message, optional, tag="5")]
    pub created_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    #[prost(message, optional, tag="6")]
    pub updated_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
/// User email address (stored in _system namespace as Entity with key "user_email:{id}")
/// Each user can have multiple emails; primary is tracked by UserEmail.primary field.
/// Constraint: Primary email cannot be deleted (must reassign primary first).
/// Global email uniqueness is enforced via index: "_idx:email:{email}" → email_id
/// ID assigned by Ledger leader from sequence counter "_meta:seq:user_email"
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserEmail {
    /// Sequential ID (Ledger-assigned)
    #[prost(int64, tag="1")]
    pub id: i64,
    /// Owning user
    #[prost(message, optional, tag="2")]
    pub user_id: ::core::option::Option<UserId>,
    /// Normalized to lowercase (max 320 chars per RFC 5321)
    #[prost(string, tag="3")]
    pub email: ::prost::alloc::string::String,
    /// Whether email has been verified
    #[prost(bool, tag="4")]
    pub verified: bool,
    /// Whether this is the user's primary email
    #[prost(bool, tag="5")]
    pub primary: bool,
    #[prost(message, optional, tag="6")]
    pub created_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    /// When verified (null if unverified)
    #[prost(message, optional, tag="7")]
    pub verified_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
/// Email verification token (stored in _system namespace with TTL)
/// Key: "email_verify:{id}", Index: "_idx:email_verify:token:{token}" → token_id
/// Tokens expire after 24 hours via Ledger's TTL mechanism.
/// ID assigned by Ledger leader from sequence counter "_meta:seq:email_verify"
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EmailVerificationToken {
    /// Sequential ID (Ledger-assigned)
    #[prost(int64, tag="1")]
    pub id: i64,
    /// Email being verified
    #[prost(int64, tag="2")]
    pub user_email_id: i64,
    /// 64-char hex string (32 random bytes)
    #[prost(string, tag="3")]
    pub token: ::prost::alloc::string::String,
    #[prost(message, optional, tag="4")]
    pub created_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    /// For application-level validation
    #[prost(message, optional, tag="5")]
    pub expires_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    /// When token was consumed (null if unused)
    #[prost(message, optional, tag="6")]
    pub used_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
/// Unique client identifier (for idempotency)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClientId {
    /// Opaque string (max 256 chars, typically API key ID)
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
}
/// Unique transaction identifier
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TxId {
    /// UUID as 16 bytes
    #[prost(bytes="vec", tag="1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
// =============================================================================
// Block & Transaction Types
// =============================================================================

#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockHeader {
    #[prost(uint64, tag="1")]
    pub height: u64,
    /// Owning namespace (organization)
    #[prost(message, optional, tag="2")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Vault within namespace
    #[prost(message, optional, tag="3")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(message, optional, tag="4")]
    pub previous_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag="5")]
    pub tx_merkle_root: ::core::option::Option<Hash>,
    #[prost(message, optional, tag="6")]
    pub state_root: ::core::option::Option<Hash>,
    #[prost(message, optional, tag="7")]
    pub timestamp: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    #[prost(message, optional, tag="8")]
    pub leader_id: ::core::option::Option<NodeId>,
    #[prost(uint64, tag="9")]
    pub term: u64,
    #[prost(uint64, tag="10")]
    pub committed_index: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(message, optional, tag="1")]
    pub header: ::core::option::Option<BlockHeader>,
    #[prost(message, repeated, tag="2")]
    pub transactions: ::prost::alloc::vec::Vec<Transaction>,
}
/// Lightweight block notification for streaming (excludes transaction bodies)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockAnnouncement {
    /// Owning namespace
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Vault within namespace
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(uint64, tag="3")]
    pub height: u64,
    #[prost(message, optional, tag="4")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag="5")]
    pub state_root: ::core::option::Option<Hash>,
    #[prost(message, optional, tag="6")]
    pub timestamp: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    #[prost(message, optional, tag="1")]
    pub id: ::core::option::Option<TxId>,
    #[prost(message, optional, tag="2")]
    pub client_id: ::core::option::Option<ClientId>,
    #[prost(uint64, tag="3")]
    pub sequence: u64,
    #[prost(message, repeated, tag="4")]
    pub operations: ::prost::alloc::vec::Vec<Operation>,
    #[prost(message, optional, tag="5")]
    pub timestamp: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    /// Actor identity, ALWAYS server-assigned from authenticated context.
    /// Clients cannot specify this - derived from auth:
    ///    - Session token → "user:{user_id}"
    ///    - API key → "client:{client_id}"
    ///    - Internal operation → "system:{component}" (e.g., "system:gc")
    /// Format: {type}:{id}, max 128 characters.
    #[prost(string, tag="6")]
    pub actor: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Operation {
    #[prost(oneof="operation::Op", tags="1, 2, 3, 4, 5")]
    pub op: ::core::option::Option<operation::Op>,
}
/// Nested message and enum types in `Operation`.
pub mod operation {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Op {
        #[prost(message, tag="1")]
        CreateRelationship(super::CreateRelationship),
        #[prost(message, tag="2")]
        DeleteRelationship(super::DeleteRelationship),
        #[prost(message, tag="3")]
        SetEntity(super::SetEntity),
        #[prost(message, tag="4")]
        DeleteEntity(super::DeleteEntity),
        /// GC-initiated removal (distinct from user delete)
        #[prost(message, tag="5")]
        ExpireEntity(super::ExpireEntity),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateRelationship {
    /// Format: "type:id" (max 512 chars total)
    #[prost(string, tag="1")]
    pub resource: ::prost::alloc::string::String,
    /// Relation name (max 64 chars, e.g., "viewer", "editor")
    #[prost(string, tag="2")]
    pub relation: ::prost::alloc::string::String,
    /// Format: "type:id" or "type:id#relation" (max 512 chars)
    #[prost(string, tag="3")]
    pub subject: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteRelationship {
    /// Format: "type:id" (max 512 chars total)
    #[prost(string, tag="1")]
    pub resource: ::prost::alloc::string::String,
    /// Relation name (max 64 chars)
    #[prost(string, tag="2")]
    pub relation: ::prost::alloc::string::String,
    /// Format: "type:id" or "type:id#relation" (max 512 chars)
    #[prost(string, tag="3")]
    pub subject: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetEntity {
    /// Entity key (max 1024 bytes, UTF-8)
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Entity value (max 1MB)
    #[prost(bytes="vec", tag="2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// Unix epoch seconds; 0 or omit = never expires
    #[prost(uint64, optional, tag="3")]
    pub expires_at: ::core::option::Option<u64>,
    /// Optional conditional write (CAS)
    #[prost(message, optional, tag="4")]
    pub condition: ::core::option::Option<SetCondition>,
}
/// Condition for compare-and-set writes (used for coordination primitives)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetCondition {
    #[prost(oneof="set_condition::Condition", tags="1, 2, 3, 4")]
    pub condition: ::core::option::Option<set_condition::Condition>,
}
/// Nested message and enum types in `SetCondition`.
pub mod set_condition {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Condition {
        /// Only set if key doesn't exist
        #[prost(bool, tag="1")]
        NotExists(bool),
        /// Only set if key was last modified at this block height
        #[prost(uint64, tag="2")]
        Version(u64),
        /// Only set if current value matches exactly
        #[prost(bytes, tag="3")]
        ValueEquals(::prost::alloc::vec::Vec<u8>),
        /// Only set if key already exists (for safe updates)
        #[prost(bool, tag="4")]
        MustExists(bool),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteEntity {
    /// Entity key (max 1024 bytes, UTF-8)
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
}
/// GC-initiated entity removal (distinct from user deletion for audit trail)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExpireEntity {
    /// Entity key (max 1024 bytes, UTF-8)
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// When the entity's TTL was reached (Unix epoch seconds)
    #[prost(uint64, tag="2")]
    pub expired_at: u64,
}
/// Relationship tuple (used in query results)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Relationship {
    /// Format: "type:id" (max 512 chars)
    #[prost(string, tag="1")]
    pub resource: ::prost::alloc::string::String,
    /// Relation name (max 64 chars)
    #[prost(string, tag="2")]
    pub relation: ::prost::alloc::string::String,
    /// Format: "type:id" or "type:id#relation" (max 512 chars)
    #[prost(string, tag="3")]
    pub subject: ::prost::alloc::string::String,
}
/// Entity (used in query results)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Entity {
    /// Entity key (max 1024 bytes, UTF-8)
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// Entity value (max 1MB)
    #[prost(bytes="vec", tag="2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// Unix epoch seconds; 0 = never expires
    #[prost(uint64, optional, tag="3")]
    pub expires_at: ::core::option::Option<u64>,
    /// Block height when last modified (for conditional writes)
    #[prost(uint64, tag="4")]
    pub version: u64,
}
/// Merkle inclusion proof for transaction in block.
/// Verification: recompute root from leaf_hash up through siblings.
/// The leaf_hash is SHA-256(canonical_tx_encoding) - see DESIGN.md "Transaction Hash".
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerkleProof {
    /// SHA-256 of transaction (not included separately)
    #[prost(message, optional, tag="1")]
    pub leaf_hash: ::core::option::Option<Hash>,
    /// Siblings from leaf to root (bottom-up order)
    #[prost(message, repeated, tag="2")]
    pub siblings: ::prost::alloc::vec::Vec<MerkleSibling>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MerkleSibling {
    #[prost(message, optional, tag="1")]
    pub hash: ::core::option::Option<Hash>,
    /// Where sibling sits: LEFT means hash(sibling || current)
    #[prost(enumeration="Direction", tag="2")]
    pub direction: i32,
}
/// Chain proof linking a trusted height to a response height.
/// Used to verify that block at response_height descends from trusted_height.
///
/// Ordering: headers\[0\].height == trusted_height + 1, ascending to response_height.
/// The trusted header itself is NOT included (client already has it).
/// Verification: chain previous_hash links and verify final header matches response.
///
/// Example: trusted_height=100, response_height=103
///    headers = \[BlockHeader(101), BlockHeader(102), BlockHeader(103)\]
///    Verify: headers\[0\].previous_hash == sha256(trusted_header)
///            headers\[1\].previous_hash == sha256(headers\[0\])
///            headers\[2\].previous_hash == sha256(headers\[1\])
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainProof {
    /// Ascending height order, excludes trusted header
    #[prost(message, repeated, tag="1")]
    pub headers: ::prost::alloc::vec::Vec<BlockHeader>,
}
/// State proof for entity existence verification.
/// Unlike transaction proofs (O(log n) Merkle path), state proofs require
/// bucket contents because state uses bucket-based hashing for O(1) writes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateProof {
    /// Entity key
    #[prost(bytes="vec", tag="1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// Entity value
    #[prost(bytes="vec", tag="2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// TTL (0 = never)
    #[prost(uint64, tag="3")]
    pub expires_at: u64,
    /// Block height when last modified
    #[prost(uint64, tag="4")]
    pub version: u64,
    /// Bucket assignment (seahash(key) % 256)
    #[prost(uint32, tag="5")]
    pub bucket_id: u32,
    /// Computed bucket root
    #[prost(message, optional, tag="6")]
    pub bucket_root: ::core::option::Option<Hash>,
    /// 255 other bucket roots (index skips bucket_id)
    #[prost(message, repeated, tag="7")]
    pub other_bucket_roots: ::prost::alloc::vec::Vec<Hash>,
    /// Block height this proof is valid for
    #[prost(uint64, tag="8")]
    pub block_height: u64,
    /// Expected state_root (for verification)
    #[prost(message, optional, tag="9")]
    pub state_root: ::core::option::Option<Hash>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Omit for namespace-level entity reads
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(string, tag="3")]
    pub key: ::prost::alloc::string::String,
    /// Default: EVENTUAL (any replica)
    #[prost(enumeration="ReadConsistency", tag="4")]
    pub consistency: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadResponse {
    #[prost(bytes="vec", optional, tag="1")]
    pub value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, tag="2")]
    pub block_height: u64,
}
/// Batch read request: read multiple keys in a single RPC for higher throughput.
/// All reads share the same namespace, vault, and consistency level.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchReadRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Keys to read (max 1000)
    #[prost(string, repeated, tag="3")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Applied to all reads
    #[prost(enumeration="ReadConsistency", tag="4")]
    pub consistency: i32,
}
/// Batch read response: results for all requested keys.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchReadResponse {
    #[prost(message, repeated, tag="1")]
    pub results: ::prost::alloc::vec::Vec<BatchReadResult>,
    /// Block height at time of read
    #[prost(uint64, tag="2")]
    pub block_height: u64,
}
/// Result for a single key in a batch read.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchReadResult {
    #[prost(string, tag="1")]
    pub key: ::prost::alloc::string::String,
    /// None if key not found
    #[prost(bytes="vec", optional, tag="2")]
    pub value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Explicit found flag for clarity
    #[prost(bool, tag="3")]
    pub found: bool,
}
/// Verified read: retrieve state with cryptographic proofs for client-side verification.
/// Always returns: block_header + merkle_proof (required for verification).
/// Use case: Clients that verify state locally, don't trust the server.
///
/// For historical reads WITHOUT proofs (audits, debugging), use HistoricalRead
/// with include_proof=false to avoid proof generation overhead.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VerifiedReadRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Omit for namespace-level entity reads
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(string, tag="3")]
    pub key: ::prost::alloc::string::String,
    /// Read at specific height (0 or omit = current)
    #[prost(uint64, optional, tag="4")]
    pub at_height: ::core::option::Option<u64>,
    /// Also include chain proof to trusted_height
    #[prost(bool, tag="5")]
    pub include_chain_proof: bool,
    /// Chain proof starts from this checkpoint
    #[prost(uint64, optional, tag="6")]
    pub trusted_height: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifiedReadResponse {
    #[prost(bytes="vec", optional, tag="1")]
    pub value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, tag="2")]
    pub block_height: u64,
    #[prost(message, optional, tag="3")]
    pub block_header: ::core::option::Option<BlockHeader>,
    #[prost(message, optional, tag="4")]
    pub merkle_proof: ::core::option::Option<MerkleProof>,
    #[prost(message, optional, tag="5")]
    pub chain_proof: ::core::option::Option<ChainProof>,
}
/// Historical read: retrieve state at a specific past block height.
/// Use case: Audits, compliance queries, debugging past state.
/// Performance: Requires snapshot reconstruction (5-20ms hot, 100ms-10s cold).
///
/// For verified historical reads with proofs, prefer VerifiedRead(at_height) which
/// is optimized for the verification use case. HistoricalRead is for unverified
/// archival queries where proof generation would add unnecessary overhead.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HistoricalReadRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Omit for namespace-level entity reads
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(string, tag="3")]
    pub key: ::prost::alloc::string::String,
    /// Required: block height to read from
    #[prost(uint64, tag="4")]
    pub at_height: u64,
    /// Include block_header + merkle_proof (default: false)
    #[prost(bool, tag="5")]
    pub include_proof: bool,
    /// Also include chain proof (requires include_proof=true)
    #[prost(bool, tag="6")]
    pub include_chain_proof: bool,
    /// Chain proof starts from this checkpoint
    #[prost(uint64, optional, tag="7")]
    pub trusted_height: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistoricalReadResponse {
    /// None if key didn't exist at at_height
    #[prost(bytes="vec", optional, tag="1")]
    pub value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Echoes at_height for confirmation
    #[prost(uint64, tag="2")]
    pub block_height: u64,
    /// Proofs (present only if include_proof=true):
    #[prost(message, optional, tag="3")]
    pub block_header: ::core::option::Option<BlockHeader>,
    #[prost(message, optional, tag="4")]
    pub merkle_proof: ::core::option::Option<MerkleProof>,
    /// Present if include_chain_proof was true
    #[prost(message, optional, tag="5")]
    pub chain_proof: ::core::option::Option<ChainProof>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WatchBlocksRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// First block height to stream. Must be >= 1 (0 is rejected with INVALID_ARGUMENT).
    ///
    /// Behavior:
    /// - If start_height <= current tip: replays committed blocks first, then streams new
    /// - If start_height > current tip: waits for that block, then streams
    ///
    /// Typical usage:
    ///    tip = GetTip()
    ///    stream = WatchBlocks(start_height = tip.height + 1)
    #[prost(uint64, tag="3")]
    pub start_height: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBlockRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(uint64, tag="3")]
    pub height: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockResponse {
    #[prost(message, optional, tag="1")]
    pub block: ::core::option::Option<Block>,
}
/// Fetch multiple blocks for sync/catchup.
/// Use case: Client reconnecting after downtime needs to catch up.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBlockRangeRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// First block to return (inclusive)
    #[prost(uint64, tag="3")]
    pub start_height: u64,
    /// Last block to return (inclusive), max range: 1000 blocks
    #[prost(uint64, tag="4")]
    pub end_height: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockRangeResponse {
    /// Ordered by height ascending
    #[prost(message, repeated, tag="1")]
    pub blocks: ::prost::alloc::vec::Vec<Block>,
    /// Current chain tip (for client to know if more syncing needed)
    #[prost(uint64, tag="2")]
    pub current_tip: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTipRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTipResponse {
    #[prost(uint64, tag="1")]
    pub height: u64,
    #[prost(message, optional, tag="2")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag="3")]
    pub state_root: ::core::option::Option<Hash>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetClientStateRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Omit for namespace-level entity writes
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(message, optional, tag="3")]
    pub client_id: ::core::option::Option<ClientId>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetClientStateResponse {
    #[prost(uint64, tag="1")]
    pub last_committed_sequence: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListRelationshipsRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Filter by resource (exact match)
    #[prost(string, optional, tag="3")]
    pub resource: ::core::option::Option<::prost::alloc::string::String>,
    /// Filter by relation (exact match)
    #[prost(string, optional, tag="4")]
    pub relation: ::core::option::Option<::prost::alloc::string::String>,
    /// Filter by subject (exact match)
    #[prost(string, optional, tag="5")]
    pub subject: ::core::option::Option<::prost::alloc::string::String>,
    /// Read at specific height (0 or omit = current)
    #[prost(uint64, optional, tag="6")]
    pub at_height: ::core::option::Option<u64>,
    /// Max results (0 = default limit)
    #[prost(uint32, tag="7")]
    pub limit: u32,
    /// Opaque pagination cursor from previous response. Server-managed; do not parse or modify.
    /// Encodes position and query context for consistent pagination across requests.
    #[prost(string, tag="8")]
    pub page_token: ::prost::alloc::string::String,
    /// Default: EVENTUAL (any replica)
    #[prost(enumeration="ReadConsistency", tag="9")]
    pub consistency: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRelationshipsResponse {
    #[prost(message, repeated, tag="1")]
    pub relationships: ::prost::alloc::vec::Vec<Relationship>,
    #[prost(uint64, tag="2")]
    pub block_height: u64,
    /// Opaque cursor for next page; empty if no more results
    #[prost(string, tag="3")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListResourcesRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Type prefix (e.g., "document" matches "document:*")
    #[prost(string, tag="3")]
    pub resource_type: ::prost::alloc::string::String,
    /// Read at specific height (0 or omit = current)
    #[prost(uint64, optional, tag="4")]
    pub at_height: ::core::option::Option<u64>,
    /// Max results (0 = default limit)
    #[prost(uint32, tag="5")]
    pub limit: u32,
    /// Opaque pagination cursor from previous response. Server-managed; do not parse or modify.
    #[prost(string, tag="6")]
    pub page_token: ::prost::alloc::string::String,
    /// Default: EVENTUAL (any replica)
    #[prost(enumeration="ReadConsistency", tag="7")]
    pub consistency: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListResourcesResponse {
    /// Full resource IDs (e.g., \["document:1", "document:2"\])
    #[prost(string, repeated, tag="1")]
    pub resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag="2")]
    pub block_height: u64,
    /// Opaque cursor for next page; empty if no more results
    #[prost(string, tag="3")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListEntitiesRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// e.g., "user:", "_idx:email:", "session:"
    #[prost(string, tag="2")]
    pub key_prefix: ::prost::alloc::string::String,
    /// Read at specific height (0 or omit = current)
    #[prost(uint64, optional, tag="3")]
    pub at_height: ::core::option::Option<u64>,
    /// Include entities past expires_at (default: false)
    #[prost(bool, tag="4")]
    pub include_expired: bool,
    /// Max results (0 = default limit)
    #[prost(uint32, tag="5")]
    pub limit: u32,
    /// Opaque pagination cursor from previous response. Server-managed; do not parse or modify.
    #[prost(string, tag="6")]
    pub page_token: ::prost::alloc::string::String,
    /// Default: EVENTUAL (any replica)
    #[prost(enumeration="ReadConsistency", tag="7")]
    pub consistency: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitiesResponse {
    #[prost(message, repeated, tag="1")]
    pub entities: ::prost::alloc::vec::Vec<Entity>,
    #[prost(uint64, tag="2")]
    pub block_height: u64,
    /// Opaque cursor for next page; empty if no more results
    #[prost(string, tag="3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Note: actor is NOT specified by client. Server assigns Transaction.actor
/// from authenticated context (session token, API key, or system identity).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Required for relationships; omit for namespace-level entities
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(message, optional, tag="3")]
    pub client_id: ::core::option::Option<ClientId>,
    #[prost(uint64, tag="4")]
    pub sequence: u64,
    #[prost(message, repeated, tag="5")]
    pub operations: ::prost::alloc::vec::Vec<Operation>,
    /// Request block_header + tx_proof in response for verification
    #[prost(bool, tag="6")]
    pub include_tx_proof: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteResponse {
    #[prost(oneof="write_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<write_response::Result>,
}
/// Nested message and enum types in `WriteResponse`.
pub mod write_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Success(super::WriteSuccess),
        #[prost(message, tag="2")]
        Error(super::WriteError),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteSuccess {
    #[prost(message, optional, tag="1")]
    pub tx_id: ::core::option::Option<TxId>,
    #[prost(uint64, tag="2")]
    pub block_height: u64,
    /// For client-side verification (both present or both absent):
    ///
    /// Contains tx_merkle_root for proof verification
    #[prost(message, optional, tag="3")]
    pub block_header: ::core::option::Option<BlockHeader>,
    /// Proof tx is in block (verify against block_header.tx_merkle_root)
    #[prost(message, optional, tag="4")]
    pub tx_proof: ::core::option::Option<MerkleProof>,
}
/// Detailed error for conditional write failures.
/// Provides enough context for clients to retry with correct values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WriteError {
    #[prost(enumeration="WriteErrorCode", tag="1")]
    pub code: i32,
    /// Which key's condition failed (CAS errors)
    #[prost(string, tag="2")]
    pub key: ::prost::alloc::string::String,
    /// Actual version (for version mismatch)
    #[prost(uint64, optional, tag="3")]
    pub current_version: ::core::option::Option<u64>,
    /// Actual value (for value_equals mismatch, if small)
    #[prost(bytes="vec", optional, tag="4")]
    pub current_value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Human-readable error description
    #[prost(string, tag="5")]
    pub message: ::prost::alloc::string::String,
    /// Sequence error recovery fields (populated for ALREADY_COMMITTED and SEQUENCE_GAP)
    ///
    /// For ALREADY_COMMITTED: original tx_id
    #[prost(message, optional, tag="6")]
    pub committed_tx_id: ::core::option::Option<TxId>,
    /// For ALREADY_COMMITTED: original block_height
    #[prost(uint64, optional, tag="7")]
    pub committed_block_height: ::core::option::Option<u64>,
    /// For SEQUENCE_GAP: server's last seen sequence
    #[prost(uint64, optional, tag="8")]
    pub last_committed_sequence: ::core::option::Option<u64>,
}
/// Batch write with all-or-nothing atomicity.
///
/// Semantics:
/// - All writes are committed in a SINGLE block (shared block_height in response)
/// - Writes are applied in ARRAY ORDER (writes\[0\] before writes\[1\], etc.)
/// - If ANY write's condition fails (e.g., CAS mismatch), the ENTIRE batch fails
/// - On failure, no writes are applied—the vault state is unchanged
///
/// Idempotency: Uses BATCH-LEVEL client_id/sequence (not per-write).
/// The entire batch is the idempotency unit—retry with same (client_id, sequence)
/// returns the original result. Per-write client_id/sequence in writes\[\] are IGNORED.
///
/// Use cases:
/// - Multi-key transactions requiring atomic commit
/// - Ordered operations where later writes depend on earlier writes' effects
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// All writes must target same scope
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Batch-level idempotency (per-write client_id ignored)
    #[prost(message, optional, tag="3")]
    pub client_id: ::core::option::Option<ClientId>,
    /// Batch-level sequence (per-write sequence ignored)
    #[prost(uint64, tag="4")]
    pub sequence: u64,
    /// Operations in this batch
    #[prost(message, repeated, tag="5")]
    pub operations: ::prost::alloc::vec::Vec<BatchWriteOperation>,
    /// Request block_header + tx_proofs in response for verification
    #[prost(bool, tag="6")]
    pub include_tx_proofs: bool,
}
/// Logical grouping of operations within a BatchWriteRequest.
/// Purpose: Allows expressing ordered operation groups within an atomic batch.
/// Processing: Groups are processed in array order (operations\[0\], then operations\[1\], etc.)
///              All groups share the batch's namespace_id, vault_id, client_id, and sequence.
/// Atomicity: The ENTIRE batch is atomic—if any operation fails, no changes are applied.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteOperation {
    /// Operations in this group
    #[prost(message, repeated, tag="1")]
    pub operations: ::prost::alloc::vec::Vec<Operation>,
}
/// Response for batch write.
/// All-or-nothing: either all writes succeed or none are applied.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteResponse {
    #[prost(oneof="batch_write_response::Result", tags="1, 2")]
    pub result: ::core::option::Option<batch_write_response::Result>,
}
/// Nested message and enum types in `BatchWriteResponse`.
pub mod batch_write_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag="1")]
        Success(super::BatchWriteSuccess),
        /// First failing write; no writes applied
        #[prost(message, tag="2")]
        Error(super::WriteError),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteSuccess {
    /// Single transaction ID for entire batch
    #[prost(message, optional, tag="1")]
    pub tx_id: ::core::option::Option<TxId>,
    /// Block containing this transaction
    #[prost(uint64, tag="2")]
    pub block_height: u64,
    /// For client-side verification (optional):
    ///
    /// Contains tx_merkle_root for proof verification
    #[prost(message, optional, tag="3")]
    pub block_header: ::core::option::Option<BlockHeader>,
    /// Proof this tx is in block
    #[prost(message, optional, tag="4")]
    pub tx_proof: ::core::option::Option<MerkleProof>,
}
// -----------------------------------------------------------------------------
// Namespace Messages
// -----------------------------------------------------------------------------

/// Create a new namespace. NamespaceId is leader-assigned from _meta:seq:namespace.
/// The namespace is assigned to the shard with lowest load, or to the specified shard.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateNamespaceRequest {
    /// Human-readable name (e.g., "acme_corp")
    #[prost(string, tag="1")]
    pub name: ::prost::alloc::string::String,
    /// Target shard (auto-assigned if not specified)
    #[prost(message, optional, tag="2")]
    pub shard_id: ::core::option::Option<ShardId>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateNamespaceResponse {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Assigned shard
    #[prost(message, optional, tag="2")]
    pub shard_id: ::core::option::Option<ShardId>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteNamespaceRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteNamespaceResponse {
    #[prost(message, optional, tag="1")]
    pub deleted_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetNamespaceRequest {
    /// Lookup by ID or name (exactly one must be set)
    #[prost(oneof="get_namespace_request::Lookup", tags="1, 2")]
    pub lookup: ::core::option::Option<get_namespace_request::Lookup>,
}
/// Nested message and enum types in `GetNamespaceRequest`.
pub mod get_namespace_request {
    /// Lookup by ID or name (exactly one must be set)
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Lookup {
        #[prost(message, tag="1")]
        NamespaceId(super::NamespaceId),
        #[prost(string, tag="2")]
        Name(::prost::alloc::string::String),
    }
}
/// Namespace registry info (routing metadata from _system)
/// Note: leader_hint is computed dynamically from Raft state via GetSystemState
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNamespaceResponse {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Which shard hosts this namespace
    #[prost(message, optional, tag="3")]
    pub shard_id: ::core::option::Option<ShardId>,
    /// Nodes in the shard
    #[prost(message, repeated, tag="4")]
    pub member_nodes: ::prost::alloc::vec::Vec<NodeId>,
    /// Lifecycle state
    #[prost(enumeration="NamespaceStatus", tag="5")]
    pub status: i32,
    /// For cache invalidation
    #[prost(uint64, tag="6")]
    pub config_version: u64,
    #[prost(message, optional, tag="7")]
    pub created_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListNamespacesRequest {
    #[prost(bytes="vec", optional, tag="1")]
    pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Default: 100, Max: 1000
    #[prost(uint32, tag="2")]
    pub page_size: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNamespacesResponse {
    #[prost(message, repeated, tag="1")]
    pub namespaces: ::prost::alloc::vec::Vec<GetNamespaceResponse>,
    /// Absent if no more pages
    #[prost(bytes="vec", optional, tag="2")]
    pub next_page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
// -----------------------------------------------------------------------------
// Vault Messages
// -----------------------------------------------------------------------------

/// Create a new vault. VaultId is leader-assigned from _meta:seq:vault
/// and returned in CreateVaultResponse.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVaultRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(uint32, tag="2")]
    pub replication_factor: u32,
    #[prost(message, repeated, tag="3")]
    pub initial_nodes: ::prost::alloc::vec::Vec<NodeId>,
    /// Default: FULL
    #[prost(message, optional, tag="4")]
    pub retention_policy: ::core::option::Option<BlockRetentionPolicy>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockRetentionPolicy {
    #[prost(enumeration="BlockRetentionMode", tag="1")]
    pub mode: i32,
    /// For COMPACTED mode: blocks newer than tip - retention_blocks keep full transactions.
    /// Ignored for FULL mode. Default: 10000 blocks.
    #[prost(uint64, tag="2")]
    pub retention_blocks: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateVaultResponse {
    #[prost(message, optional, tag="1")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(message, optional, tag="2")]
    pub genesis: ::core::option::Option<BlockHeader>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteVaultRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteVaultResponse {
    #[prost(message, optional, tag="1")]
    pub deleted_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetVaultRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVaultResponse {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(uint64, tag="3")]
    pub height: u64,
    #[prost(message, optional, tag="4")]
    pub state_root: ::core::option::Option<Hash>,
    #[prost(message, repeated, tag="5")]
    pub nodes: ::prost::alloc::vec::Vec<NodeId>,
    #[prost(message, optional, tag="6")]
    pub leader: ::core::option::Option<NodeId>,
    #[prost(enumeration="VaultStatus", tag="7")]
    pub status: i32,
    #[prost(message, optional, tag="8")]
    pub retention_policy: ::core::option::Option<BlockRetentionPolicy>,
}
/// Empty - lists all vaults on this node
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListVaultsRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVaultsResponse {
    #[prost(message, repeated, tag="1")]
    pub vaults: ::prost::alloc::vec::Vec<GetVaultResponse>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateSnapshotRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateSnapshotResponse {
    #[prost(uint64, tag="1")]
    pub block_height: u64,
    #[prost(message, optional, tag="2")]
    pub state_root: ::core::option::Option<Hash>,
    #[prost(string, tag="3")]
    pub snapshot_path: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CheckIntegrityRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Replay from genesis vs quick check
    #[prost(bool, tag="3")]
    pub full_check: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckIntegrityResponse {
    #[prost(bool, tag="1")]
    pub healthy: bool,
    #[prost(message, repeated, tag="2")]
    pub issues: ::prost::alloc::vec::Vec<IntegrityIssue>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IntegrityIssue {
    #[prost(uint64, tag="1")]
    pub block_height: u64,
    /// "chain_break", "state_divergence", etc.
    #[prost(string, tag="2")]
    pub issue_type: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
}
/// Recover a diverged vault by replaying blocks from archive.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RecoverVaultRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Force recovery even if vault is healthy (for testing/maintenance).
    /// Required for manual intervention after automatic recovery exhausted.
    #[prost(bool, tag="3")]
    pub force: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RecoverVaultResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    /// Error details if !success
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    /// New vault health status after recovery attempt.
    #[prost(enumeration="VaultHealthProto", tag="3")]
    pub health_status: i32,
    /// Final block height after recovery.
    #[prost(uint64, tag="4")]
    pub final_height: u64,
    /// Final state root after recovery (should match expected).
    #[prost(message, optional, tag="5")]
    pub final_state_root: ::core::option::Option<Hash>,
}
/// Request to simulate vault divergence for testing.
/// This forces a vault into the Diverged state without actual corruption.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SimulateDivergenceRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Expected state root (fake value for simulation).
    #[prost(message, optional, tag="3")]
    pub expected_state_root: ::core::option::Option<Hash>,
    /// Computed state root (fake value for simulation).
    #[prost(message, optional, tag="4")]
    pub computed_state_root: ::core::option::Option<Hash>,
    /// Height at which "divergence" occurred.
    #[prost(uint64, tag="5")]
    pub at_height: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SimulateDivergenceResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    /// Vault health status after simulation (should be DIVERGED).
    #[prost(enumeration="VaultHealthProto", tag="3")]
    pub health_status: i32,
}
/// Force a garbage collection cycle for expired entities.
/// If namespace_id and vault_id are specified, only that vault is scanned.
/// If omitted, all vaults are scanned (cluster-wide GC).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ForceGcRequest {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ForceGcResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    /// Number of expired entities that were removed.
    #[prost(uint64, tag="3")]
    pub expired_count: u64,
    /// Number of vaults that were scanned.
    #[prost(uint64, tag="4")]
    pub vaults_scanned: u64,
}
// -----------------------------------------------------------------------------
// Cluster Membership Messages
// -----------------------------------------------------------------------------

/// Request to join an existing cluster.
/// The node provides its ID and address so the leader can add it to Raft.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct JoinClusterRequest {
    /// Numeric node ID for Raft
    #[prost(uint64, tag="1")]
    pub node_id: u64,
    /// gRPC address (e.g., "10.0.0.5:50051")
    #[prost(string, tag="2")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct JoinClusterResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    /// Error details if !success
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    /// Current leader (for redirect if needed)
    #[prost(uint64, tag="3")]
    pub leader_id: u64,
    /// Leader's gRPC address
    #[prost(string, tag="4")]
    pub leader_address: ::prost::alloc::string::String,
}
/// Request to gracefully leave the cluster.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeaveClusterRequest {
    /// Node requesting to leave
    #[prost(uint64, tag="1")]
    pub node_id: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeaveClusterResponse {
    #[prost(bool, tag="1")]
    pub success: bool,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
}
/// Get current cluster membership.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetClusterInfoRequest {
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClusterInfoResponse {
    #[prost(message, repeated, tag="1")]
    pub members: ::prost::alloc::vec::Vec<ClusterMember>,
    #[prost(uint64, tag="2")]
    pub leader_id: u64,
    /// Current Raft term
    #[prost(uint64, tag="3")]
    pub term: u64,
}
/// Request for node identity (empty - no parameters needed).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetNodeInfoRequest {
}
/// Node identity for bootstrap coordination.
/// Available before cluster formation to support coordinated bootstrap.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetNodeInfoResponse {
    /// Node's Snowflake ID (auto-generated, persisted).
    #[prost(uint64, tag="1")]
    pub node_id: u64,
    /// Node's gRPC address (e.g., "192.168.1.10:50051").
    #[prost(string, tag="2")]
    pub address: ::prost::alloc::string::String,
    /// True if node is already part of a cluster.
    #[prost(bool, tag="3")]
    pub is_cluster_member: bool,
    /// Current Raft term (0 if not in cluster).
    #[prost(uint64, tag="4")]
    pub term: u64,
}
/// A member of the Raft cluster.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClusterMember {
    #[prost(uint64, tag="1")]
    pub node_id: u64,
    #[prost(string, tag="2")]
    pub address: ::prost::alloc::string::String,
    #[prost(enumeration="ClusterMemberRole", tag="3")]
    pub role: i32,
    #[prost(bool, tag="4")]
    pub is_leader: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthCheckRequest {
    /// Namespace for vault health check
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// If empty, check node health
    #[prost(message, optional, tag="2")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckResponse {
    #[prost(enumeration="HealthStatus", tag="1")]
    pub status: i32,
    #[prost(string, tag="2")]
    pub message: ::prost::alloc::string::String,
    #[prost(map="string, string", tag="3")]
    pub details: ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPeersRequest {
    /// Limit response size (0 = no limit)
    #[prost(uint32, tag="1")]
    pub max_peers: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPeersResponse {
    #[prost(message, repeated, tag="1")]
    pub peers: ::prost::alloc::vec::Vec<PeerInfo>,
    /// For cache invalidation
    #[prost(uint64, tag="2")]
    pub system_version: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PeerInfo {
    #[prost(message, optional, tag="1")]
    pub node_id: ::core::option::Option<NodeId>,
    /// IP addresses only (no port). IPv4 or IPv6, e.g., \["10.0.0.1", "fd00::1"\].
    /// Must be private/WireGuard IPs—public IPs rejected.
    /// Connect via: addresses\[i\] + ":" + grpc_port
    #[prost(string, repeated, tag="2")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// gRPC port (same for all addresses), typically 5000
    #[prost(uint32, tag="3")]
    pub grpc_port: u32,
    #[prost(message, optional, tag="4")]
    pub last_seen: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AnnouncePeerRequest {
    #[prost(message, optional, tag="1")]
    pub peer: ::core::option::Option<PeerInfo>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AnnouncePeerResponse {
    #[prost(bool, tag="1")]
    pub accepted: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSystemStateRequest {
    /// Return empty if version <= this (cache optimization)
    #[prost(uint64, tag="1")]
    pub if_version_greater_than: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemStateResponse {
    #[prost(uint64, tag="1")]
    pub version: u64,
    #[prost(message, repeated, tag="2")]
    pub nodes: ::prost::alloc::vec::Vec<NodeInfo>,
    /// Routing table: namespace → shard
    #[prost(message, repeated, tag="3")]
    pub namespaces: ::prost::alloc::vec::Vec<NamespaceRegistry>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeInfo {
    #[prost(message, optional, tag="1")]
    pub node_id: ::core::option::Option<NodeId>,
    /// IP addresses only (no port). IPv4 or IPv6, e.g., \["10.0.0.1", "fd00::1"\].
    /// Must be private/WireGuard IPs—public IPs rejected.
    /// Connect via: addresses\[i\] + ":" + grpc_port
    #[prost(string, repeated, tag="2")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// gRPC port (same for all addresses), typically 5000
    #[prost(uint32, tag="3")]
    pub grpc_port: u32,
    /// Voter or Learner
    #[prost(enumeration="NodeRole", tag="4")]
    pub role: i32,
    #[prost(message, optional, tag="5")]
    pub last_heartbeat: ::core::option::Option<super::super::google::protobuf::Timestamp>,
    /// For voter election ordering
    #[prost(message, optional, tag="6")]
    pub joined_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
/// Routing entry: namespace → shard assignment
/// Note: leader_hint is computed dynamically from Raft state, not stored here
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespaceRegistry {
    #[prost(message, optional, tag="1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Human-readable namespace name
    #[prost(string, tag="2")]
    pub name: ::prost::alloc::string::String,
    /// Which Raft group hosts this namespace
    #[prost(message, optional, tag="3")]
    pub shard_id: ::core::option::Option<ShardId>,
    /// Nodes in the shard
    #[prost(message, repeated, tag="4")]
    pub members: ::prost::alloc::vec::Vec<NodeId>,
    /// Lifecycle state
    #[prost(enumeration="NamespaceStatus", tag="5")]
    pub status: i32,
    /// For cache invalidation
    #[prost(uint64, tag="6")]
    pub config_version: u64,
    #[prost(message, optional, tag="7")]
    pub created_at: ::core::option::Option<super::super::google::protobuf::Timestamp>,
}
/// Raft vote (term + node_id + committed flag).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftVote {
    #[prost(uint64, tag="1")]
    pub term: u64,
    #[prost(uint64, tag="2")]
    pub node_id: u64,
    #[prost(bool, tag="3")]
    pub committed: bool,
}
/// Raft log entry identifier.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftLogId {
    #[prost(uint64, tag="1")]
    pub term: u64,
    #[prost(uint64, tag="2")]
    pub index: u64,
}
/// Vote request during leader election.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftVoteRequest {
    #[prost(message, optional, tag="1")]
    pub vote: ::core::option::Option<RaftVote>,
    #[prost(message, optional, tag="2")]
    pub last_log_id: ::core::option::Option<RaftLogId>,
    /// Shard ID for multi-shard routing (defaults to system shard 0).
    #[prost(uint64, optional, tag="3")]
    pub shard_id: ::core::option::Option<u64>,
}
/// Vote response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftVoteResponse {
    #[prost(message, optional, tag="1")]
    pub vote: ::core::option::Option<RaftVote>,
    #[prost(bool, tag="2")]
    pub vote_granted: bool,
    #[prost(message, optional, tag="3")]
    pub last_log_id: ::core::option::Option<RaftLogId>,
}
/// Log replication request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftAppendEntriesRequest {
    #[prost(message, optional, tag="1")]
    pub vote: ::core::option::Option<RaftVote>,
    #[prost(message, optional, tag="2")]
    pub prev_log_id: ::core::option::Option<RaftLogId>,
    /// Serialized log entries
    #[prost(bytes="vec", repeated, tag="3")]
    pub entries: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag="4")]
    pub leader_commit: ::core::option::Option<RaftLogId>,
    /// Shard ID for multi-shard routing (defaults to system shard 0).
    #[prost(uint64, optional, tag="5")]
    pub shard_id: ::core::option::Option<u64>,
}
/// Log replication response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftAppendEntriesResponse {
    #[prost(message, optional, tag="1")]
    pub vote: ::core::option::Option<RaftVote>,
    #[prost(bool, tag="2")]
    pub success: bool,
    #[prost(bool, tag="3")]
    pub conflict: bool,
}
/// Snapshot installation request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaftInstallSnapshotRequest {
    #[prost(message, optional, tag="1")]
    pub vote: ::core::option::Option<RaftVote>,
    #[prost(message, optional, tag="2")]
    pub meta: ::core::option::Option<RaftSnapshotMeta>,
    #[prost(uint64, tag="3")]
    pub offset: u64,
    #[prost(bytes="vec", tag="4")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag="5")]
    pub done: bool,
    /// Shard ID for multi-shard routing (defaults to system shard 0).
    #[prost(uint64, optional, tag="6")]
    pub shard_id: ::core::option::Option<u64>,
}
/// Snapshot installation response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftInstallSnapshotResponse {
    #[prost(message, optional, tag="1")]
    pub vote: ::core::option::Option<RaftVote>,
}
/// Snapshot metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaftSnapshotMeta {
    #[prost(message, optional, tag="1")]
    pub last_log_id: ::core::option::Option<RaftLogId>,
    #[prost(message, optional, tag="2")]
    pub last_membership: ::core::option::Option<RaftMembership>,
    #[prost(string, tag="3")]
    pub snapshot_id: ::prost::alloc::string::String,
}
/// Raft cluster membership configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaftMembership {
    #[prost(message, repeated, tag="1")]
    pub configs: ::prost::alloc::vec::Vec<RaftMembershipConfig>,
}
/// Single membership configuration (joint consensus may have multiple).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaftMembershipConfig {
    /// Map of node_id -> address
    #[prost(map="uint64, string", tag="1")]
    pub members: ::std::collections::HashMap<u64, ::prost::alloc::string::String>,
}
/// User account status (lifecycle state machine)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserStatus {
    Unspecified = 0,
    /// User can authenticate
    Active = 1,
    /// Pending organization creation (saga in progress)
    PendingOrg = 2,
    /// User cannot authenticate
    Suspended = 3,
    /// Deletion cascade in progress
    Deleting = 4,
    /// Tombstone for audit
    Deleted = 5,
}
impl UserStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "USER_STATUS_UNSPECIFIED",
            Self::Active => "USER_STATUS_ACTIVE",
            Self::PendingOrg => "USER_STATUS_PENDING_ORG",
            Self::Suspended => "USER_STATUS_SUSPENDED",
            Self::Deleting => "USER_STATUS_DELETING",
            Self::Deleted => "USER_STATUS_DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "USER_STATUS_ACTIVE" => Some(Self::Active),
            "USER_STATUS_PENDING_ORG" => Some(Self::PendingOrg),
            "USER_STATUS_SUSPENDED" => Some(Self::Suspended),
            "USER_STATUS_DELETING" => Some(Self::Deleting),
            "USER_STATUS_DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
// =============================================================================
// Merkle Proof Types
// =============================================================================

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Direction {
    Unspecified = 0,
    Left = 1,
    Right = 2,
}
impl Direction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DIRECTION_UNSPECIFIED",
            Self::Left => "DIRECTION_LEFT",
            Self::Right => "DIRECTION_RIGHT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
            "DIRECTION_LEFT" => Some(Self::Left),
            "DIRECTION_RIGHT" => Some(Self::Right),
            _ => None,
        }
    }
}
/// Read consistency levels for read operations.
/// Trade-off between consistency and performance/availability.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReadConsistency {
    /// Server default (typically EVENTUAL)
    Unspecified = 0,
    /// Read from any replica (fastest, may be stale)
    Eventual = 1,
    /// Read from leader (strong consistency, higher latency)
    Linearizable = 2,
}
impl ReadConsistency {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "READ_CONSISTENCY_UNSPECIFIED",
            Self::Eventual => "READ_CONSISTENCY_EVENTUAL",
            Self::Linearizable => "READ_CONSISTENCY_LINEARIZABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "READ_CONSISTENCY_UNSPECIFIED" => Some(Self::Unspecified),
            "READ_CONSISTENCY_EVENTUAL" => Some(Self::Eventual),
            "READ_CONSISTENCY_LINEARIZABLE" => Some(Self::Linearizable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WriteErrorCode {
    Unspecified = 0,
    /// not_exists condition failed: key already exists
    KeyExists = 1,
    /// version/value_equals condition: key doesn't exist
    KeyNotFound = 2,
    /// version condition: block height differs
    VersionMismatch = 3,
    /// value_equals condition: value differs
    ValueMismatch = 4,
    /// Sequence errors (split for client recovery)
    ///
    /// Duplicate: sequence already committed
    AlreadyCommitted = 5,
    /// Recovery: use committed_tx_id, committed_block_height
    ///
    /// Gap: sequence > last_committed + 1
    SequenceGap = 6,
}
impl WriteErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WRITE_ERROR_CODE_UNSPECIFIED",
            Self::KeyExists => "WRITE_ERROR_CODE_KEY_EXISTS",
            Self::KeyNotFound => "WRITE_ERROR_CODE_KEY_NOT_FOUND",
            Self::VersionMismatch => "WRITE_ERROR_CODE_VERSION_MISMATCH",
            Self::ValueMismatch => "WRITE_ERROR_CODE_VALUE_MISMATCH",
            Self::AlreadyCommitted => "WRITE_ERROR_CODE_ALREADY_COMMITTED",
            Self::SequenceGap => "WRITE_ERROR_CODE_SEQUENCE_GAP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WRITE_ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "WRITE_ERROR_CODE_KEY_EXISTS" => Some(Self::KeyExists),
            "WRITE_ERROR_CODE_KEY_NOT_FOUND" => Some(Self::KeyNotFound),
            "WRITE_ERROR_CODE_VERSION_MISMATCH" => Some(Self::VersionMismatch),
            "WRITE_ERROR_CODE_VALUE_MISMATCH" => Some(Self::ValueMismatch),
            "WRITE_ERROR_CODE_ALREADY_COMMITTED" => Some(Self::AlreadyCommitted),
            "WRITE_ERROR_CODE_SEQUENCE_GAP" => Some(Self::SequenceGap),
            _ => None,
        }
    }
}
/// Error codes for read operations.
/// Used in gRPC status details for structured error handling.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReadErrorCode {
    Unspecified = 0,
    /// Requested height is outside retention window (pruned from storage).
    /// Recovery: Use a more recent height, or re-sync from current tip.
    /// Pagination: If height becomes unavailable mid-pagination, restart
    /// query at current tip with fresh page_token.
    HeightUnavailable = 1,
}
impl ReadErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "READ_ERROR_CODE_UNSPECIFIED",
            Self::HeightUnavailable => "READ_ERROR_CODE_HEIGHT_UNAVAILABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "READ_ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "READ_ERROR_CODE_HEIGHT_UNAVAILABLE" => Some(Self::HeightUnavailable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NamespaceStatus {
    Unspecified = 0,
    /// Accepting requests
    Active = 1,
    /// Being migrated to another shard
    Migrating = 2,
    /// Billing or policy suspension
    Suspended = 3,
    /// Deletion in progress
    Deleting = 4,
    /// Tombstone
    Deleted = 5,
}
impl NamespaceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NAMESPACE_STATUS_UNSPECIFIED",
            Self::Active => "NAMESPACE_STATUS_ACTIVE",
            Self::Migrating => "NAMESPACE_STATUS_MIGRATING",
            Self::Suspended => "NAMESPACE_STATUS_SUSPENDED",
            Self::Deleting => "NAMESPACE_STATUS_DELETING",
            Self::Deleted => "NAMESPACE_STATUS_DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NAMESPACE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "NAMESPACE_STATUS_ACTIVE" => Some(Self::Active),
            "NAMESPACE_STATUS_MIGRATING" => Some(Self::Migrating),
            "NAMESPACE_STATUS_SUSPENDED" => Some(Self::Suspended),
            "NAMESPACE_STATUS_DELETING" => Some(Self::Deleting),
            "NAMESPACE_STATUS_DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
/// Block retention modes for storage/compliance trade-off.
/// See DESIGN.md "Snapshot & Retention Policy" for details.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BlockRetentionMode {
    Unspecified = 0,
    /// Keep all blocks with full transactions indefinitely.
    /// Use case: SOC 2, HIPAA compliance requiring full audit trail.
    Full = 1,
    /// After snapshot, remove transaction bodies for old blocks (headers preserved).
    /// Use case: High-volume workloads prioritizing storage efficiency.
    Compacted = 2,
}
impl BlockRetentionMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BLOCK_RETENTION_MODE_UNSPECIFIED",
            Self::Full => "BLOCK_RETENTION_MODE_FULL",
            Self::Compacted => "BLOCK_RETENTION_MODE_COMPACTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BLOCK_RETENTION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "BLOCK_RETENTION_MODE_FULL" => Some(Self::Full),
            "BLOCK_RETENTION_MODE_COMPACTED" => Some(Self::Compacted),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VaultStatus {
    Unspecified = 0,
    Active = 1,
    ReadOnly = 2,
    Deleted = 3,
}
impl VaultStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VAULT_STATUS_UNSPECIFIED",
            Self::Active => "VAULT_STATUS_ACTIVE",
            Self::ReadOnly => "VAULT_STATUS_READ_ONLY",
            Self::Deleted => "VAULT_STATUS_DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VAULT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "VAULT_STATUS_ACTIVE" => Some(Self::Active),
            "VAULT_STATUS_READ_ONLY" => Some(Self::ReadOnly),
            "VAULT_STATUS_DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
/// Vault health status (mirrors internal VaultHealthStatus enum).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VaultHealthProto {
    Unspecified = 0,
    Healthy = 1,
    Diverged = 2,
    Recovering = 3,
}
impl VaultHealthProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VAULT_HEALTH_PROTO_UNSPECIFIED",
            Self::Healthy => "VAULT_HEALTH_PROTO_HEALTHY",
            Self::Diverged => "VAULT_HEALTH_PROTO_DIVERGED",
            Self::Recovering => "VAULT_HEALTH_PROTO_RECOVERING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VAULT_HEALTH_PROTO_UNSPECIFIED" => Some(Self::Unspecified),
            "VAULT_HEALTH_PROTO_HEALTHY" => Some(Self::Healthy),
            "VAULT_HEALTH_PROTO_DIVERGED" => Some(Self::Diverged),
            "VAULT_HEALTH_PROTO_RECOVERING" => Some(Self::Recovering),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClusterMemberRole {
    Unspecified = 0,
    /// Full voting member
    Voter = 1,
    /// Receiving logs but can't vote
    Learner = 2,
}
impl ClusterMemberRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLUSTER_MEMBER_ROLE_UNSPECIFIED",
            Self::Voter => "CLUSTER_MEMBER_ROLE_VOTER",
            Self::Learner => "CLUSTER_MEMBER_ROLE_LEARNER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLUSTER_MEMBER_ROLE_UNSPECIFIED" => Some(Self::Unspecified),
            "CLUSTER_MEMBER_ROLE_VOTER" => Some(Self::Voter),
            "CLUSTER_MEMBER_ROLE_LEARNER" => Some(Self::Learner),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatus {
    Unspecified = 0,
    Healthy = 1,
    Degraded = 2,
    Unavailable = 3,
}
impl HealthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "HEALTH_STATUS_UNSPECIFIED",
            Self::Healthy => "HEALTH_STATUS_HEALTHY",
            Self::Degraded => "HEALTH_STATUS_DEGRADED",
            Self::Unavailable => "HEALTH_STATUS_UNAVAILABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "HEALTH_STATUS_HEALTHY" => Some(Self::Healthy),
            "HEALTH_STATUS_DEGRADED" => Some(Self::Degraded),
            "HEALTH_STATUS_UNAVAILABLE" => Some(Self::Unavailable),
            _ => None,
        }
    }
}
/// Node role in the cluster (Raft membership type)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeRole {
    Unspecified = 0,
    /// Participates in Raft elections (max 5 per cluster)
    Voter = 1,
    /// Replicates data but doesn't vote (for scaling)
    Learner = 2,
}
impl NodeRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NODE_ROLE_UNSPECIFIED",
            Self::Voter => "NODE_ROLE_VOTER",
            Self::Learner => "NODE_ROLE_LEARNER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_ROLE_UNSPECIFIED" => Some(Self::Unspecified),
            "NODE_ROLE_VOTER" => Some(Self::Voter),
            "NODE_ROLE_LEARNER" => Some(Self::Learner),
            _ => None,
        }
    }
}
include!("ledger.v1.tonic.rs");
// @@protoc_insertion_point(module)