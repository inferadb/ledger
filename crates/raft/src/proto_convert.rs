//! Centralized proto conversion functions.
//!
//! This module provides `From` and `Into` implementations for converting between
//! domain types (from `inferadb_ledger_types`) and proto types (generated by prost).
//!
//! # Design
//!
//! Rather than scattering `foo_to_proto` and `proto_to_foo` functions across
//! service files, we centralize all conversions here using Rust's `From` trait.
//! This enables idiomatic `.into()` calls and ensures consistent, tested conversions.
//!
//! # Usage
//!
//! ```ignore
//! use crate::proto_convert::*;
//!
//! // Domain to proto
//! let proto_op: proto::Operation = domain_op.into();
//!
//! // Proto to domain  
//! let domain_vote: Vote<LedgerNodeId> = proto_vote.into();
//! ```

use inferadb_ledger_types::merkle::MerkleProof as InternalMerkleProof;
use openraft::Vote;
use tonic::Status;

use crate::{
    proto,
    types::{BlockRetentionMode, BlockRetentionPolicy, LedgerNodeId},
};

// =============================================================================
// Vote conversions (openraft::Vote <-> proto::RaftVote)
// =============================================================================

impl From<&Vote<LedgerNodeId>> for proto::RaftVote {
    fn from(vote: &Vote<LedgerNodeId>) -> Self {
        proto::RaftVote {
            term: vote.leader_id.term,
            node_id: vote.leader_id.node_id,
            committed: vote.committed,
        }
    }
}

impl From<Vote<LedgerNodeId>> for proto::RaftVote {
    fn from(vote: Vote<LedgerNodeId>) -> Self {
        (&vote).into()
    }
}

impl From<&proto::RaftVote> for Vote<LedgerNodeId> {
    fn from(proto: &proto::RaftVote) -> Self {
        if proto.committed {
            Vote::new_committed(proto.term, proto.node_id)
        } else {
            Vote::new(proto.term, proto.node_id)
        }
    }
}

impl From<proto::RaftVote> for Vote<LedgerNodeId> {
    fn from(proto: proto::RaftVote) -> Self {
        (&proto).into()
    }
}

// =============================================================================
// Operation conversions (inferadb_ledger_types::Operation <-> proto::Operation)
// =============================================================================

impl From<&inferadb_ledger_types::Operation> for proto::Operation {
    fn from(op: &inferadb_ledger_types::Operation) -> Self {
        use inferadb_ledger_types::Operation as LedgerOp;
        use proto::operation::Op;

        match op {
            LedgerOp::CreateRelationship { resource, relation, subject } => proto::Operation {
                op: Some(Op::CreateRelationship(proto::CreateRelationship {
                    resource: resource.clone(),
                    relation: relation.clone(),
                    subject: subject.clone(),
                })),
            },
            LedgerOp::DeleteRelationship { resource, relation, subject } => proto::Operation {
                op: Some(Op::DeleteRelationship(proto::DeleteRelationship {
                    resource: resource.clone(),
                    relation: relation.clone(),
                    subject: subject.clone(),
                })),
            },
            LedgerOp::SetEntity { key, value, condition, expires_at } => {
                let condition_proto = condition.as_ref().map(|c| c.into());

                proto::Operation {
                    op: Some(Op::SetEntity(proto::SetEntity {
                        key: key.clone(),
                        value: value.clone(),
                        condition: condition_proto,
                        expires_at: *expires_at,
                    })),
                }
            },
            LedgerOp::DeleteEntity { key } => proto::Operation {
                op: Some(Op::DeleteEntity(proto::DeleteEntity { key: key.clone() })),
            },
            LedgerOp::ExpireEntity { key, expired_at } => proto::Operation {
                op: Some(Op::ExpireEntity(proto::ExpireEntity {
                    key: key.clone(),
                    expired_at: *expired_at,
                })),
            },
        }
    }
}

impl From<inferadb_ledger_types::Operation> for proto::Operation {
    fn from(op: inferadb_ledger_types::Operation) -> Self {
        (&op).into()
    }
}

// =============================================================================
// SetCondition conversions (inferadb_ledger_types::SetCondition <-> proto::SetCondition)
// =============================================================================

impl From<&inferadb_ledger_types::SetCondition> for proto::SetCondition {
    fn from(c: &inferadb_ledger_types::SetCondition) -> Self {
        use proto::set_condition::Condition;

        let condition = match c {
            inferadb_ledger_types::SetCondition::MustNotExist => Condition::NotExists(true),
            inferadb_ledger_types::SetCondition::MustExist => {
                // Proto uses must_exists field for this
                Condition::MustExists(true)
            },
            inferadb_ledger_types::SetCondition::VersionEquals(v) => Condition::Version(*v),
            inferadb_ledger_types::SetCondition::ValueEquals(bytes) => {
                Condition::ValueEquals(bytes.clone())
            },
        };

        proto::SetCondition { condition: Some(condition) }
    }
}

impl From<inferadb_ledger_types::SetCondition> for proto::SetCondition {
    fn from(c: inferadb_ledger_types::SetCondition) -> Self {
        (&c).into()
    }
}

// =============================================================================
// SetCondition conversions (proto::SetCondition -> inferadb_ledger_types::SetCondition)
// =============================================================================

/// Convert a proto `SetCondition` to an optional domain `SetCondition`.
///
/// Returns `None` if the proto condition field is not set.
/// The `NotExists(false)` and `MustExists(false)` cases map to their logical
/// inverses for backward compatibility with proto3 default values.
impl From<&proto::SetCondition> for Option<inferadb_ledger_types::SetCondition> {
    fn from(proto: &proto::SetCondition) -> Self {
        use proto::set_condition::Condition;

        proto.condition.as_ref().map(|c| match c {
            Condition::NotExists(true) => inferadb_ledger_types::SetCondition::MustNotExist,
            Condition::NotExists(false) => inferadb_ledger_types::SetCondition::MustExist,
            Condition::MustExists(true) => inferadb_ledger_types::SetCondition::MustExist,
            Condition::MustExists(false) => inferadb_ledger_types::SetCondition::MustNotExist,
            Condition::Version(v) => inferadb_ledger_types::SetCondition::VersionEquals(*v),
            Condition::ValueEquals(v) => {
                inferadb_ledger_types::SetCondition::ValueEquals(v.clone())
            },
        })
    }
}

// =============================================================================
// Operation conversions (proto::Operation -> inferadb_ledger_types::Operation)
// =============================================================================

impl TryFrom<&proto::Operation> for inferadb_ledger_types::Operation {
    type Error = Status;

    fn try_from(proto_op: &proto::Operation) -> Result<Self, Self::Error> {
        use proto::operation::Op;

        let op = proto_op
            .op
            .as_ref()
            .ok_or_else(|| Status::invalid_argument("Operation missing op field"))?;

        match op {
            Op::CreateRelationship(cr) => {
                Ok(inferadb_ledger_types::Operation::CreateRelationship {
                    resource: cr.resource.clone(),
                    relation: cr.relation.clone(),
                    subject: cr.subject.clone(),
                })
            },
            Op::DeleteRelationship(dr) => {
                Ok(inferadb_ledger_types::Operation::DeleteRelationship {
                    resource: dr.resource.clone(),
                    relation: dr.relation.clone(),
                    subject: dr.subject.clone(),
                })
            },
            Op::SetEntity(se) => {
                let condition: Option<inferadb_ledger_types::SetCondition> =
                    se.condition.as_ref().and_then(|c| c.into());

                Ok(inferadb_ledger_types::Operation::SetEntity {
                    key: se.key.clone(),
                    value: se.value.clone(),
                    condition,
                    expires_at: se.expires_at,
                })
            },
            Op::DeleteEntity(de) => {
                Ok(inferadb_ledger_types::Operation::DeleteEntity { key: de.key.clone() })
            },
            Op::ExpireEntity(ee) => Ok(inferadb_ledger_types::Operation::ExpireEntity {
                key: ee.key.clone(),
                expired_at: ee.expired_at,
            }),
        }
    }
}

impl TryFrom<proto::Operation> for inferadb_ledger_types::Operation {
    type Error = Status;

    fn try_from(proto_op: proto::Operation) -> Result<Self, Self::Error> {
        Self::try_from(&proto_op)
    }
}

// =============================================================================
// NamespaceStatus conversions
// =============================================================================

impl From<inferadb_ledger_state::system::NamespaceStatus> for proto::NamespaceStatus {
    fn from(status: inferadb_ledger_state::system::NamespaceStatus) -> Self {
        use inferadb_ledger_state::system::NamespaceStatus;

        match status {
            NamespaceStatus::Active => proto::NamespaceStatus::Active,
            NamespaceStatus::Migrating => proto::NamespaceStatus::Migrating,
            NamespaceStatus::Suspended => proto::NamespaceStatus::Suspended,
            NamespaceStatus::Deleting => proto::NamespaceStatus::Deleting,
            NamespaceStatus::Deleted => proto::NamespaceStatus::Deleted,
        }
    }
}

// =============================================================================
// Entity conversions (inferadb_ledger_types::Entity -> proto::Entity)
// =============================================================================

impl From<&inferadb_ledger_types::Entity> for proto::Entity {
    fn from(e: &inferadb_ledger_types::Entity) -> Self {
        proto::Entity {
            key: String::from_utf8_lossy(&e.key).to_string(),
            value: e.value.clone(),
            version: e.version,
            // Convert 0 (never expires) to None
            expires_at: if e.expires_at == 0 { None } else { Some(e.expires_at) },
        }
    }
}

// =============================================================================
// Relationship conversions (inferadb_ledger_types::Relationship -> proto::Relationship)
// =============================================================================

impl From<&inferadb_ledger_types::Relationship> for proto::Relationship {
    fn from(r: &inferadb_ledger_types::Relationship) -> Self {
        proto::Relationship {
            resource: r.resource.clone(),
            relation: r.relation.clone(),
            subject: r.subject.clone(),
        }
    }
}

impl From<inferadb_ledger_types::Relationship> for proto::Relationship {
    fn from(r: inferadb_ledger_types::Relationship) -> Self {
        proto::Relationship { resource: r.resource, relation: r.relation, subject: r.subject }
    }
}

// =============================================================================
// BlockRetentionPolicy conversions
// =============================================================================

impl From<BlockRetentionMode> for proto::BlockRetentionMode {
    fn from(mode: BlockRetentionMode) -> Self {
        match mode {
            BlockRetentionMode::Full => proto::BlockRetentionMode::Full,
            BlockRetentionMode::Compacted => proto::BlockRetentionMode::Compacted,
        }
    }
}

impl From<&proto::BlockRetentionPolicy> for BlockRetentionPolicy {
    fn from(proto_policy: &proto::BlockRetentionPolicy) -> Self {
        let mode = match proto_policy.mode() {
            proto::BlockRetentionMode::Unspecified | proto::BlockRetentionMode::Full => {
                BlockRetentionMode::Full
            },
            proto::BlockRetentionMode::Compacted => BlockRetentionMode::Compacted,
        };

        BlockRetentionPolicy {
            mode,
            retention_blocks: if proto_policy.retention_blocks > 0 {
                proto_policy.retention_blocks
            } else {
                10_000 // Default
            },
        }
    }
}

impl From<BlockRetentionPolicy> for proto::BlockRetentionPolicy {
    fn from(policy: BlockRetentionPolicy) -> Self {
        proto::BlockRetentionPolicy {
            mode: proto::BlockRetentionMode::from(policy.mode).into(),
            retention_blocks: policy.retention_blocks,
        }
    }
}

// =============================================================================
// MerkleProof conversions (InternalMerkleProof -> proto::MerkleProof)
// =============================================================================

impl From<&InternalMerkleProof> for proto::MerkleProof {
    /// Convert an internal MerkleProof to a proto MerkleProof.
    ///
    /// The internal format stores raw sibling hashes with the leaf_index to
    /// determine direction. The proto format explicitly encodes direction for
    /// each sibling.
    fn from(internal: &InternalMerkleProof) -> Self {
        use proto::Direction;

        let mut index = internal.leaf_index;
        let mut siblings = Vec::with_capacity(internal.proof_hashes.len());

        for hash in &internal.proof_hashes {
            // If current index is even (left child), sibling is on the right
            // If current index is odd (right child), sibling is on the left
            let direction = if index.is_multiple_of(2) {
                Direction::Right // sibling is right, so we do hash(current || sibling)
            } else {
                Direction::Left // sibling is left, so we do hash(sibling || current)
            };

            siblings.push(proto::MerkleSibling {
                hash: Some(proto::Hash { value: hash.to_vec() }),
                direction: direction.into(),
            });

            // Move up to parent index
            index /= 2;
        }

        proto::MerkleProof {
            leaf_hash: Some(proto::Hash { value: internal.leaf_hash.to_vec() }),
            siblings,
        }
    }
}

impl From<InternalMerkleProof> for proto::MerkleProof {
    fn from(internal: InternalMerkleProof) -> Self {
        (&internal).into()
    }
}

// =============================================================================
// VaultEntry to Block conversion (special case - requires ShardBlock context)
// =============================================================================

/// Convert a VaultEntry from storage to a proto Block.
///
/// This is a method rather than a `From` impl because it requires additional
/// context (the ShardBlock) to populate the block header timestamp and leader info.
pub fn vault_entry_to_proto_block(
    entry: &inferadb_ledger_types::VaultEntry,
    shard_block: &inferadb_ledger_types::ShardBlock,
) -> proto::Block {
    use prost_types::Timestamp;

    // Convert VaultEntry transactions to proto transactions
    let transactions = entry
        .transactions
        .iter()
        .map(|tx| proto::Transaction {
            id: Some(proto::TxId { id: tx.id.to_vec() }),
            client_id: Some(proto::ClientId { id: tx.client_id.clone() }),
            sequence: tx.sequence,
            operations: tx.operations.iter().map(|op| op.into()).collect(),
            timestamp: Some(Timestamp {
                seconds: tx.timestamp.timestamp(),
                nanos: tx.timestamp.timestamp_subsec_nanos() as i32,
            }),
            actor: tx.actor.clone(),
        })
        .collect();

    // Build block header
    let header = proto::BlockHeader {
        height: entry.vault_height,
        namespace_id: Some(proto::NamespaceId { id: entry.namespace_id.value() }),
        vault_id: Some(proto::VaultId { id: entry.vault_id.value() }),
        previous_hash: Some(proto::Hash { value: entry.previous_vault_hash.to_vec() }),
        tx_merkle_root: Some(proto::Hash { value: entry.tx_merkle_root.to_vec() }),
        state_root: Some(proto::Hash { value: entry.state_root.to_vec() }),
        timestamp: Some(Timestamp {
            seconds: shard_block.timestamp.timestamp(),
            nanos: shard_block.timestamp.timestamp_subsec_nanos() as i32,
        }),
        leader_id: Some(proto::NodeId { id: shard_block.leader_id.clone() }),
        term: shard_block.term,
        committed_index: shard_block.committed_index,
    };

    proto::Block { header: Some(header), transactions }
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    #![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic, clippy::disallowed_methods)]

    use inferadb_ledger_types::hash::Hash;

    use super::*;

    // -------------------------------------------------------------------------
    // Vote conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_vote_to_proto_uncommitted() {
        let vote = Vote::new(5, 42);
        let proto: proto::RaftVote = (&vote).into();

        assert_eq!(proto.term, 5);
        assert_eq!(proto.node_id, 42);
        assert!(!proto.committed);
    }

    #[test]
    fn test_vote_to_proto_committed() {
        let vote = Vote::new_committed(10, 99);
        let proto: proto::RaftVote = (&vote).into();

        assert_eq!(proto.term, 10);
        assert_eq!(proto.node_id, 99);
        assert!(proto.committed);
    }

    #[test]
    fn test_proto_to_vote_uncommitted() {
        let proto = proto::RaftVote { term: 7, node_id: 123, committed: false };
        let vote: Vote<LedgerNodeId> = proto.into();

        assert_eq!(vote.leader_id.term, 7);
        assert_eq!(vote.leader_id.node_id, 123);
        assert!(!vote.committed);
    }

    #[test]
    fn test_proto_to_vote_committed() {
        let proto = proto::RaftVote { term: 15, node_id: 456, committed: true };
        let vote: Vote<LedgerNodeId> = proto.into();

        assert_eq!(vote.leader_id.term, 15);
        assert_eq!(vote.leader_id.node_id, 456);
        assert!(vote.committed);
    }

    #[test]
    fn test_vote_roundtrip() {
        // Uncommitted roundtrip
        let original = Vote::new(100, 200);
        let proto: proto::RaftVote = (&original).into();
        let recovered: Vote<LedgerNodeId> = proto.into();

        assert_eq!(original.leader_id.term, recovered.leader_id.term);
        assert_eq!(original.leader_id.node_id, recovered.leader_id.node_id);
        assert_eq!(original.committed, recovered.committed);

        // Committed roundtrip
        let original_committed = Vote::new_committed(50, 60);
        let proto_committed: proto::RaftVote = (&original_committed).into();
        let recovered_committed: Vote<LedgerNodeId> = proto_committed.into();

        assert_eq!(original_committed.leader_id.term, recovered_committed.leader_id.term);
        assert_eq!(original_committed.leader_id.node_id, recovered_committed.leader_id.node_id);
        assert_eq!(original_committed.committed, recovered_committed.committed);
    }

    // -------------------------------------------------------------------------
    // SetCondition conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_condition_must_not_exist() {
        let condition = inferadb_ledger_types::SetCondition::MustNotExist;
        let proto: proto::SetCondition = (&condition).into();

        assert!(matches!(proto.condition, Some(proto::set_condition::Condition::NotExists(true))));
    }

    #[test]
    fn test_condition_must_exist() {
        let condition = inferadb_ledger_types::SetCondition::MustExist;
        let proto: proto::SetCondition = (&condition).into();

        assert!(matches!(proto.condition, Some(proto::set_condition::Condition::MustExists(true))));
    }

    #[test]
    fn test_condition_version_equals() {
        let condition = inferadb_ledger_types::SetCondition::VersionEquals(42);
        let proto: proto::SetCondition = (&condition).into();

        assert!(matches!(proto.condition, Some(proto::set_condition::Condition::Version(42))));
    }

    #[test]
    fn test_condition_value_equals() {
        let condition = inferadb_ledger_types::SetCondition::ValueEquals(vec![1, 2, 3, 4]);
        let proto: proto::SetCondition = (&condition).into();

        match proto.condition {
            Some(proto::set_condition::Condition::ValueEquals(bytes)) => {
                assert_eq!(bytes, vec![1, 2, 3, 4]);
            },
            _ => panic!("Expected ValueEquals condition"),
        }
    }

    // -------------------------------------------------------------------------
    // Operation conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_operation_create_relationship() {
        let op = inferadb_ledger_types::Operation::CreateRelationship {
            resource: "doc:123".to_string(),
            relation: "viewer".to_string(),
            subject: "user:456".to_string(),
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::CreateRelationship(cr)) => {
                assert_eq!(cr.resource, "doc:123");
                assert_eq!(cr.relation, "viewer");
                assert_eq!(cr.subject, "user:456");
            },
            _ => panic!("Expected CreateRelationship operation"),
        }
    }

    #[test]
    fn test_operation_delete_relationship() {
        let op = inferadb_ledger_types::Operation::DeleteRelationship {
            resource: "folder:abc".to_string(),
            relation: "editor".to_string(),
            subject: "team:xyz".to_string(),
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::DeleteRelationship(dr)) => {
                assert_eq!(dr.resource, "folder:abc");
                assert_eq!(dr.relation, "editor");
                assert_eq!(dr.subject, "team:xyz");
            },
            _ => panic!("Expected DeleteRelationship operation"),
        }
    }

    #[test]
    fn test_operation_set_entity_simple() {
        let op = inferadb_ledger_types::Operation::SetEntity {
            key: "config:timeout".to_string(),
            value: vec![0, 0, 0, 30],
            condition: None,
            expires_at: None,
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::SetEntity(se)) => {
                assert_eq!(se.key, "config:timeout");
                assert_eq!(se.value, vec![0, 0, 0, 30]);
                assert!(se.condition.is_none());
                assert!(se.expires_at.is_none());
            },
            _ => panic!("Expected SetEntity operation"),
        }
    }

    #[test]
    fn test_operation_set_entity_with_condition_and_ttl() {
        let op = inferadb_ledger_types::Operation::SetEntity {
            key: "session:abc".to_string(),
            value: vec![1, 2, 3],
            condition: Some(inferadb_ledger_types::SetCondition::MustNotExist),
            expires_at: Some(1700000000),
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::SetEntity(se)) => {
                assert_eq!(se.key, "session:abc");
                assert_eq!(se.value, vec![1, 2, 3]);
                assert!(se.condition.is_some());
                assert_eq!(se.expires_at, Some(1700000000));
            },
            _ => panic!("Expected SetEntity operation"),
        }
    }

    #[test]
    fn test_operation_delete_entity() {
        let op = inferadb_ledger_types::Operation::DeleteEntity { key: "temp:data".to_string() };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::DeleteEntity(de)) => {
                assert_eq!(de.key, "temp:data");
            },
            _ => panic!("Expected DeleteEntity operation"),
        }
    }

    #[test]
    fn test_operation_expire_entity() {
        let op = inferadb_ledger_types::Operation::ExpireEntity {
            key: "cache:item".to_string(),
            expired_at: 1699999999,
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::ExpireEntity(ee)) => {
                assert_eq!(ee.key, "cache:item");
                assert_eq!(ee.expired_at, 1699999999);
            },
            _ => panic!("Expected ExpireEntity operation"),
        }
    }

    // -------------------------------------------------------------------------
    // MerkleProof conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_merkle_proof_empty() {
        let internal = InternalMerkleProof {
            leaf_index: 0,
            leaf_hash: Hash::default(),
            proof_hashes: vec![],
            root: Hash::default(),
        };
        let proto: proto::MerkleProof = (&internal).into();

        assert!(proto.leaf_hash.is_some());
        assert!(proto.siblings.is_empty());
    }

    #[test]
    fn test_merkle_proof_single_sibling() {
        let leaf_hash = Hash::from([1u8; 32]);
        let sibling_hash = Hash::from([2u8; 32]);

        let internal = InternalMerkleProof {
            leaf_index: 0, // Even index = sibling is on the right
            leaf_hash,
            proof_hashes: vec![sibling_hash],
            root: Hash::default(),
        };
        let proto: proto::MerkleProof = (&internal).into();

        assert_eq!(proto.siblings.len(), 1);
        assert_eq!(proto.siblings[0].direction, proto::Direction::Right as i32);
    }

    #[test]
    fn test_merkle_proof_direction_alternating() {
        let internal = InternalMerkleProof {
            leaf_index: 5, // Binary: 101 -> directions: Left, Right, Left
            leaf_hash: Hash::default(),
            proof_hashes: vec![Hash::default(), Hash::default(), Hash::default()],
            root: Hash::default(),
        };
        let proto: proto::MerkleProof = (&internal).into();

        assert_eq!(proto.siblings.len(), 3);
        // Index 5 is odd -> Left
        assert_eq!(proto.siblings[0].direction, proto::Direction::Left as i32);
        // Index 2 (5/2) is even -> Right
        assert_eq!(proto.siblings[1].direction, proto::Direction::Right as i32);
        // Index 1 (2/2) is odd -> Left
        assert_eq!(proto.siblings[2].direction, proto::Direction::Left as i32);
    }

    // -------------------------------------------------------------------------
    // VaultEntry to Block conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_vault_entry_to_proto_block_empty_transactions() {
        use chrono::Utc;

        let entry = inferadb_ledger_types::VaultEntry {
            namespace_id: inferadb_ledger_types::NamespaceId::new(1),
            vault_id: inferadb_ledger_types::VaultId::new(2),
            vault_height: 10,
            previous_vault_hash: Hash::from([0xABu8; 32]),
            transactions: vec![],
            tx_merkle_root: Hash::from([0xCDu8; 32]),
            state_root: Hash::from([0xEFu8; 32]),
        };

        let shard_block = inferadb_ledger_types::ShardBlock {
            shard_id: inferadb_ledger_types::ShardId::new(1),
            shard_height: 100,
            previous_shard_hash: Hash::default(),
            vault_entries: vec![],
            timestamp: Utc::now(),
            leader_id: "node-1".to_string(),
            term: 5,
            committed_index: 99,
        };

        let block = vault_entry_to_proto_block(&entry, &shard_block);

        let header = block.header.expect("Block should have header");
        assert_eq!(header.height, 10);
        assert_eq!(header.namespace_id.unwrap().id, 1);
        assert_eq!(header.vault_id.unwrap().id, 2);
        assert_eq!(header.term, 5);
        assert_eq!(header.committed_index, 99);
        assert!(block.transactions.is_empty());
    }

    #[test]
    fn test_vault_entry_to_proto_block_with_transaction() {
        use chrono::Utc;

        let tx = inferadb_ledger_types::Transaction {
            id: *uuid::Uuid::new_v4().as_bytes(),
            client_id: "client-123".to_string(),
            sequence: 1,
            operations: vec![inferadb_ledger_types::Operation::CreateRelationship {
                resource: "doc:1".to_string(),
                relation: "owner".to_string(),
                subject: "user:1".to_string(),
            }],
            timestamp: Utc::now(),
            actor: "user:1".to_string(),
        };

        let entry = inferadb_ledger_types::VaultEntry {
            namespace_id: inferadb_ledger_types::NamespaceId::new(5),
            vault_id: inferadb_ledger_types::VaultId::new(10),
            vault_height: 1,
            previous_vault_hash: Hash::default(),
            transactions: vec![tx],
            tx_merkle_root: Hash::default(),
            state_root: Hash::default(),
        };

        let shard_block = inferadb_ledger_types::ShardBlock {
            shard_id: inferadb_ledger_types::ShardId::new(1),
            shard_height: 50,
            previous_shard_hash: Hash::default(),
            vault_entries: vec![],
            timestamp: Utc::now(),
            leader_id: "leader-node".to_string(),
            term: 3,
            committed_index: 49,
        };

        let block = vault_entry_to_proto_block(&entry, &shard_block);

        assert_eq!(block.transactions.len(), 1);
        let proto_tx = &block.transactions[0];
        assert_eq!(proto_tx.client_id.as_ref().unwrap().id, "client-123");
        assert_eq!(proto_tx.sequence, 1);
        assert_eq!(proto_tx.operations.len(), 1);
    }

    // -------------------------------------------------------------------------
    // Proto -> Domain SetCondition conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_proto_to_condition_not_exists() {
        let proto = proto::SetCondition {
            condition: Some(proto::set_condition::Condition::NotExists(true)),
        };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert_eq!(result, Some(inferadb_ledger_types::SetCondition::MustNotExist));
    }

    #[test]
    fn test_proto_to_condition_must_exists() {
        let proto = proto::SetCondition {
            condition: Some(proto::set_condition::Condition::MustExists(true)),
        };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert_eq!(result, Some(inferadb_ledger_types::SetCondition::MustExist));
    }

    #[test]
    fn test_proto_to_condition_version() {
        let proto =
            proto::SetCondition { condition: Some(proto::set_condition::Condition::Version(42)) };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert_eq!(result, Some(inferadb_ledger_types::SetCondition::VersionEquals(42)));
    }

    #[test]
    fn test_proto_to_condition_value_equals() {
        let proto = proto::SetCondition {
            condition: Some(proto::set_condition::Condition::ValueEquals(vec![1, 2, 3])),
        };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert_eq!(result, Some(inferadb_ledger_types::SetCondition::ValueEquals(vec![1, 2, 3])));
    }

    #[test]
    fn test_proto_to_condition_none_returns_none() {
        let proto = proto::SetCondition { condition: None };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert!(result.is_none());
    }

    #[test]
    fn test_proto_to_condition_inverted_booleans() {
        // NotExists(false) should map to MustExist
        let proto = proto::SetCondition {
            condition: Some(proto::set_condition::Condition::NotExists(false)),
        };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert_eq!(result, Some(inferadb_ledger_types::SetCondition::MustExist));

        // MustExists(false) should map to MustNotExist
        let proto = proto::SetCondition {
            condition: Some(proto::set_condition::Condition::MustExists(false)),
        };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert_eq!(result, Some(inferadb_ledger_types::SetCondition::MustNotExist));
    }

    // -------------------------------------------------------------------------
    // Proto -> Domain Operation conversion tests (TryFrom)
    // -------------------------------------------------------------------------

    #[test]
    fn test_try_from_create_relationship() {
        let proto_op = proto::Operation {
            op: Some(proto::operation::Op::CreateRelationship(proto::CreateRelationship {
                resource: "doc:1".to_string(),
                relation: "viewer".to_string(),
                subject: "user:2".to_string(),
            })),
        };
        let result = inferadb_ledger_types::Operation::try_from(&proto_op).unwrap();
        assert_eq!(
            result,
            inferadb_ledger_types::Operation::CreateRelationship {
                resource: "doc:1".to_string(),
                relation: "viewer".to_string(),
                subject: "user:2".to_string(),
            }
        );
    }

    #[test]
    fn test_try_from_set_entity_with_condition() {
        let proto_op = proto::Operation {
            op: Some(proto::operation::Op::SetEntity(proto::SetEntity {
                key: "key:1".to_string(),
                value: vec![1, 2, 3],
                condition: Some(proto::SetCondition {
                    condition: Some(proto::set_condition::Condition::Version(5)),
                }),
                expires_at: Some(1700000000),
            })),
        };
        let result = inferadb_ledger_types::Operation::try_from(&proto_op).unwrap();
        assert_eq!(
            result,
            inferadb_ledger_types::Operation::SetEntity {
                key: "key:1".to_string(),
                value: vec![1, 2, 3],
                condition: Some(inferadb_ledger_types::SetCondition::VersionEquals(5)),
                expires_at: Some(1700000000),
            }
        );
    }

    #[test]
    fn test_try_from_missing_op_field() {
        let proto_op = proto::Operation { op: None };
        let result = inferadb_ledger_types::Operation::try_from(&proto_op);
        assert!(result.is_err());
        let status = result.unwrap_err();
        assert_eq!(status.code(), tonic::Code::InvalidArgument);
    }

    #[test]
    fn test_try_from_delete_entity() {
        let proto_op = proto::Operation {
            op: Some(proto::operation::Op::DeleteEntity(proto::DeleteEntity {
                key: "key:del".to_string(),
            })),
        };
        let result = inferadb_ledger_types::Operation::try_from(&proto_op).unwrap();
        assert_eq!(
            result,
            inferadb_ledger_types::Operation::DeleteEntity { key: "key:del".to_string() }
        );
    }

    #[test]
    fn test_try_from_expire_entity() {
        let proto_op = proto::Operation {
            op: Some(proto::operation::Op::ExpireEntity(proto::ExpireEntity {
                key: "key:exp".to_string(),
                expired_at: 1699999999,
            })),
        };
        let result = inferadb_ledger_types::Operation::try_from(&proto_op).unwrap();
        assert_eq!(
            result,
            inferadb_ledger_types::Operation::ExpireEntity {
                key: "key:exp".to_string(),
                expired_at: 1699999999,
            }
        );
    }

    // -------------------------------------------------------------------------
    // NamespaceStatus conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_namespace_status_all_variants() {
        use inferadb_ledger_state::system::NamespaceStatus;

        assert_eq!(
            proto::NamespaceStatus::from(NamespaceStatus::Active),
            proto::NamespaceStatus::Active
        );
        assert_eq!(
            proto::NamespaceStatus::from(NamespaceStatus::Migrating),
            proto::NamespaceStatus::Migrating
        );
        assert_eq!(
            proto::NamespaceStatus::from(NamespaceStatus::Suspended),
            proto::NamespaceStatus::Suspended
        );
        assert_eq!(
            proto::NamespaceStatus::from(NamespaceStatus::Deleting),
            proto::NamespaceStatus::Deleting
        );
        assert_eq!(
            proto::NamespaceStatus::from(NamespaceStatus::Deleted),
            proto::NamespaceStatus::Deleted
        );
    }

    // -------------------------------------------------------------------------
    // Entity conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_entity_to_proto() {
        let entity = inferadb_ledger_types::Entity {
            key: b"test-key".to_vec(),
            value: vec![1, 2, 3],
            expires_at: 1700000000,
            version: 42,
        };
        let proto_entity: proto::Entity = (&entity).into();
        assert_eq!(proto_entity.key, "test-key");
        assert_eq!(proto_entity.value, vec![1, 2, 3]);
        assert_eq!(proto_entity.version, 42);
        assert_eq!(proto_entity.expires_at, Some(1700000000));
    }

    #[test]
    fn test_entity_to_proto_never_expires() {
        let entity = inferadb_ledger_types::Entity {
            key: b"perm-key".to_vec(),
            value: vec![],
            expires_at: 0,
            version: 1,
        };
        let proto_entity: proto::Entity = (&entity).into();
        assert!(proto_entity.expires_at.is_none());
    }

    // -------------------------------------------------------------------------
    // Relationship conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_relationship_to_proto() {
        let rel = inferadb_ledger_types::Relationship {
            resource: "doc:123".to_string(),
            relation: "viewer".to_string(),
            subject: "user:456".to_string(),
        };
        let proto_rel: proto::Relationship = (&rel).into();
        assert_eq!(proto_rel.resource, "doc:123");
        assert_eq!(proto_rel.relation, "viewer");
        assert_eq!(proto_rel.subject, "user:456");
    }

    #[test]
    fn test_relationship_to_proto_owned() {
        let rel = inferadb_ledger_types::Relationship {
            resource: "folder:abc".to_string(),
            relation: "editor".to_string(),
            subject: "team:xyz".to_string(),
        };
        let proto_rel: proto::Relationship = rel.into();
        assert_eq!(proto_rel.resource, "folder:abc");
        assert_eq!(proto_rel.relation, "editor");
        assert_eq!(proto_rel.subject, "team:xyz");
    }

    // -------------------------------------------------------------------------
    // BlockRetentionPolicy conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_retention_policy_full_roundtrip() {
        let policy =
            BlockRetentionPolicy { mode: BlockRetentionMode::Full, retention_blocks: 10_000 };
        let proto_policy: proto::BlockRetentionPolicy = policy.into();
        let recovered = BlockRetentionPolicy::from(&proto_policy);
        assert_eq!(recovered.mode, BlockRetentionMode::Full);
        assert_eq!(recovered.retention_blocks, 10_000);
    }

    #[test]
    fn test_retention_policy_compacted_roundtrip() {
        let policy =
            BlockRetentionPolicy { mode: BlockRetentionMode::Compacted, retention_blocks: 5_000 };
        let proto_policy: proto::BlockRetentionPolicy = policy.into();
        let recovered = BlockRetentionPolicy::from(&proto_policy);
        assert_eq!(recovered.mode, BlockRetentionMode::Compacted);
        assert_eq!(recovered.retention_blocks, 5_000);
    }

    #[test]
    fn test_retention_policy_zero_blocks_defaults() {
        let proto_policy = proto::BlockRetentionPolicy {
            mode: proto::BlockRetentionMode::Full.into(),
            retention_blocks: 0,
        };
        let recovered = BlockRetentionPolicy::from(&proto_policy);
        assert_eq!(recovered.retention_blocks, 10_000); // Default
    }

    #[test]
    fn test_retention_mode_unspecified_defaults_to_full() {
        let proto_policy = proto::BlockRetentionPolicy {
            mode: proto::BlockRetentionMode::Unspecified.into(),
            retention_blocks: 100,
        };
        let recovered = BlockRetentionPolicy::from(&proto_policy);
        assert_eq!(recovered.mode, BlockRetentionMode::Full);
    }

    // -------------------------------------------------------------------------
    // Property-based roundtrip tests
    // -------------------------------------------------------------------------

    mod proptests {
        #![allow(
            clippy::unwrap_used,
            clippy::expect_used,
            clippy::panic,
            clippy::disallowed_methods
        )]

        use inferadb_ledger_test_utils::strategies::{
            arb_entity, arb_operation, arb_relationship, arb_set_condition,
        };
        use proptest::prelude::*;

        use super::*;

        proptest! {
            /// Operation roundtrip: domain -> proto -> domain preserves all data.
            #[test]
            fn operation_roundtrip(op in arb_operation()) {
                let proto: proto::Operation = (&op).into();
                let recovered = inferadb_ledger_types::Operation::try_from(&proto).unwrap();
                prop_assert_eq!(op, recovered);
            }

            /// SetCondition roundtrip: domain -> proto -> domain preserves all data.
            #[test]
            fn set_condition_roundtrip(cond in arb_set_condition()) {
                let proto: proto::SetCondition = (&cond).into();
                let recovered: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
                prop_assert_eq!(Some(cond), recovered);
            }

            /// Relationship roundtrip: domain -> proto -> domain preserves fields.
            #[test]
            fn relationship_roundtrip(rel in arb_relationship()) {
                let proto: proto::Relationship = (&rel).into();
                let recovered = inferadb_ledger_types::Relationship {
                    resource: proto.resource,
                    relation: proto.relation,
                    subject: proto.subject,
                };
                prop_assert_eq!(rel, recovered);
            }

            /// Entity roundtrip: domain -> proto -> domain preserves data
            /// (key encoding may differ for non-UTF8 keys via lossy conversion).
            #[test]
            fn entity_to_proto_preserves_value(entity in arb_entity()) {
                let proto: proto::Entity = (&entity).into();
                prop_assert_eq!(&proto.value, &entity.value);
                prop_assert_eq!(proto.version, entity.version);
                if entity.expires_at == 0 {
                    prop_assert!(proto.expires_at.is_none());
                } else {
                    prop_assert_eq!(proto.expires_at, Some(entity.expires_at));
                }
            }
        }
    }
}
