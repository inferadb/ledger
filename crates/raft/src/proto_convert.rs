//! Centralized proto conversion functions.
//!
//! This module provides `From` and `Into` implementations for converting between
//! domain types (from `inferadb_ledger_types`) and proto types (generated by prost).
//!
//! # Design
//!
//! Rather than scattering `foo_to_proto` and `proto_to_foo` functions across
//! service files, we centralize all conversions here using Rust's `From` trait.
//! This enables idiomatic `.into()` calls and ensures consistent, tested conversions.
//!
//! # Usage
//!
//! ```ignore
//! use crate::proto_convert::*;
//!
//! // Domain to proto
//! let proto_op: proto::Operation = domain_op.into();
//!
//! // Proto to domain  
//! let domain_vote: Vote<LedgerNodeId> = proto_vote.into();
//! ```

use inferadb_ledger_types::merkle::MerkleProof as InternalMerkleProof;
use openraft::Vote;

use crate::{proto, types::LedgerNodeId};

// =============================================================================
// Vote conversions (openraft::Vote <-> proto::RaftVote)
// =============================================================================

impl From<&Vote<LedgerNodeId>> for proto::RaftVote {
    fn from(vote: &Vote<LedgerNodeId>) -> Self {
        proto::RaftVote {
            term: vote.leader_id.term,
            node_id: vote.leader_id.node_id,
            committed: vote.committed,
        }
    }
}

impl From<Vote<LedgerNodeId>> for proto::RaftVote {
    fn from(vote: Vote<LedgerNodeId>) -> Self {
        (&vote).into()
    }
}

impl From<&proto::RaftVote> for Vote<LedgerNodeId> {
    fn from(proto: &proto::RaftVote) -> Self {
        if proto.committed {
            Vote::new_committed(proto.term, proto.node_id)
        } else {
            Vote::new(proto.term, proto.node_id)
        }
    }
}

impl From<proto::RaftVote> for Vote<LedgerNodeId> {
    fn from(proto: proto::RaftVote) -> Self {
        (&proto).into()
    }
}

// =============================================================================
// Operation conversions (inferadb_ledger_types::Operation <-> proto::Operation)
// =============================================================================

impl From<&inferadb_ledger_types::Operation> for proto::Operation {
    fn from(op: &inferadb_ledger_types::Operation) -> Self {
        use inferadb_ledger_types::Operation as LedgerOp;
        use proto::operation::Op;

        match op {
            LedgerOp::CreateRelationship { resource, relation, subject } => proto::Operation {
                op: Some(Op::CreateRelationship(proto::CreateRelationship {
                    resource: resource.clone(),
                    relation: relation.clone(),
                    subject: subject.clone(),
                })),
            },
            LedgerOp::DeleteRelationship { resource, relation, subject } => proto::Operation {
                op: Some(Op::DeleteRelationship(proto::DeleteRelationship {
                    resource: resource.clone(),
                    relation: relation.clone(),
                    subject: subject.clone(),
                })),
            },
            LedgerOp::SetEntity { key, value, condition, expires_at } => {
                let condition_proto = condition.as_ref().map(|c| c.into());

                proto::Operation {
                    op: Some(Op::SetEntity(proto::SetEntity {
                        key: key.clone(),
                        value: value.clone(),
                        condition: condition_proto,
                        expires_at: *expires_at,
                    })),
                }
            },
            LedgerOp::DeleteEntity { key } => proto::Operation {
                op: Some(Op::DeleteEntity(proto::DeleteEntity { key: key.clone() })),
            },
            LedgerOp::ExpireEntity { key, expired_at } => proto::Operation {
                op: Some(Op::ExpireEntity(proto::ExpireEntity {
                    key: key.clone(),
                    expired_at: *expired_at,
                })),
            },
        }
    }
}

impl From<inferadb_ledger_types::Operation> for proto::Operation {
    fn from(op: inferadb_ledger_types::Operation) -> Self {
        (&op).into()
    }
}

// =============================================================================
// SetCondition conversions (inferadb_ledger_types::SetCondition <-> proto::SetCondition)
// =============================================================================

impl From<&inferadb_ledger_types::SetCondition> for proto::SetCondition {
    fn from(c: &inferadb_ledger_types::SetCondition) -> Self {
        use proto::set_condition::Condition;

        let condition = match c {
            inferadb_ledger_types::SetCondition::MustNotExist => Condition::NotExists(true),
            inferadb_ledger_types::SetCondition::MustExist => {
                // Proto uses must_exists field for this
                Condition::MustExists(true)
            },
            inferadb_ledger_types::SetCondition::VersionEquals(v) => Condition::Version(*v),
            inferadb_ledger_types::SetCondition::ValueEquals(bytes) => {
                Condition::ValueEquals(bytes.clone())
            },
        };

        proto::SetCondition { condition: Some(condition) }
    }
}

impl From<inferadb_ledger_types::SetCondition> for proto::SetCondition {
    fn from(c: inferadb_ledger_types::SetCondition) -> Self {
        (&c).into()
    }
}

// =============================================================================
// MerkleProof conversions (InternalMerkleProof -> proto::MerkleProof)
// =============================================================================

impl From<&InternalMerkleProof> for proto::MerkleProof {
    /// Convert an internal MerkleProof to a proto MerkleProof.
    ///
    /// The internal format stores raw sibling hashes with the leaf_index to
    /// determine direction. The proto format explicitly encodes direction for
    /// each sibling.
    fn from(internal: &InternalMerkleProof) -> Self {
        use proto::Direction;

        let mut index = internal.leaf_index;
        let mut siblings = Vec::with_capacity(internal.proof_hashes.len());

        for hash in &internal.proof_hashes {
            // If current index is even (left child), sibling is on the right
            // If current index is odd (right child), sibling is on the left
            let direction = if index % 2 == 0 {
                Direction::Right // sibling is right, so we do hash(current || sibling)
            } else {
                Direction::Left // sibling is left, so we do hash(sibling || current)
            };

            siblings.push(proto::MerkleSibling {
                hash: Some(proto::Hash { value: hash.to_vec() }),
                direction: direction.into(),
            });

            // Move up to parent index
            index /= 2;
        }

        proto::MerkleProof {
            leaf_hash: Some(proto::Hash { value: internal.leaf_hash.to_vec() }),
            siblings,
        }
    }
}

impl From<InternalMerkleProof> for proto::MerkleProof {
    fn from(internal: InternalMerkleProof) -> Self {
        (&internal).into()
    }
}

// =============================================================================
// VaultEntry to Block conversion (special case - requires ShardBlock context)
// =============================================================================

/// Convert a VaultEntry from storage to a proto Block.
///
/// This is a method rather than a `From` impl because it requires additional
/// context (the ShardBlock) to populate the block header timestamp and leader info.
pub fn vault_entry_to_proto_block(
    entry: &inferadb_ledger_types::VaultEntry,
    shard_block: &inferadb_ledger_types::ShardBlock,
) -> proto::Block {
    use prost_types::Timestamp;

    // Convert VaultEntry transactions to proto transactions
    let transactions = entry
        .transactions
        .iter()
        .map(|tx| proto::Transaction {
            id: Some(proto::TxId { id: tx.id.to_vec() }),
            client_id: Some(proto::ClientId { id: tx.client_id.clone() }),
            sequence: tx.sequence,
            operations: tx.operations.iter().map(|op| op.into()).collect(),
            timestamp: Some(Timestamp {
                seconds: tx.timestamp.timestamp(),
                nanos: tx.timestamp.timestamp_subsec_nanos() as i32,
            }),
            actor: tx.actor.clone(),
        })
        .collect();

    // Build block header
    let header = proto::BlockHeader {
        height: entry.vault_height,
        namespace_id: Some(proto::NamespaceId { id: entry.namespace_id }),
        vault_id: Some(proto::VaultId { id: entry.vault_id }),
        previous_hash: Some(proto::Hash { value: entry.previous_vault_hash.to_vec() }),
        tx_merkle_root: Some(proto::Hash { value: entry.tx_merkle_root.to_vec() }),
        state_root: Some(proto::Hash { value: entry.state_root.to_vec() }),
        timestamp: Some(Timestamp {
            seconds: shard_block.timestamp.timestamp(),
            nanos: shard_block.timestamp.timestamp_subsec_nanos() as i32,
        }),
        leader_id: Some(proto::NodeId { id: shard_block.leader_id.clone() }),
        term: shard_block.term,
        committed_index: shard_block.committed_index,
    };

    proto::Block { header: Some(header), transactions }
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    #![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic, clippy::disallowed_methods)]

    use inferadb_ledger_types::hash::Hash;

    use super::*;

    // -------------------------------------------------------------------------
    // Vote conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_vote_to_proto_uncommitted() {
        let vote = Vote::new(5, 42);
        let proto: proto::RaftVote = (&vote).into();

        assert_eq!(proto.term, 5);
        assert_eq!(proto.node_id, 42);
        assert!(!proto.committed);
    }

    #[test]
    fn test_vote_to_proto_committed() {
        let vote = Vote::new_committed(10, 99);
        let proto: proto::RaftVote = (&vote).into();

        assert_eq!(proto.term, 10);
        assert_eq!(proto.node_id, 99);
        assert!(proto.committed);
    }

    #[test]
    fn test_proto_to_vote_uncommitted() {
        let proto = proto::RaftVote { term: 7, node_id: 123, committed: false };
        let vote: Vote<LedgerNodeId> = proto.into();

        assert_eq!(vote.leader_id.term, 7);
        assert_eq!(vote.leader_id.node_id, 123);
        assert!(!vote.committed);
    }

    #[test]
    fn test_proto_to_vote_committed() {
        let proto = proto::RaftVote { term: 15, node_id: 456, committed: true };
        let vote: Vote<LedgerNodeId> = proto.into();

        assert_eq!(vote.leader_id.term, 15);
        assert_eq!(vote.leader_id.node_id, 456);
        assert!(vote.committed);
    }

    #[test]
    fn test_vote_roundtrip() {
        // Uncommitted roundtrip
        let original = Vote::new(100, 200);
        let proto: proto::RaftVote = (&original).into();
        let recovered: Vote<LedgerNodeId> = proto.into();

        assert_eq!(original.leader_id.term, recovered.leader_id.term);
        assert_eq!(original.leader_id.node_id, recovered.leader_id.node_id);
        assert_eq!(original.committed, recovered.committed);

        // Committed roundtrip
        let original_committed = Vote::new_committed(50, 60);
        let proto_committed: proto::RaftVote = (&original_committed).into();
        let recovered_committed: Vote<LedgerNodeId> = proto_committed.into();

        assert_eq!(original_committed.leader_id.term, recovered_committed.leader_id.term);
        assert_eq!(original_committed.leader_id.node_id, recovered_committed.leader_id.node_id);
        assert_eq!(original_committed.committed, recovered_committed.committed);
    }

    // -------------------------------------------------------------------------
    // SetCondition conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_condition_must_not_exist() {
        let condition = inferadb_ledger_types::SetCondition::MustNotExist;
        let proto: proto::SetCondition = (&condition).into();

        assert!(matches!(proto.condition, Some(proto::set_condition::Condition::NotExists(true))));
    }

    #[test]
    fn test_condition_must_exist() {
        let condition = inferadb_ledger_types::SetCondition::MustExist;
        let proto: proto::SetCondition = (&condition).into();

        assert!(matches!(proto.condition, Some(proto::set_condition::Condition::MustExists(true))));
    }

    #[test]
    fn test_condition_version_equals() {
        let condition = inferadb_ledger_types::SetCondition::VersionEquals(42);
        let proto: proto::SetCondition = (&condition).into();

        assert!(matches!(proto.condition, Some(proto::set_condition::Condition::Version(42))));
    }

    #[test]
    fn test_condition_value_equals() {
        let condition = inferadb_ledger_types::SetCondition::ValueEquals(vec![1, 2, 3, 4]);
        let proto: proto::SetCondition = (&condition).into();

        match proto.condition {
            Some(proto::set_condition::Condition::ValueEquals(bytes)) => {
                assert_eq!(bytes, vec![1, 2, 3, 4]);
            },
            _ => panic!("Expected ValueEquals condition"),
        }
    }

    // -------------------------------------------------------------------------
    // Operation conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_operation_create_relationship() {
        let op = inferadb_ledger_types::Operation::CreateRelationship {
            resource: "doc:123".to_string(),
            relation: "viewer".to_string(),
            subject: "user:456".to_string(),
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::CreateRelationship(cr)) => {
                assert_eq!(cr.resource, "doc:123");
                assert_eq!(cr.relation, "viewer");
                assert_eq!(cr.subject, "user:456");
            },
            _ => panic!("Expected CreateRelationship operation"),
        }
    }

    #[test]
    fn test_operation_delete_relationship() {
        let op = inferadb_ledger_types::Operation::DeleteRelationship {
            resource: "folder:abc".to_string(),
            relation: "editor".to_string(),
            subject: "team:xyz".to_string(),
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::DeleteRelationship(dr)) => {
                assert_eq!(dr.resource, "folder:abc");
                assert_eq!(dr.relation, "editor");
                assert_eq!(dr.subject, "team:xyz");
            },
            _ => panic!("Expected DeleteRelationship operation"),
        }
    }

    #[test]
    fn test_operation_set_entity_simple() {
        let op = inferadb_ledger_types::Operation::SetEntity {
            key: "config:timeout".to_string(),
            value: vec![0, 0, 0, 30],
            condition: None,
            expires_at: None,
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::SetEntity(se)) => {
                assert_eq!(se.key, "config:timeout");
                assert_eq!(se.value, vec![0, 0, 0, 30]);
                assert!(se.condition.is_none());
                assert!(se.expires_at.is_none());
            },
            _ => panic!("Expected SetEntity operation"),
        }
    }

    #[test]
    fn test_operation_set_entity_with_condition_and_ttl() {
        let op = inferadb_ledger_types::Operation::SetEntity {
            key: "session:abc".to_string(),
            value: vec![1, 2, 3],
            condition: Some(inferadb_ledger_types::SetCondition::MustNotExist),
            expires_at: Some(1700000000),
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::SetEntity(se)) => {
                assert_eq!(se.key, "session:abc");
                assert_eq!(se.value, vec![1, 2, 3]);
                assert!(se.condition.is_some());
                assert_eq!(se.expires_at, Some(1700000000));
            },
            _ => panic!("Expected SetEntity operation"),
        }
    }

    #[test]
    fn test_operation_delete_entity() {
        let op = inferadb_ledger_types::Operation::DeleteEntity { key: "temp:data".to_string() };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::DeleteEntity(de)) => {
                assert_eq!(de.key, "temp:data");
            },
            _ => panic!("Expected DeleteEntity operation"),
        }
    }

    #[test]
    fn test_operation_expire_entity() {
        let op = inferadb_ledger_types::Operation::ExpireEntity {
            key: "cache:item".to_string(),
            expired_at: 1699999999,
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::ExpireEntity(ee)) => {
                assert_eq!(ee.key, "cache:item");
                assert_eq!(ee.expired_at, 1699999999);
            },
            _ => panic!("Expected ExpireEntity operation"),
        }
    }

    // -------------------------------------------------------------------------
    // MerkleProof conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_merkle_proof_empty() {
        let internal = InternalMerkleProof {
            leaf_index: 0,
            leaf_hash: Hash::default(),
            proof_hashes: vec![],
            root: Hash::default(),
        };
        let proto: proto::MerkleProof = (&internal).into();

        assert!(proto.leaf_hash.is_some());
        assert!(proto.siblings.is_empty());
    }

    #[test]
    fn test_merkle_proof_single_sibling() {
        let leaf_hash = Hash::from([1u8; 32]);
        let sibling_hash = Hash::from([2u8; 32]);

        let internal = InternalMerkleProof {
            leaf_index: 0, // Even index = sibling is on the right
            leaf_hash,
            proof_hashes: vec![sibling_hash],
            root: Hash::default(),
        };
        let proto: proto::MerkleProof = (&internal).into();

        assert_eq!(proto.siblings.len(), 1);
        assert_eq!(proto.siblings[0].direction, proto::Direction::Right as i32);
    }

    #[test]
    fn test_merkle_proof_direction_alternating() {
        let internal = InternalMerkleProof {
            leaf_index: 5, // Binary: 101 -> directions: Left, Right, Left
            leaf_hash: Hash::default(),
            proof_hashes: vec![Hash::default(), Hash::default(), Hash::default()],
            root: Hash::default(),
        };
        let proto: proto::MerkleProof = (&internal).into();

        assert_eq!(proto.siblings.len(), 3);
        // Index 5 is odd -> Left
        assert_eq!(proto.siblings[0].direction, proto::Direction::Left as i32);
        // Index 2 (5/2) is even -> Right
        assert_eq!(proto.siblings[1].direction, proto::Direction::Right as i32);
        // Index 1 (2/2) is odd -> Left
        assert_eq!(proto.siblings[2].direction, proto::Direction::Left as i32);
    }

    // -------------------------------------------------------------------------
    // VaultEntry to Block conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_vault_entry_to_proto_block_empty_transactions() {
        use chrono::Utc;

        let entry = inferadb_ledger_types::VaultEntry {
            namespace_id: 1,
            vault_id: 2,
            vault_height: 10,
            previous_vault_hash: Hash::from([0xABu8; 32]),
            transactions: vec![],
            tx_merkle_root: Hash::from([0xCDu8; 32]),
            state_root: Hash::from([0xEFu8; 32]),
        };

        let shard_block = inferadb_ledger_types::ShardBlock {
            shard_id: 1,
            shard_height: 100,
            previous_shard_hash: Hash::default(),
            vault_entries: vec![],
            timestamp: Utc::now(),
            leader_id: "node-1".to_string(),
            term: 5,
            committed_index: 99,
        };

        let block = vault_entry_to_proto_block(&entry, &shard_block);

        let header = block.header.expect("Block should have header");
        assert_eq!(header.height, 10);
        assert_eq!(header.namespace_id.unwrap().id, 1);
        assert_eq!(header.vault_id.unwrap().id, 2);
        assert_eq!(header.term, 5);
        assert_eq!(header.committed_index, 99);
        assert!(block.transactions.is_empty());
    }

    #[test]
    fn test_vault_entry_to_proto_block_with_transaction() {
        use chrono::Utc;

        let tx = inferadb_ledger_types::Transaction {
            id: *uuid::Uuid::new_v4().as_bytes(),
            client_id: "client-123".to_string(),
            sequence: 1,
            operations: vec![inferadb_ledger_types::Operation::CreateRelationship {
                resource: "doc:1".to_string(),
                relation: "owner".to_string(),
                subject: "user:1".to_string(),
            }],
            timestamp: Utc::now(),
            actor: "user:1".to_string(),
        };

        let entry = inferadb_ledger_types::VaultEntry {
            namespace_id: 5,
            vault_id: 10,
            vault_height: 1,
            previous_vault_hash: Hash::default(),
            transactions: vec![tx],
            tx_merkle_root: Hash::default(),
            state_root: Hash::default(),
        };

        let shard_block = inferadb_ledger_types::ShardBlock {
            shard_id: 1,
            shard_height: 50,
            previous_shard_hash: Hash::default(),
            vault_entries: vec![],
            timestamp: Utc::now(),
            leader_id: "leader-node".to_string(),
            term: 3,
            committed_index: 49,
        };

        let block = vault_entry_to_proto_block(&entry, &shard_block);

        assert_eq!(block.transactions.len(), 1);
        let proto_tx = &block.transactions[0];
        assert_eq!(proto_tx.client_id.as_ref().unwrap().id, "client-123");
        assert_eq!(proto_tx.sequence, 1);
        assert_eq!(proto_tx.operations.len(), 1);
    }
}
