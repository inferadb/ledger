// This file is @generated by prost-build.
/// 256-bit hash (SHA-256)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Hash {
    /// 32 bytes
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Unique namespace identifier (one per organization)
/// Sequential int64 assigned by Ledger leader from "\_meta:seq:namespace"
/// Special case: namespace_id = 0 is reserved for \_system
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NamespaceId {
    #[prost(int64, tag = "1")]
    pub id: i64,
}
/// Unique vault identifier (relationship store within a namespace)
/// Sequential int64 assigned by Ledger leader from "\_meta:seq:vault"
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VaultId {
    #[prost(int64, tag = "1")]
    pub id: i64,
}
/// Unique shard identifier (Raft group hosting multiple namespaces)
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShardId {
    #[prost(uint32, tag = "1")]
    pub id: u32,
}
/// Unique node identifier
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeId {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Unique user identifier (global, stored in \_system namespace)
/// Sequential int64 assigned by Ledger leader (see ID Generation Strategy in DESIGN.md)
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserId {
    #[prost(int64, tag = "1")]
    pub id: i64,
}
/// User record (stored in \_system namespace as Entity with key "user:{id}")
/// Users can have multiple email addresses via separate UserEmail entities.
/// Namespace access is derived from membership records (member:{id} in each org namespace).
/// ID assigned by Ledger leader from sequence counter "\_meta:seq:user"
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct User {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<UserId>,
    /// Display name (1-200 characters)
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// References UserEmail.id
    #[prost(int64, tag = "3")]
    pub primary_email_id: i64,
    /// Lifecycle state
    #[prost(enumeration = "UserStatus", tag = "4")]
    pub status: i32,
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// User email address (stored in \_system namespace as Entity with key "user_email:{id}")
/// Each user can have multiple emails; primary is tracked by UserEmail.primary field.
/// Constraint: Primary email cannot be deleted (must reassign primary first).
/// Global email uniqueness is enforced via index: "\_idx:email:{email}" → email_id
/// ID assigned by Ledger leader from sequence counter "\_meta:seq:user_email"
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserEmail {
    /// Sequential ID (Ledger-assigned)
    #[prost(int64, tag = "1")]
    pub id: i64,
    /// Owning user
    #[prost(message, optional, tag = "2")]
    pub user_id: ::core::option::Option<UserId>,
    /// Normalized to lowercase (max 320 chars per RFC 5321)
    #[prost(string, tag = "3")]
    pub email: ::prost::alloc::string::String,
    /// Whether email has been verified
    #[prost(bool, tag = "4")]
    pub verified: bool,
    /// Whether this is the user's primary email
    #[prost(bool, tag = "5")]
    pub primary: bool,
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// When verified (null if unverified)
    #[prost(message, optional, tag = "7")]
    pub verified_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Email verification token (stored in \_system namespace with TTL)
/// Key: "email_verify:{id}", Index: "\_idx:email_verify:token:{token}" → token_id
/// Tokens expire after 24 hours via Ledger's TTL mechanism.
/// ID assigned by Ledger leader from sequence counter "\_meta:seq:email_verify"
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EmailVerificationToken {
    /// Sequential ID (Ledger-assigned)
    #[prost(int64, tag = "1")]
    pub id: i64,
    /// Email being verified
    #[prost(int64, tag = "2")]
    pub user_email_id: i64,
    /// 64-char hex string (32 random bytes)
    #[prost(string, tag = "3")]
    pub token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// For application-level validation
    #[prost(message, optional, tag = "5")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
    /// When token was consumed (null if unused)
    #[prost(message, optional, tag = "6")]
    pub used_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Unique client identifier (for idempotency)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClientId {
    /// Opaque string (max 256 chars, typically API key ID)
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Unique transaction identifier
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TxId {
    /// UUID as 16 bytes
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockHeader {
    #[prost(uint64, tag = "1")]
    pub height: u64,
    /// Owning namespace (organization)
    #[prost(message, optional, tag = "2")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Vault within namespace
    #[prost(message, optional, tag = "3")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(message, optional, tag = "4")]
    pub previous_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag = "5")]
    pub tx_merkle_root: ::core::option::Option<Hash>,
    #[prost(message, optional, tag = "6")]
    pub state_root: ::core::option::Option<Hash>,
    #[prost(message, optional, tag = "7")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Note: leader_id is included in proto for API completeness but excluded from
    /// the 148-byte deterministic block hash computation. This ensures blocks hash
    /// identically regardless of which leader committed them. The leader_id is stored
    /// in ShardBlock and populated when extracting VaultBlock for client responses.
    #[prost(message, optional, tag = "8")]
    pub leader_id: ::core::option::Option<NodeId>,
    #[prost(uint64, tag = "9")]
    pub term: u64,
    #[prost(uint64, tag = "10")]
    pub committed_index: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Block {
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<BlockHeader>,
    #[prost(message, repeated, tag = "2")]
    pub transactions: ::prost::alloc::vec::Vec<Transaction>,
}
/// Lightweight block notification for streaming (excludes transaction bodies)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockAnnouncement {
    /// Owning namespace
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Vault within namespace
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(uint64, tag = "3")]
    pub height: u64,
    #[prost(message, optional, tag = "4")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag = "5")]
    pub state_root: ::core::option::Option<Hash>,
    #[prost(message, optional, tag = "6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<TxId>,
    #[prost(message, optional, tag = "2")]
    pub client_id: ::core::option::Option<ClientId>,
    #[prost(uint64, tag = "3")]
    pub sequence: u64,
    #[prost(message, repeated, tag = "4")]
    pub operations: ::prost::alloc::vec::Vec<Operation>,
    #[prost(message, optional, tag = "5")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Actor identity, ALWAYS server-assigned from authenticated context.
    /// Clients cannot specify this - derived from auth:
    ///
    /// * Session token → "user:{user_id}"
    /// * API key → "client:{client_id}"
    /// * Internal operation → "system:{component}" (e.g., "system:gc")
    ///   Format: {type}:{id}, max 128 characters.
    #[prost(string, tag = "6")]
    pub actor: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Operation {
    #[prost(oneof = "operation::Op", tags = "1, 2, 3, 4, 5")]
    pub op: ::core::option::Option<operation::Op>,
}
/// Nested message and enum types in `Operation`.
pub mod operation {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Op {
        #[prost(message, tag = "1")]
        CreateRelationship(super::CreateRelationship),
        #[prost(message, tag = "2")]
        DeleteRelationship(super::DeleteRelationship),
        #[prost(message, tag = "3")]
        SetEntity(super::SetEntity),
        #[prost(message, tag = "4")]
        DeleteEntity(super::DeleteEntity),
        /// GC-initiated removal (distinct from user delete)
        #[prost(message, tag = "5")]
        ExpireEntity(super::ExpireEntity),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateRelationship {
    /// Format: "type:id" (max 512 chars total)
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    /// Relation name (max 64 chars, e.g., "viewer", "editor")
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
    /// Format: "type:id" or "type:id#relation" (max 512 chars)
    #[prost(string, tag = "3")]
    pub subject: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteRelationship {
    /// Format: "type:id" (max 512 chars total)
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    /// Relation name (max 64 chars)
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
    /// Format: "type:id" or "type:id#relation" (max 512 chars)
    #[prost(string, tag = "3")]
    pub subject: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetEntity {
    /// Entity key (max 1024 bytes, UTF-8)
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// Entity value (max 1MB)
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// Unix epoch seconds; 0 or omit = never expires
    #[prost(uint64, optional, tag = "3")]
    pub expires_at: ::core::option::Option<u64>,
    /// Optional conditional write (CAS)
    #[prost(message, optional, tag = "4")]
    pub condition: ::core::option::Option<SetCondition>,
}
/// Condition for compare-and-set writes (used for coordination primitives)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SetCondition {
    #[prost(oneof = "set_condition::Condition", tags = "1, 2, 3, 4")]
    pub condition: ::core::option::Option<set_condition::Condition>,
}
/// Nested message and enum types in `SetCondition`.
pub mod set_condition {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Condition {
        /// Only set if key doesn't exist
        #[prost(bool, tag = "1")]
        NotExists(bool),
        /// Only set if key was last modified at this block height
        #[prost(uint64, tag = "2")]
        Version(u64),
        /// Only set if current value matches exactly
        #[prost(bytes, tag = "3")]
        ValueEquals(::prost::alloc::vec::Vec<u8>),
        /// Only set if key already exists (for safe updates)
        #[prost(bool, tag = "4")]
        MustExists(bool),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteEntity {
    /// Entity key (max 1024 bytes, UTF-8)
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
/// GC-initiated entity removal (distinct from user deletion for audit trail)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExpireEntity {
    /// Entity key (max 1024 bytes, UTF-8)
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// When the entity's TTL was reached (Unix epoch seconds)
    #[prost(uint64, tag = "2")]
    pub expired_at: u64,
}
/// Relationship tuple (used in query results)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Relationship {
    /// Format: "type:id" (max 512 chars)
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    /// Relation name (max 64 chars)
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
    /// Format: "type:id" or "type:id#relation" (max 512 chars)
    #[prost(string, tag = "3")]
    pub subject: ::prost::alloc::string::String,
}
/// Entity (used in query results)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Entity {
    /// Entity key (max 1024 bytes, UTF-8)
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// Entity value (max 1MB)
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// Unix epoch seconds; 0 = never expires
    #[prost(uint64, optional, tag = "3")]
    pub expires_at: ::core::option::Option<u64>,
    /// Block height when last modified (for conditional writes)
    #[prost(uint64, tag = "4")]
    pub version: u64,
}
/// Merkle inclusion proof for transaction in block.
/// Verification: recompute root from leaf_hash up through siblings.
/// The leaf_hash is SHA-256(canonical_tx_encoding) - see DESIGN.md "Transaction Hash".
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerkleProof {
    /// SHA-256 of transaction (not included separately)
    #[prost(message, optional, tag = "1")]
    pub leaf_hash: ::core::option::Option<Hash>,
    /// Siblings from leaf to root (bottom-up order)
    #[prost(message, repeated, tag = "2")]
    pub siblings: ::prost::alloc::vec::Vec<MerkleSibling>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MerkleSibling {
    #[prost(message, optional, tag = "1")]
    pub hash: ::core::option::Option<Hash>,
    /// Where sibling sits: LEFT means hash(sibling || current)
    #[prost(enumeration = "Direction", tag = "2")]
    pub direction: i32,
}
/// Chain proof linking a trusted height to a response height.
/// Used to verify that block at response_height descends from trusted_height.
///
/// Ordering: headers\[0\].height == trusted_height + 1, ascending to response_height.
/// The trusted header itself is NOT included (client already has it).
/// Verification: chain previous_hash links and verify final header matches response.
///
/// Example: trusted_height=100, response_height=103
/// headers = \[BlockHeader(101), BlockHeader(102), BlockHeader(103)\]
/// Verify: headers\[0\].previous_hash == sha256(trusted_header)
/// headers\[1\].previous_hash == sha256(headers\[0\])
/// headers\[2\].previous_hash == sha256(headers\[1\])
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainProof {
    /// Ascending height order, excludes trusted header
    #[prost(message, repeated, tag = "1")]
    pub headers: ::prost::alloc::vec::Vec<BlockHeader>,
}
/// State proof for entity existence verification.
/// Unlike transaction proofs (O(log n) Merkle path), state proofs require
/// bucket contents because state uses bucket-based hashing for O(1) writes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StateProof {
    /// Entity key
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// Entity value
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// TTL (0 = never)
    #[prost(uint64, tag = "3")]
    pub expires_at: u64,
    /// Block height when last modified
    #[prost(uint64, tag = "4")]
    pub version: u64,
    /// Bucket assignment (seahash(key) % 256)
    #[prost(uint32, tag = "5")]
    pub bucket_id: u32,
    /// Computed bucket root
    #[prost(message, optional, tag = "6")]
    pub bucket_root: ::core::option::Option<Hash>,
    /// 255 other bucket roots (index skips bucket_id)
    #[prost(message, repeated, tag = "7")]
    pub other_bucket_roots: ::prost::alloc::vec::Vec<Hash>,
    /// Block height this proof is valid for
    #[prost(uint64, tag = "8")]
    pub block_height: u64,
    /// Expected state_root (for verification)
    #[prost(message, optional, tag = "9")]
    pub state_root: ::core::option::Option<Hash>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Omit for namespace-level entity reads
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(string, tag = "3")]
    pub key: ::prost::alloc::string::String,
    /// Default: EVENTUAL (any replica)
    #[prost(enumeration = "ReadConsistency", tag = "4")]
    pub consistency: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReadResponse {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, tag = "2")]
    pub block_height: u64,
}
/// Batch read request: read multiple keys in a single RPC for higher throughput.
/// All reads share the same namespace, vault, and consistency level.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchReadRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Keys to read (max 1000)
    #[prost(string, repeated, tag = "3")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Applied to all reads
    #[prost(enumeration = "ReadConsistency", tag = "4")]
    pub consistency: i32,
}
/// Batch read response: results for all requested keys.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchReadResponse {
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<BatchReadResult>,
    /// Block height at time of read
    #[prost(uint64, tag = "2")]
    pub block_height: u64,
}
/// Result for a single key in a batch read.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchReadResult {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// None if key not found
    #[prost(bytes = "vec", optional, tag = "2")]
    pub value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Explicit found flag for clarity
    #[prost(bool, tag = "3")]
    pub found: bool,
}
/// Verified read: retrieve state with cryptographic proofs for client-side verification.
/// Always returns: block_header + merkle_proof (required for verification).
/// Use case: Clients that verify state locally, don't trust the server.
///
/// For historical reads WITHOUT proofs (audits, debugging), use HistoricalRead
/// with include_proof=false to avoid proof generation overhead.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VerifiedReadRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Omit for namespace-level entity reads
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(string, tag = "3")]
    pub key: ::prost::alloc::string::String,
    /// Read at specific height (0 or omit = current)
    #[prost(uint64, optional, tag = "4")]
    pub at_height: ::core::option::Option<u64>,
    /// Also include chain proof to trusted_height
    #[prost(bool, tag = "5")]
    pub include_chain_proof: bool,
    /// Chain proof starts from this checkpoint
    #[prost(uint64, optional, tag = "6")]
    pub trusted_height: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifiedReadResponse {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, tag = "2")]
    pub block_height: u64,
    #[prost(message, optional, tag = "3")]
    pub block_header: ::core::option::Option<BlockHeader>,
    #[prost(message, optional, tag = "4")]
    pub merkle_proof: ::core::option::Option<MerkleProof>,
    #[prost(message, optional, tag = "5")]
    pub chain_proof: ::core::option::Option<ChainProof>,
}
/// Historical read: retrieve state at a specific past block height.
/// Use case: Audits, compliance queries, debugging past state.
/// Performance: Requires snapshot reconstruction (5-20ms hot, 100ms-10s cold).
///
/// For verified historical reads with proofs, prefer VerifiedRead(at_height) which
/// is optimized for the verification use case. HistoricalRead is for unverified
/// archival queries where proof generation would add unnecessary overhead.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HistoricalReadRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Omit for namespace-level entity reads
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(string, tag = "3")]
    pub key: ::prost::alloc::string::String,
    /// Required: block height to read from
    #[prost(uint64, tag = "4")]
    pub at_height: u64,
    /// Include block_header + merkle_proof (default: false)
    #[prost(bool, tag = "5")]
    pub include_proof: bool,
    /// Also include chain proof (requires include_proof=true)
    #[prost(bool, tag = "6")]
    pub include_chain_proof: bool,
    /// Chain proof starts from this checkpoint
    #[prost(uint64, optional, tag = "7")]
    pub trusted_height: ::core::option::Option<u64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistoricalReadResponse {
    /// None if key didn't exist at at_height
    #[prost(bytes = "vec", optional, tag = "1")]
    pub value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Echoes at_height for confirmation
    #[prost(uint64, tag = "2")]
    pub block_height: u64,
    /// Proofs (present only if include_proof=true):
    #[prost(message, optional, tag = "3")]
    pub block_header: ::core::option::Option<BlockHeader>,
    #[prost(message, optional, tag = "4")]
    pub merkle_proof: ::core::option::Option<MerkleProof>,
    /// Present if include_chain_proof was true
    #[prost(message, optional, tag = "5")]
    pub chain_proof: ::core::option::Option<ChainProof>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WatchBlocksRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// First block height to stream. Must be >= 1 (0 is rejected with INVALID_ARGUMENT).
    ///
    /// Streaming behavior:
    ///
    /// 1. Historical replay: Streams committed blocks from start_height to current tip
    /// 1. Real-time push: After historical replay, stream stays open and pushes new
    ///    blocks as they are committed (zero-polling live synchronization)
    /// 1. Stream lifetime: Remains open indefinitely until client disconnects
    ///
    /// Backpressure handling:
    ///
    /// * Uses tokio::sync::broadcast internally with buffer size 1024
    /// * Slow consumers that fall >1024 blocks behind receive a Lagged error
    /// * On Lagged error, reconnect with start_height = last_received_height + 1
    ///
    /// Typical usage for live sync:
    /// stream = WatchBlocks(start_height = last_known_height + 1)
    /// for block in stream:
    /// process(block)
    /// last_known_height = block.height
    #[prost(uint64, tag = "3")]
    pub start_height: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBlockRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(uint64, tag = "3")]
    pub height: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockResponse {
    #[prost(message, optional, tag = "1")]
    pub block: ::core::option::Option<Block>,
}
/// Fetch multiple blocks for sync/catchup.
/// Use case: Client reconnecting after downtime needs to catch up.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBlockRangeRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// First block to return (inclusive)
    #[prost(uint64, tag = "3")]
    pub start_height: u64,
    /// Last block to return (inclusive), max range: 1000 blocks
    #[prost(uint64, tag = "4")]
    pub end_height: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBlockRangeResponse {
    /// Ordered by height ascending
    #[prost(message, repeated, tag = "1")]
    pub blocks: ::prost::alloc::vec::Vec<Block>,
    /// Current chain tip (for client to know if more syncing needed)
    #[prost(uint64, tag = "2")]
    pub current_tip: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTipRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTipResponse {
    #[prost(uint64, tag = "1")]
    pub height: u64,
    #[prost(message, optional, tag = "2")]
    pub block_hash: ::core::option::Option<Hash>,
    #[prost(message, optional, tag = "3")]
    pub state_root: ::core::option::Option<Hash>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetClientStateRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Omit for namespace-level entity writes
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(message, optional, tag = "3")]
    pub client_id: ::core::option::Option<ClientId>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetClientStateResponse {
    #[prost(uint64, tag = "1")]
    pub last_committed_sequence: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListRelationshipsRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Filter by resource (exact match)
    #[prost(string, optional, tag = "3")]
    pub resource: ::core::option::Option<::prost::alloc::string::String>,
    /// Filter by relation (exact match)
    #[prost(string, optional, tag = "4")]
    pub relation: ::core::option::Option<::prost::alloc::string::String>,
    /// Filter by subject (exact match)
    #[prost(string, optional, tag = "5")]
    pub subject: ::core::option::Option<::prost::alloc::string::String>,
    /// Read at specific height (0 or omit = current)
    #[prost(uint64, optional, tag = "6")]
    pub at_height: ::core::option::Option<u64>,
    /// Max results (0 = default limit)
    #[prost(uint32, tag = "7")]
    pub limit: u32,
    /// Opaque pagination cursor from previous response. Server-managed; do not parse or modify.
    /// Encodes position and query context for consistent pagination across requests.
    #[prost(string, tag = "8")]
    pub page_token: ::prost::alloc::string::String,
    /// Default: EVENTUAL (any replica)
    #[prost(enumeration = "ReadConsistency", tag = "9")]
    pub consistency: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRelationshipsResponse {
    #[prost(message, repeated, tag = "1")]
    pub relationships: ::prost::alloc::vec::Vec<Relationship>,
    #[prost(uint64, tag = "2")]
    pub block_height: u64,
    /// Opaque cursor for next page; empty if no more results
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListResourcesRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Type prefix (e.g., "document" matches "document:\*")
    #[prost(string, tag = "3")]
    pub resource_type: ::prost::alloc::string::String,
    /// Read at specific height (0 or omit = current)
    #[prost(uint64, optional, tag = "4")]
    pub at_height: ::core::option::Option<u64>,
    /// Max results (0 = default limit)
    #[prost(uint32, tag = "5")]
    pub limit: u32,
    /// Opaque pagination cursor from previous response. Server-managed; do not parse or modify.
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
    /// Default: EVENTUAL (any replica)
    #[prost(enumeration = "ReadConsistency", tag = "7")]
    pub consistency: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListResourcesResponse {
    /// Full resource IDs (e.g., \["document:1", "document:2"\])
    #[prost(string, repeated, tag = "1")]
    pub resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag = "2")]
    pub block_height: u64,
    /// Opaque cursor for next page; empty if no more results
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListEntitiesRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// e.g., "user:", "\_idx:email:", "session:"
    #[prost(string, tag = "2")]
    pub key_prefix: ::prost::alloc::string::String,
    /// Read at specific height (0 or omit = current)
    #[prost(uint64, optional, tag = "3")]
    pub at_height: ::core::option::Option<u64>,
    /// Include entities past expires_at (default: false)
    #[prost(bool, tag = "4")]
    pub include_expired: bool,
    /// Max results (0 = default limit)
    #[prost(uint32, tag = "5")]
    pub limit: u32,
    /// Opaque pagination cursor from previous response. Server-managed; do not parse or modify.
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
    /// Default: EVENTUAL (any replica)
    #[prost(enumeration = "ReadConsistency", tag = "7")]
    pub consistency: i32,
    /// Omit for namespace-level entities (vault_id=0)
    #[prost(message, optional, tag = "8")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitiesResponse {
    #[prost(message, repeated, tag = "1")]
    pub entities: ::prost::alloc::vec::Vec<Entity>,
    #[prost(uint64, tag = "2")]
    pub block_height: u64,
    /// Opaque cursor for next page; empty if no more results
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Note: actor is NOT specified by client. Server assigns Transaction.actor
/// from authenticated context (session token, API key, or system identity).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Required for relationships; omit for namespace-level entities
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(message, optional, tag = "3")]
    pub client_id: ::core::option::Option<ClientId>,
    /// 16-byte UUID for idempotent retries (server rejects reuse with different payload)
    #[prost(bytes = "vec", tag = "4")]
    pub idempotency_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "5")]
    pub operations: ::prost::alloc::vec::Vec<Operation>,
    /// Request block_header + tx_proof in response for verification
    #[prost(bool, tag = "6")]
    pub include_tx_proof: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteResponse {
    #[prost(oneof = "write_response::Result", tags = "1, 2")]
    pub result: ::core::option::Option<write_response::Result>,
}
/// Nested message and enum types in `WriteResponse`.
pub mod write_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        Success(super::WriteSuccess),
        #[prost(message, tag = "2")]
        Error(super::WriteError),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteSuccess {
    #[prost(message, optional, tag = "1")]
    pub tx_id: ::core::option::Option<TxId>,
    #[prost(uint64, tag = "2")]
    pub block_height: u64,
    /// For client-side verification (both present or both absent):
    ///
    /// Contains tx_merkle_root for proof verification
    #[prost(message, optional, tag = "3")]
    pub block_header: ::core::option::Option<BlockHeader>,
    /// Proof tx is in block (verify against block_header.tx_merkle_root)
    #[prost(message, optional, tag = "4")]
    pub tx_proof: ::core::option::Option<MerkleProof>,
    /// Server-assigned sequence number for this write
    #[prost(uint64, tag = "5")]
    pub assigned_sequence: u64,
}
/// Detailed error for conditional write failures.
/// Provides enough context for clients to retry with correct values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WriteError {
    #[prost(enumeration = "WriteErrorCode", tag = "1")]
    pub code: i32,
    /// Which key's condition failed (CAS errors)
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    /// Actual version (for version mismatch)
    #[prost(uint64, optional, tag = "3")]
    pub current_version: ::core::option::Option<u64>,
    /// Actual value (for value_equals mismatch, if small)
    #[prost(bytes = "vec", optional, tag = "4")]
    pub current_value: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Human-readable error description
    #[prost(string, tag = "5")]
    pub message: ::prost::alloc::string::String,
    /// Idempotency recovery fields (populated for ALREADY_COMMITTED)
    ///
    /// For ALREADY_COMMITTED: original tx_id
    #[prost(message, optional, tag = "6")]
    pub committed_tx_id: ::core::option::Option<TxId>,
    /// For ALREADY_COMMITTED: original block_height
    #[prost(uint64, optional, tag = "7")]
    pub committed_block_height: ::core::option::Option<u64>,
    /// For ALREADY_COMMITTED: server-assigned sequence
    #[prost(uint64, optional, tag = "8")]
    pub assigned_sequence: ::core::option::Option<u64>,
}
/// Structured error details attached to gRPC `Status.details` for machine-readable
/// error handling. SDK clients decode this to populate `SdkError` fields without
/// parsing error message strings.
///
/// Encoding: `prost::Message::encode_to_vec()` → `Status::with_details(bytes)`.
/// Decoding: `ErrorDetails::decode(status.details())`.
///
/// Backward-compatible: clients that don't parse details continue working
/// unchanged — they still see the human-readable `Status.message`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorDetails {
    /// Machine-readable error code (numeric string, e.g., "3203").
    /// Maps to `ErrorCode::as_u16()` from the types crate.
    #[prost(string, tag = "1")]
    pub error_code: ::prost::alloc::string::String,
    /// Whether the client should retry this operation.
    #[prost(bool, tag = "2")]
    pub is_retryable: bool,
    /// Suggested delay before retrying (milliseconds). Present only for
    /// rate-limited or backpressure errors.
    #[prost(int32, optional, tag = "3")]
    pub retry_after_ms: ::core::option::Option<i32>,
    /// Structured key-value context (e.g., {"namespace_id": "42", "field": "key"}).
    #[prost(map = "string, string", tag = "4")]
    pub context: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Human-readable recovery guidance (e.g., "Reduce request rate").
    #[prost(string, optional, tag = "5")]
    pub suggested_action: ::core::option::Option<::prost::alloc::string::String>,
}
/// Batch write with all-or-nothing atomicity.
///
/// Semantics:
///
/// * All writes are committed in a SINGLE block (shared block_height in response)
/// * Writes are applied in ARRAY ORDER (writes\[0\] before writes\[1\], etc.)
/// * If ANY write's condition fails (e.g., CAS mismatch), the ENTIRE batch fails
/// * On failure, no writes are applied—the vault state is unchanged
///
/// Idempotency: Uses BATCH-LEVEL client_id/idempotency_key (not per-write).
/// The entire batch is the idempotency unit—retry with same (client_id, idempotency_key)
/// returns the original result. Per-write values in operations\[\] are IGNORED.
///
/// Use cases:
///
/// * Multi-key transactions requiring atomic commit
/// * Ordered operations where later writes depend on earlier writes' effects
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// All writes must target same scope
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Batch-level idempotency (per-write client_id ignored)
    #[prost(message, optional, tag = "3")]
    pub client_id: ::core::option::Option<ClientId>,
    /// 16-byte UUID for idempotent retries (server rejects reuse with different payload)
    #[prost(bytes = "vec", tag = "4")]
    pub idempotency_key: ::prost::alloc::vec::Vec<u8>,
    /// Operations in this batch
    #[prost(message, repeated, tag = "5")]
    pub operations: ::prost::alloc::vec::Vec<BatchWriteOperation>,
    /// Request block_header + tx_proofs in response for verification
    #[prost(bool, tag = "6")]
    pub include_tx_proofs: bool,
}
/// Logical grouping of operations within a BatchWriteRequest.
/// Purpose: Allows expressing ordered operation groups within an atomic batch.
/// Processing: Groups are processed in array order (operations\[0\], then operations\[1\], etc.)
/// All groups share the batch's namespace_id, vault_id, client_id, and idempotency_key.
/// Atomicity: The ENTIRE batch is atomic—if any operation fails, no changes are applied.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteOperation {
    /// Operations in this group
    #[prost(message, repeated, tag = "1")]
    pub operations: ::prost::alloc::vec::Vec<Operation>,
}
/// Response for batch write.
/// All-or-nothing: either all writes succeed or none are applied.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteResponse {
    #[prost(oneof = "batch_write_response::Result", tags = "1, 2")]
    pub result: ::core::option::Option<batch_write_response::Result>,
}
/// Nested message and enum types in `BatchWriteResponse`.
pub mod batch_write_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "1")]
        Success(super::BatchWriteSuccess),
        /// First failing write; no writes applied
        #[prost(message, tag = "2")]
        Error(super::WriteError),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteSuccess {
    /// Single transaction ID for entire batch
    #[prost(message, optional, tag = "1")]
    pub tx_id: ::core::option::Option<TxId>,
    /// Block containing this transaction
    #[prost(uint64, tag = "2")]
    pub block_height: u64,
    /// For client-side verification (optional):
    ///
    /// Contains tx_merkle_root for proof verification
    #[prost(message, optional, tag = "3")]
    pub block_header: ::core::option::Option<BlockHeader>,
    /// Proof this tx is in block
    #[prost(message, optional, tag = "4")]
    pub tx_proof: ::core::option::Option<MerkleProof>,
    /// Server-assigned sequence number for this batch
    #[prost(uint64, tag = "5")]
    pub assigned_sequence: u64,
}
/// Create a new namespace. NamespaceId is leader-assigned from \_meta:seq:namespace.
/// The namespace is assigned to the shard with lowest load, or to the specified shard.
/// Per-namespace resource quota limits.
/// Applied to new namespaces; defaults from server config if not specified.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NamespaceQuota {
    /// Maximum cumulative storage bytes
    #[prost(uint64, tag = "1")]
    pub max_storage_bytes: u64,
    /// Maximum number of vaults
    #[prost(uint32, tag = "2")]
    pub max_vaults: u32,
    /// Maximum write ops/sec
    #[prost(uint32, tag = "3")]
    pub max_write_ops_per_sec: u32,
    /// Maximum read ops/sec
    #[prost(uint32, tag = "4")]
    pub max_read_ops_per_sec: u32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateNamespaceRequest {
    /// Human-readable name (e.g., "acme_corp")
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Target shard (auto-assigned if not specified)
    #[prost(message, optional, tag = "2")]
    pub shard_id: ::core::option::Option<ShardId>,
    /// Resource quota (server default if not specified)
    #[prost(message, optional, tag = "3")]
    pub quota: ::core::option::Option<NamespaceQuota>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateNamespaceResponse {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Assigned shard
    #[prost(message, optional, tag = "2")]
    pub shard_id: ::core::option::Option<ShardId>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteNamespaceRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteNamespaceResponse {
    #[prost(message, optional, tag = "1")]
    pub deleted_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetNamespaceRequest {
    /// Lookup by ID or name (exactly one must be set)
    #[prost(oneof = "get_namespace_request::Lookup", tags = "1, 2")]
    pub lookup: ::core::option::Option<get_namespace_request::Lookup>,
}
/// Nested message and enum types in `GetNamespaceRequest`.
pub mod get_namespace_request {
    /// Lookup by ID or name (exactly one must be set)
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Lookup {
        #[prost(message, tag = "1")]
        NamespaceId(super::NamespaceId),
        #[prost(string, tag = "2")]
        Name(::prost::alloc::string::String),
    }
}
/// Namespace registry info (routing metadata from \_system)
/// Note: leader_hint is computed dynamically from Raft state via GetSystemState
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNamespaceResponse {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Which shard hosts this namespace
    #[prost(message, optional, tag = "3")]
    pub shard_id: ::core::option::Option<ShardId>,
    /// Nodes in the shard
    #[prost(message, repeated, tag = "4")]
    pub member_nodes: ::prost::alloc::vec::Vec<NodeId>,
    /// Lifecycle state
    #[prost(enumeration = "NamespaceStatus", tag = "5")]
    pub status: i32,
    /// For cache invalidation
    #[prost(uint64, tag = "6")]
    pub config_version: u64,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListNamespacesRequest {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Default: 100, Max: 1000
    #[prost(uint32, tag = "2")]
    pub page_size: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNamespacesResponse {
    #[prost(message, repeated, tag = "1")]
    pub namespaces: ::prost::alloc::vec::Vec<GetNamespaceResponse>,
    /// Absent if no more pages
    #[prost(bytes = "vec", optional, tag = "2")]
    pub next_page_token: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// Create a new vault. VaultId is leader-assigned from \_meta:seq:vault
/// and returned in CreateVaultResponse.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVaultRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(uint32, tag = "2")]
    pub replication_factor: u32,
    #[prost(message, repeated, tag = "3")]
    pub initial_nodes: ::prost::alloc::vec::Vec<NodeId>,
    /// Default: FULL
    #[prost(message, optional, tag = "4")]
    pub retention_policy: ::core::option::Option<BlockRetentionPolicy>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockRetentionPolicy {
    #[prost(enumeration = "BlockRetentionMode", tag = "1")]
    pub mode: i32,
    /// For COMPACTED mode: blocks newer than tip - retention_blocks keep full transactions.
    /// Ignored for FULL mode. Default: 10000 blocks.
    #[prost(uint64, tag = "2")]
    pub retention_blocks: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateVaultResponse {
    #[prost(message, optional, tag = "1")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(message, optional, tag = "2")]
    pub genesis: ::core::option::Option<BlockHeader>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteVaultRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteVaultResponse {
    #[prost(message, optional, tag = "1")]
    pub deleted_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetVaultRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVaultResponse {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    #[prost(uint64, tag = "3")]
    pub height: u64,
    #[prost(message, optional, tag = "4")]
    pub state_root: ::core::option::Option<Hash>,
    #[prost(message, repeated, tag = "5")]
    pub nodes: ::prost::alloc::vec::Vec<NodeId>,
    #[prost(message, optional, tag = "6")]
    pub leader: ::core::option::Option<NodeId>,
    #[prost(enumeration = "VaultStatus", tag = "7")]
    pub status: i32,
    #[prost(message, optional, tag = "8")]
    pub retention_policy: ::core::option::Option<BlockRetentionPolicy>,
}
/// Empty - lists all vaults on this node
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListVaultsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVaultsResponse {
    #[prost(message, repeated, tag = "1")]
    pub vaults: ::prost::alloc::vec::Vec<GetVaultResponse>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateSnapshotRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateSnapshotResponse {
    #[prost(uint64, tag = "1")]
    pub block_height: u64,
    #[prost(message, optional, tag = "2")]
    pub state_root: ::core::option::Option<Hash>,
    #[prost(string, tag = "3")]
    pub snapshot_path: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CheckIntegrityRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Replay from genesis vs quick check
    #[prost(bool, tag = "3")]
    pub full_check: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckIntegrityResponse {
    #[prost(bool, tag = "1")]
    pub healthy: bool,
    #[prost(message, repeated, tag = "2")]
    pub issues: ::prost::alloc::vec::Vec<IntegrityIssue>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IntegrityIssue {
    #[prost(uint64, tag = "1")]
    pub block_height: u64,
    /// "chain_break", "state_divergence", etc.
    #[prost(string, tag = "2")]
    pub issue_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
}
/// Recover a diverged vault by replaying blocks from archive.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RecoverVaultRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Force recovery even if vault is healthy (for testing/maintenance).
    /// Required for manual intervention after automatic recovery exhausted.
    #[prost(bool, tag = "3")]
    pub force: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RecoverVaultResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// Error details if !success
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// New vault health status after recovery attempt.
    #[prost(enumeration = "VaultHealthProto", tag = "3")]
    pub health_status: i32,
    /// Final block height after recovery.
    #[prost(uint64, tag = "4")]
    pub final_height: u64,
    /// Final state root after recovery (should match expected).
    #[prost(message, optional, tag = "5")]
    pub final_state_root: ::core::option::Option<Hash>,
}
/// Request to simulate vault divergence for testing.
/// This forces a vault into the Diverged state without actual corruption.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SimulateDivergenceRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
    /// Expected state root (fake value for simulation).
    #[prost(message, optional, tag = "3")]
    pub expected_state_root: ::core::option::Option<Hash>,
    /// Computed state root (fake value for simulation).
    #[prost(message, optional, tag = "4")]
    pub computed_state_root: ::core::option::Option<Hash>,
    /// Height at which "divergence" occurred.
    #[prost(uint64, tag = "5")]
    pub at_height: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SimulateDivergenceResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Vault health status after simulation (should be DIVERGED).
    #[prost(enumeration = "VaultHealthProto", tag = "3")]
    pub health_status: i32,
}
/// Force a garbage collection cycle for expired entities.
/// If namespace_id and vault_id are specified, only that vault is scanned.
/// If omitted, all vaults are scanned (cluster-wide GC).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ForceGcRequest {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ForceGcResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Number of expired entities that were removed.
    #[prost(uint64, tag = "3")]
    pub expired_count: u64,
    /// Number of vaults that were scanned.
    #[prost(uint64, tag = "4")]
    pub vaults_scanned: u64,
}
/// Update runtime-reconfigurable configuration parameters.
/// Only fields that are set will be updated; unset fields retain current values.
/// Set dry_run=true to validate without applying.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateConfigRequest {
    /// JSON-encoded RuntimeConfig (only reconfigurable fields).
    /// The JSON structure mirrors the TOML config file format for the
    /// reconfigurable subset: rate_limit, hot_key, compaction, validation.
    #[prost(string, tag = "1")]
    pub config_json: ::prost::alloc::string::String,
    /// If true, validate the config without applying changes.
    #[prost(bool, tag = "2")]
    pub dry_run: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateConfigResponse {
    /// Whether the update was applied (false for dry_run or validation failure).
    #[prost(bool, tag = "1")]
    pub applied: bool,
    /// Human-readable summary: fields changed, or validation error details.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// JSON-encoded current RuntimeConfig after the update (or before, for dry_run).
    #[prost(string, tag = "3")]
    pub current_config_json: ::prost::alloc::string::String,
    /// List of field paths that were changed (e.g., \["rate_limit", "hot_key"\]).
    #[prost(string, repeated, tag = "4")]
    pub changed_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Get current runtime configuration.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConfigRequest {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConfigResponse {
    /// JSON-encoded current RuntimeConfig.
    #[prost(string, tag = "1")]
    pub config_json: ::prost::alloc::string::String,
}
/// Create a consistent backup of shard state.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateBackupRequest {
    /// Optional tag for identifying this backup (e.g., "pre-migration").
    #[prost(string, optional, tag = "1")]
    pub tag: ::core::option::Option<::prost::alloc::string::String>,
    /// For incremental backup: ID of the base (full) backup.
    /// When provided, only pages changed since the base are included.
    /// Omit for a full backup.
    #[prost(string, optional, tag = "2")]
    pub base_backup_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateBackupResponse {
    /// Unique backup identifier (timestamp-based).
    #[prost(string, tag = "1")]
    pub backup_id: ::prost::alloc::string::String,
    /// Shard height at backup time.
    #[prost(uint64, tag = "2")]
    pub shard_height: u64,
    /// Path where the backup was written.
    #[prost(string, tag = "3")]
    pub backup_path: ::prost::alloc::string::String,
    /// Size of the backup in bytes.
    #[prost(uint64, tag = "4")]
    pub size_bytes: u64,
    /// SHA-256 checksum of the backup file.
    #[prost(message, optional, tag = "5")]
    pub checksum: ::core::option::Option<Hash>,
}
/// List available backups.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListBackupsRequest {
    /// Maximum number of backups to return (0 = all).
    #[prost(uint32, tag = "1")]
    pub limit: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupsResponse {
    #[prost(message, repeated, tag = "1")]
    pub backups: ::prost::alloc::vec::Vec<BackupInfo>,
}
/// Metadata about an available backup.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BackupInfo {
    /// Unique backup identifier.
    #[prost(string, tag = "1")]
    pub backup_id: ::prost::alloc::string::String,
    /// Shard height at backup time.
    #[prost(uint64, tag = "2")]
    pub shard_height: u64,
    /// Path where the backup is stored.
    #[prost(string, tag = "3")]
    pub backup_path: ::prost::alloc::string::String,
    /// Size in bytes.
    #[prost(uint64, tag = "4")]
    pub size_bytes: u64,
    /// When the backup was created.
    #[prost(message, optional, tag = "5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// SHA-256 checksum for integrity verification.
    #[prost(message, optional, tag = "6")]
    pub checksum: ::core::option::Option<Hash>,
    /// Chain commitment at backup time (for integrity verification at restore).
    #[prost(message, optional, tag = "7")]
    pub chain_commitment_hash: ::core::option::Option<Hash>,
    /// Snapshot format version.
    #[prost(uint32, tag = "8")]
    pub schema_version: u32,
    /// Optional user-provided tag.
    #[prost(string, tag = "9")]
    pub tag: ::prost::alloc::string::String,
    /// Backup type (full or incremental).
    #[prost(enumeration = "BackupType", tag = "10")]
    pub backup_type: i32,
    /// For incremental backups, the ID of the base (full) backup.
    #[prost(string, optional, tag = "11")]
    pub base_backup_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Number of pages in this backup.
    #[prost(uint64, optional, tag = "12")]
    pub page_count: ::core::option::Option<u64>,
}
/// Restore state from a backup. Requires explicit confirmation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RestoreBackupRequest {
    /// Backup identifier to restore from.
    #[prost(string, tag = "1")]
    pub backup_id: ::prost::alloc::string::String,
    /// Must be true to proceed. Safety gate to prevent accidental restores.
    #[prost(bool, tag = "2")]
    pub confirm: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RestoreBackupResponse {
    /// Whether the restore succeeded.
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// Human-readable result message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Shard height after restore.
    #[prost(uint64, tag = "3")]
    pub restored_height: u64,
}
/// Request to join an existing cluster.
/// The node provides its ID and address so the leader can add it to Raft.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct JoinClusterRequest {
    /// Numeric node ID for Raft
    #[prost(uint64, tag = "1")]
    pub node_id: u64,
    /// gRPC address (e.g., "10.0.0.5:50051")
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct JoinClusterResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    /// Error details if !success
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Current leader (for redirect if needed)
    #[prost(uint64, tag = "3")]
    pub leader_id: u64,
    /// Leader's gRPC address
    #[prost(string, tag = "4")]
    pub leader_address: ::prost::alloc::string::String,
}
/// Request to gracefully leave the cluster.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeaveClusterRequest {
    /// Node requesting to leave
    #[prost(uint64, tag = "1")]
    pub node_id: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeaveClusterResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Get current cluster membership.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetClusterInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClusterInfoResponse {
    #[prost(message, repeated, tag = "1")]
    pub members: ::prost::alloc::vec::Vec<ClusterMember>,
    #[prost(uint64, tag = "2")]
    pub leader_id: u64,
    /// Current Raft term
    #[prost(uint64, tag = "3")]
    pub term: u64,
}
/// Request for node identity (empty - no parameters needed).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetNodeInfoRequest {}
/// Node identity for bootstrap coordination.
/// Available before cluster formation to support coordinated bootstrap.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetNodeInfoResponse {
    /// Node's Snowflake ID (auto-generated, persisted).
    #[prost(uint64, tag = "1")]
    pub node_id: u64,
    /// Node's gRPC address (e.g., "192.168.1.10:50051").
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
    /// True if node is already part of a cluster.
    #[prost(bool, tag = "3")]
    pub is_cluster_member: bool,
    /// Current Raft term (0 if not in cluster).
    #[prost(uint64, tag = "4")]
    pub term: u64,
}
/// A member of the Raft cluster.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClusterMember {
    #[prost(uint64, tag = "1")]
    pub node_id: u64,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
    #[prost(enumeration = "ClusterMemberRole", tag = "3")]
    pub role: i32,
    #[prost(bool, tag = "4")]
    pub is_leader: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthCheckRequest {
    /// Namespace for vault health check
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// If empty, check node health
    #[prost(message, optional, tag = "2")]
    pub vault_id: ::core::option::Option<VaultId>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckResponse {
    #[prost(enumeration = "HealthStatus", tag = "1")]
    pub status: i32,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub details: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPeersRequest {
    /// Limit response size (0 = no limit)
    #[prost(uint32, tag = "1")]
    pub max_peers: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPeersResponse {
    #[prost(message, repeated, tag = "1")]
    pub peers: ::prost::alloc::vec::Vec<PeerInfo>,
    /// For cache invalidation
    #[prost(uint64, tag = "2")]
    pub system_version: u64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PeerInfo {
    #[prost(message, optional, tag = "1")]
    pub node_id: ::core::option::Option<NodeId>,
    /// IP addresses only (no port). IPv4 or IPv6, e.g., \["10.0.0.1", "fd00::1"\].
    /// Must be private/WireGuard IPs—public IPs rejected.
    /// Connect via: addresses\[i\] + ":" + grpc_port
    #[prost(string, repeated, tag = "2")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// gRPC port (same for all addresses), typically 5000
    #[prost(uint32, tag = "3")]
    pub grpc_port: u32,
    #[prost(message, optional, tag = "4")]
    pub last_seen: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AnnouncePeerRequest {
    #[prost(message, optional, tag = "1")]
    pub peer: ::core::option::Option<PeerInfo>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AnnouncePeerResponse {
    #[prost(bool, tag = "1")]
    pub accepted: bool,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSystemStateRequest {
    /// Return empty if version \<= this (cache optimization)
    #[prost(uint64, tag = "1")]
    pub if_version_greater_than: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSystemStateResponse {
    #[prost(uint64, tag = "1")]
    pub version: u64,
    #[prost(message, repeated, tag = "2")]
    pub nodes: ::prost::alloc::vec::Vec<NodeInfo>,
    /// Routing table: namespace → shard
    #[prost(message, repeated, tag = "3")]
    pub namespaces: ::prost::alloc::vec::Vec<NamespaceRegistry>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeInfo {
    #[prost(message, optional, tag = "1")]
    pub node_id: ::core::option::Option<NodeId>,
    /// IP addresses only (no port). IPv4 or IPv6, e.g., \["10.0.0.1", "fd00::1"\].
    /// Must be private/WireGuard IPs—public IPs rejected.
    /// Connect via: addresses\[i\] + ":" + grpc_port
    #[prost(string, repeated, tag = "2")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// gRPC port (same for all addresses), typically 5000
    #[prost(uint32, tag = "3")]
    pub grpc_port: u32,
    /// Voter or Learner
    #[prost(enumeration = "NodeRole", tag = "4")]
    pub role: i32,
    #[prost(message, optional, tag = "5")]
    pub last_heartbeat: ::core::option::Option<::prost_types::Timestamp>,
    /// For voter election ordering
    #[prost(message, optional, tag = "6")]
    pub joined_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Routing entry: namespace → shard assignment
/// Note: leader_hint is computed dynamically from Raft state, not stored here
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespaceRegistry {
    #[prost(message, optional, tag = "1")]
    pub namespace_id: ::core::option::Option<NamespaceId>,
    /// Human-readable namespace name
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Which Raft group hosts this namespace
    #[prost(message, optional, tag = "3")]
    pub shard_id: ::core::option::Option<ShardId>,
    /// Nodes in the shard
    #[prost(message, repeated, tag = "4")]
    pub members: ::prost::alloc::vec::Vec<NodeId>,
    /// Lifecycle state
    #[prost(enumeration = "NamespaceStatus", tag = "5")]
    pub status: i32,
    /// For cache invalidation
    #[prost(uint64, tag = "6")]
    pub config_version: u64,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Raft vote (term + node_id + committed flag).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftVote {
    #[prost(uint64, tag = "1")]
    pub term: u64,
    #[prost(uint64, tag = "2")]
    pub node_id: u64,
    #[prost(bool, tag = "3")]
    pub committed: bool,
}
/// Raft log entry identifier.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftLogId {
    #[prost(uint64, tag = "1")]
    pub term: u64,
    #[prost(uint64, tag = "2")]
    pub index: u64,
}
/// Vote request during leader election.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftVoteRequest {
    #[prost(message, optional, tag = "1")]
    pub vote: ::core::option::Option<RaftVote>,
    #[prost(message, optional, tag = "2")]
    pub last_log_id: ::core::option::Option<RaftLogId>,
    /// Shard ID for multi-shard routing (defaults to system shard 0).
    #[prost(uint64, optional, tag = "3")]
    pub shard_id: ::core::option::Option<u64>,
}
/// Vote response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftVoteResponse {
    #[prost(message, optional, tag = "1")]
    pub vote: ::core::option::Option<RaftVote>,
    #[prost(bool, tag = "2")]
    pub vote_granted: bool,
    #[prost(message, optional, tag = "3")]
    pub last_log_id: ::core::option::Option<RaftLogId>,
}
/// Log replication request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftAppendEntriesRequest {
    #[prost(message, optional, tag = "1")]
    pub vote: ::core::option::Option<RaftVote>,
    #[prost(message, optional, tag = "2")]
    pub prev_log_id: ::core::option::Option<RaftLogId>,
    /// Serialized log entries
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub entries: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "4")]
    pub leader_commit: ::core::option::Option<RaftLogId>,
    /// Shard ID for multi-shard routing (defaults to system shard 0).
    #[prost(uint64, optional, tag = "5")]
    pub shard_id: ::core::option::Option<u64>,
}
/// Log replication response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftAppendEntriesResponse {
    #[prost(message, optional, tag = "1")]
    pub vote: ::core::option::Option<RaftVote>,
    #[prost(bool, tag = "2")]
    pub success: bool,
    #[prost(bool, tag = "3")]
    pub conflict: bool,
}
/// Snapshot installation request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaftInstallSnapshotRequest {
    #[prost(message, optional, tag = "1")]
    pub vote: ::core::option::Option<RaftVote>,
    #[prost(message, optional, tag = "2")]
    pub meta: ::core::option::Option<RaftSnapshotMeta>,
    #[prost(uint64, tag = "3")]
    pub offset: u64,
    #[prost(bytes = "vec", tag = "4")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "5")]
    pub done: bool,
    /// Shard ID for multi-shard routing (defaults to system shard 0).
    #[prost(uint64, optional, tag = "6")]
    pub shard_id: ::core::option::Option<u64>,
}
/// Snapshot installation response.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RaftInstallSnapshotResponse {
    #[prost(message, optional, tag = "1")]
    pub vote: ::core::option::Option<RaftVote>,
}
/// Snapshot metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaftSnapshotMeta {
    #[prost(message, optional, tag = "1")]
    pub last_log_id: ::core::option::Option<RaftLogId>,
    #[prost(message, optional, tag = "2")]
    pub last_membership: ::core::option::Option<RaftMembership>,
    #[prost(string, tag = "3")]
    pub snapshot_id: ::prost::alloc::string::String,
}
/// Raft cluster membership configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaftMembership {
    #[prost(message, repeated, tag = "1")]
    pub configs: ::prost::alloc::vec::Vec<RaftMembershipConfig>,
}
/// Single membership configuration (joint consensus may have multiple).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RaftMembershipConfig {
    /// Map of node_id -> address
    #[prost(map = "uint64, string", tag = "1")]
    pub members: ::std::collections::HashMap<u64, ::prost::alloc::string::String>,
}
/// User account status (lifecycle state machine)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserStatus {
    Unspecified = 0,
    /// User can authenticate
    Active = 1,
    /// Pending organization creation (saga in progress)
    PendingOrg = 2,
    /// User cannot authenticate
    Suspended = 3,
    /// Deletion cascade in progress
    Deleting = 4,
    /// Tombstone for audit
    Deleted = 5,
}
impl UserStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "USER_STATUS_UNSPECIFIED",
            Self::Active => "USER_STATUS_ACTIVE",
            Self::PendingOrg => "USER_STATUS_PENDING_ORG",
            Self::Suspended => "USER_STATUS_SUSPENDED",
            Self::Deleting => "USER_STATUS_DELETING",
            Self::Deleted => "USER_STATUS_DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "USER_STATUS_ACTIVE" => Some(Self::Active),
            "USER_STATUS_PENDING_ORG" => Some(Self::PendingOrg),
            "USER_STATUS_SUSPENDED" => Some(Self::Suspended),
            "USER_STATUS_DELETING" => Some(Self::Deleting),
            "USER_STATUS_DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Direction {
    Unspecified = 0,
    Left = 1,
    Right = 2,
}
impl Direction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DIRECTION_UNSPECIFIED",
            Self::Left => "DIRECTION_LEFT",
            Self::Right => "DIRECTION_RIGHT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
            "DIRECTION_LEFT" => Some(Self::Left),
            "DIRECTION_RIGHT" => Some(Self::Right),
            _ => None,
        }
    }
}
/// Read consistency levels for read operations.
/// Trade-off between consistency and performance/availability.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReadConsistency {
    /// Server default (typically EVENTUAL)
    Unspecified = 0,
    /// Read from any replica (fastest, may be stale)
    Eventual = 1,
    /// Read from leader (strong consistency, higher latency)
    Linearizable = 2,
}
impl ReadConsistency {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "READ_CONSISTENCY_UNSPECIFIED",
            Self::Eventual => "READ_CONSISTENCY_EVENTUAL",
            Self::Linearizable => "READ_CONSISTENCY_LINEARIZABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "READ_CONSISTENCY_UNSPECIFIED" => Some(Self::Unspecified),
            "READ_CONSISTENCY_EVENTUAL" => Some(Self::Eventual),
            "READ_CONSISTENCY_LINEARIZABLE" => Some(Self::Linearizable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WriteErrorCode {
    Unspecified = 0,
    /// not_exists condition failed: key already exists
    KeyExists = 1,
    /// version/value_equals condition: key doesn't exist
    KeyNotFound = 2,
    /// version condition: block height differs
    VersionMismatch = 3,
    /// value_equals condition: value differs
    ValueMismatch = 4,
    /// Idempotency errors
    ///
    /// Duplicate: idempotency_key already committed (same payload)
    AlreadyCommitted = 5,
    /// Recovery: use committed_tx_id, committed_block_height, assigned_sequence
    ///
    /// Conflict: idempotency_key reused with different payload
    IdempotencyKeyReused = 6,
}
impl WriteErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WRITE_ERROR_CODE_UNSPECIFIED",
            Self::KeyExists => "WRITE_ERROR_CODE_KEY_EXISTS",
            Self::KeyNotFound => "WRITE_ERROR_CODE_KEY_NOT_FOUND",
            Self::VersionMismatch => "WRITE_ERROR_CODE_VERSION_MISMATCH",
            Self::ValueMismatch => "WRITE_ERROR_CODE_VALUE_MISMATCH",
            Self::AlreadyCommitted => "WRITE_ERROR_CODE_ALREADY_COMMITTED",
            Self::IdempotencyKeyReused => "WRITE_ERROR_CODE_IDEMPOTENCY_KEY_REUSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WRITE_ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "WRITE_ERROR_CODE_KEY_EXISTS" => Some(Self::KeyExists),
            "WRITE_ERROR_CODE_KEY_NOT_FOUND" => Some(Self::KeyNotFound),
            "WRITE_ERROR_CODE_VERSION_MISMATCH" => Some(Self::VersionMismatch),
            "WRITE_ERROR_CODE_VALUE_MISMATCH" => Some(Self::ValueMismatch),
            "WRITE_ERROR_CODE_ALREADY_COMMITTED" => Some(Self::AlreadyCommitted),
            "WRITE_ERROR_CODE_IDEMPOTENCY_KEY_REUSED" => Some(Self::IdempotencyKeyReused),
            _ => None,
        }
    }
}
/// Error codes for read operations.
/// Used in gRPC status details for structured error handling.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReadErrorCode {
    Unspecified = 0,
    /// Requested height is outside retention window (pruned from storage).
    /// Recovery: Use a more recent height, or re-sync from current tip.
    /// Pagination: If height becomes unavailable mid-pagination, restart
    /// query at current tip with fresh page_token.
    HeightUnavailable = 1,
}
impl ReadErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "READ_ERROR_CODE_UNSPECIFIED",
            Self::HeightUnavailable => "READ_ERROR_CODE_HEIGHT_UNAVAILABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "READ_ERROR_CODE_UNSPECIFIED" => Some(Self::Unspecified),
            "READ_ERROR_CODE_HEIGHT_UNAVAILABLE" => Some(Self::HeightUnavailable),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NamespaceStatus {
    Unspecified = 0,
    /// Accepting requests
    Active = 1,
    /// Being migrated to another shard
    Migrating = 2,
    /// Billing or policy suspension
    Suspended = 3,
    /// Deletion in progress
    Deleting = 4,
    /// Tombstone
    Deleted = 5,
}
impl NamespaceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NAMESPACE_STATUS_UNSPECIFIED",
            Self::Active => "NAMESPACE_STATUS_ACTIVE",
            Self::Migrating => "NAMESPACE_STATUS_MIGRATING",
            Self::Suspended => "NAMESPACE_STATUS_SUSPENDED",
            Self::Deleting => "NAMESPACE_STATUS_DELETING",
            Self::Deleted => "NAMESPACE_STATUS_DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NAMESPACE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "NAMESPACE_STATUS_ACTIVE" => Some(Self::Active),
            "NAMESPACE_STATUS_MIGRATING" => Some(Self::Migrating),
            "NAMESPACE_STATUS_SUSPENDED" => Some(Self::Suspended),
            "NAMESPACE_STATUS_DELETING" => Some(Self::Deleting),
            "NAMESPACE_STATUS_DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
/// Block retention modes for storage/compliance trade-off.
/// See DESIGN.md "Snapshot & Retention Policy" for details.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BlockRetentionMode {
    Unspecified = 0,
    /// Keep all blocks with full transactions indefinitely.
    /// Use case: SOC 2, HIPAA compliance requiring full audit trail.
    Full = 1,
    /// After snapshot, remove transaction bodies for old blocks (headers preserved).
    /// Use case: High-volume workloads prioritizing storage efficiency.
    Compacted = 2,
}
impl BlockRetentionMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BLOCK_RETENTION_MODE_UNSPECIFIED",
            Self::Full => "BLOCK_RETENTION_MODE_FULL",
            Self::Compacted => "BLOCK_RETENTION_MODE_COMPACTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BLOCK_RETENTION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "BLOCK_RETENTION_MODE_FULL" => Some(Self::Full),
            "BLOCK_RETENTION_MODE_COMPACTED" => Some(Self::Compacted),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VaultStatus {
    Unspecified = 0,
    Active = 1,
    ReadOnly = 2,
    Deleted = 3,
}
impl VaultStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VAULT_STATUS_UNSPECIFIED",
            Self::Active => "VAULT_STATUS_ACTIVE",
            Self::ReadOnly => "VAULT_STATUS_READ_ONLY",
            Self::Deleted => "VAULT_STATUS_DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VAULT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "VAULT_STATUS_ACTIVE" => Some(Self::Active),
            "VAULT_STATUS_READ_ONLY" => Some(Self::ReadOnly),
            "VAULT_STATUS_DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
/// Vault health status (mirrors internal VaultHealthStatus enum).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VaultHealthProto {
    Unspecified = 0,
    Healthy = 1,
    Diverged = 2,
    Recovering = 3,
}
impl VaultHealthProto {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VAULT_HEALTH_PROTO_UNSPECIFIED",
            Self::Healthy => "VAULT_HEALTH_PROTO_HEALTHY",
            Self::Diverged => "VAULT_HEALTH_PROTO_DIVERGED",
            Self::Recovering => "VAULT_HEALTH_PROTO_RECOVERING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VAULT_HEALTH_PROTO_UNSPECIFIED" => Some(Self::Unspecified),
            "VAULT_HEALTH_PROTO_HEALTHY" => Some(Self::Healthy),
            "VAULT_HEALTH_PROTO_DIVERGED" => Some(Self::Diverged),
            "VAULT_HEALTH_PROTO_RECOVERING" => Some(Self::Recovering),
            _ => None,
        }
    }
}
/// Backup type indicator.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BackupType {
    /// Full backup containing all database pages.
    Full = 0,
    /// Incremental backup containing only pages changed since the base backup.
    Incremental = 1,
}
impl BackupType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Full => "BACKUP_TYPE_FULL",
            Self::Incremental => "BACKUP_TYPE_INCREMENTAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BACKUP_TYPE_FULL" => Some(Self::Full),
            "BACKUP_TYPE_INCREMENTAL" => Some(Self::Incremental),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ClusterMemberRole {
    Unspecified = 0,
    /// Full voting member
    Voter = 1,
    /// Receiving logs but can't vote
    Learner = 2,
}
impl ClusterMemberRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLUSTER_MEMBER_ROLE_UNSPECIFIED",
            Self::Voter => "CLUSTER_MEMBER_ROLE_VOTER",
            Self::Learner => "CLUSTER_MEMBER_ROLE_LEARNER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLUSTER_MEMBER_ROLE_UNSPECIFIED" => Some(Self::Unspecified),
            "CLUSTER_MEMBER_ROLE_VOTER" => Some(Self::Voter),
            "CLUSTER_MEMBER_ROLE_LEARNER" => Some(Self::Learner),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatus {
    Unspecified = 0,
    Healthy = 1,
    Degraded = 2,
    Unavailable = 3,
}
impl HealthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "HEALTH_STATUS_UNSPECIFIED",
            Self::Healthy => "HEALTH_STATUS_HEALTHY",
            Self::Degraded => "HEALTH_STATUS_DEGRADED",
            Self::Unavailable => "HEALTH_STATUS_UNAVAILABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "HEALTH_STATUS_HEALTHY" => Some(Self::Healthy),
            "HEALTH_STATUS_DEGRADED" => Some(Self::Degraded),
            "HEALTH_STATUS_UNAVAILABLE" => Some(Self::Unavailable),
            _ => None,
        }
    }
}
/// Node role in the cluster (Raft membership type)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeRole {
    Unspecified = 0,
    /// Participates in Raft elections (max 5 per cluster)
    Voter = 1,
    /// Replicates data but doesn't vote (for scaling)
    Learner = 2,
}
impl NodeRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NODE_ROLE_UNSPECIFIED",
            Self::Voter => "NODE_ROLE_VOTER",
            Self::Learner => "NODE_ROLE_LEARNER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NODE_ROLE_UNSPECIFIED" => Some(Self::Unspecified),
            "NODE_ROLE_VOTER" => Some(Self::Voter),
            "NODE_ROLE_LEARNER" => Some(Self::Learner),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod read_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ReadServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ReadServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ReadServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ReadServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ReadServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Read a value from the state tree (unverified, fastest)
        pub async fn read(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.ReadService/Read",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.ReadService", "Read"));
            self.inner.unary(req, path, codec).await
        }
        /// Batch read multiple keys in a single RPC call.
        /// Amortizes network overhead across multiple reads for higher throughput.
        /// All reads use the same namespace/vault scope and consistency level.
        pub async fn batch_read(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchReadRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchReadResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.ReadService/BatchRead",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.ReadService", "BatchRead"));
            self.inner.unary(req, path, codec).await
        }
        /// Read with merkle proof for client-side verification.
        /// Supports both current and historical reads via optional at_height.
        /// Use include_chain_proof=true to verify against a trusted checkpoint.
        pub async fn verified_read(
            &mut self,
            request: impl tonic::IntoRequest<super::VerifiedReadRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VerifiedReadResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.ReadService/VerifiedRead",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.ReadService", "VerifiedRead"));
            self.inner.unary(req, path, codec).await
        }
        /// Read state at a specific block height with proof.
        /// Similar to VerifiedRead with at_height, but at_height is required.
        /// Supports chain proofs for verification against trusted checkpoints.
        pub async fn historical_read(
            &mut self,
            request: impl tonic::IntoRequest<super::HistoricalReadRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HistoricalReadResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.ReadService/HistoricalRead",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.ReadService", "HistoricalRead"));
            self.inner.unary(req, path, codec).await
        }
        /// Stream block announcements as they're committed (lightweight notifications)
        pub async fn watch_blocks(
            &mut self,
            request: impl tonic::IntoRequest<super::WatchBlocksRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::BlockAnnouncement>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.ReadService/WatchBlocks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.ReadService", "WatchBlocks"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Get block by height
        pub async fn get_block(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBlockRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBlockResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.ReadService/GetBlock",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.ReadService", "GetBlock"));
            self.inner.unary(req, path, codec).await
        }
        /// Get multiple blocks for sync/catchup (max 1000 blocks per request)
        pub async fn get_block_range(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBlockRangeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBlockRangeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.ReadService/GetBlockRange",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.ReadService", "GetBlockRange"));
            self.inner.unary(req, path, codec).await
        }
        /// Get current chain tip
        pub async fn get_tip(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTipRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTipResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.ReadService/GetTip",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.ReadService", "GetTip"));
            self.inner.unary(req, path, codec).await
        }
        /// Get client's last committed sequence (for recovery after client restart)
        pub async fn get_client_state(
            &mut self,
            request: impl tonic::IntoRequest<super::GetClientStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetClientStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.ReadService/GetClientState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.ReadService", "GetClientState"));
            self.inner.unary(req, path, codec).await
        }
        /// Query relationships with optional filters (uses dual indexes)
        pub async fn list_relationships(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRelationshipsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRelationshipsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.ReadService/ListRelationships",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.ReadService", "ListRelationships"));
            self.inner.unary(req, path, codec).await
        }
        /// List distinct resources matching a type prefix
        pub async fn list_resources(
            &mut self,
            request: impl tonic::IntoRequest<super::ListResourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListResourcesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.ReadService/ListResources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.ReadService", "ListResources"));
            self.inner.unary(req, path, codec).await
        }
        /// List entities matching a key prefix (for Control data queries)
        pub async fn list_entities(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntitiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntitiesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.ReadService/ListEntities",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.ReadService", "ListEntities"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod read_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with ReadServiceServer.
    #[async_trait]
    pub trait ReadService: std::marker::Send + std::marker::Sync + 'static {
        /// Read a value from the state tree (unverified, fastest)
        async fn read(
            &self,
            request: tonic::Request<super::ReadRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResponse>, tonic::Status>;
        /// Batch read multiple keys in a single RPC call.
        /// Amortizes network overhead across multiple reads for higher throughput.
        /// All reads use the same namespace/vault scope and consistency level.
        async fn batch_read(
            &self,
            request: tonic::Request<super::BatchReadRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchReadResponse>,
            tonic::Status,
        >;
        /// Read with merkle proof for client-side verification.
        /// Supports both current and historical reads via optional at_height.
        /// Use include_chain_proof=true to verify against a trusted checkpoint.
        async fn verified_read(
            &self,
            request: tonic::Request<super::VerifiedReadRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VerifiedReadResponse>,
            tonic::Status,
        >;
        /// Read state at a specific block height with proof.
        /// Similar to VerifiedRead with at_height, but at_height is required.
        /// Supports chain proofs for verification against trusted checkpoints.
        async fn historical_read(
            &self,
            request: tonic::Request<super::HistoricalReadRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HistoricalReadResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the WatchBlocks method.
        type WatchBlocksStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::BlockAnnouncement, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// Stream block announcements as they're committed (lightweight notifications)
        async fn watch_blocks(
            &self,
            request: tonic::Request<super::WatchBlocksRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::WatchBlocksStream>,
            tonic::Status,
        >;
        /// Get block by height
        async fn get_block(
            &self,
            request: tonic::Request<super::GetBlockRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBlockResponse>,
            tonic::Status,
        >;
        /// Get multiple blocks for sync/catchup (max 1000 blocks per request)
        async fn get_block_range(
            &self,
            request: tonic::Request<super::GetBlockRangeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetBlockRangeResponse>,
            tonic::Status,
        >;
        /// Get current chain tip
        async fn get_tip(
            &self,
            request: tonic::Request<super::GetTipRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTipResponse>, tonic::Status>;
        /// Get client's last committed sequence (for recovery after client restart)
        async fn get_client_state(
            &self,
            request: tonic::Request<super::GetClientStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetClientStateResponse>,
            tonic::Status,
        >;
        /// Query relationships with optional filters (uses dual indexes)
        async fn list_relationships(
            &self,
            request: tonic::Request<super::ListRelationshipsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRelationshipsResponse>,
            tonic::Status,
        >;
        /// List distinct resources matching a type prefix
        async fn list_resources(
            &self,
            request: tonic::Request<super::ListResourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListResourcesResponse>,
            tonic::Status,
        >;
        /// List entities matching a key prefix (for Control data queries)
        async fn list_entities(
            &self,
            request: tonic::Request<super::ListEntitiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntitiesResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct ReadServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> ReadServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for ReadServiceServer<T>
    where
        T: ReadService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/ledger.v1.ReadService/Read" => {
                    #[allow(non_camel_case_types)]
                    struct ReadSvc<T: ReadService>(pub Arc<T>);
                    impl<T: ReadService> tonic::server::UnaryService<super::ReadRequest>
                    for ReadSvc<T> {
                        type Response = super::ReadResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReadService>::read(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ReadSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.ReadService/BatchRead" => {
                    #[allow(non_camel_case_types)]
                    struct BatchReadSvc<T: ReadService>(pub Arc<T>);
                    impl<
                        T: ReadService,
                    > tonic::server::UnaryService<super::BatchReadRequest>
                    for BatchReadSvc<T> {
                        type Response = super::BatchReadResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReadService>::batch_read(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchReadSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.ReadService/VerifiedRead" => {
                    #[allow(non_camel_case_types)]
                    struct VerifiedReadSvc<T: ReadService>(pub Arc<T>);
                    impl<
                        T: ReadService,
                    > tonic::server::UnaryService<super::VerifiedReadRequest>
                    for VerifiedReadSvc<T> {
                        type Response = super::VerifiedReadResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::VerifiedReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReadService>::verified_read(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VerifiedReadSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.ReadService/HistoricalRead" => {
                    #[allow(non_camel_case_types)]
                    struct HistoricalReadSvc<T: ReadService>(pub Arc<T>);
                    impl<
                        T: ReadService,
                    > tonic::server::UnaryService<super::HistoricalReadRequest>
                    for HistoricalReadSvc<T> {
                        type Response = super::HistoricalReadResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HistoricalReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReadService>::historical_read(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = HistoricalReadSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.ReadService/WatchBlocks" => {
                    #[allow(non_camel_case_types)]
                    struct WatchBlocksSvc<T: ReadService>(pub Arc<T>);
                    impl<
                        T: ReadService,
                    > tonic::server::ServerStreamingService<super::WatchBlocksRequest>
                    for WatchBlocksSvc<T> {
                        type Response = super::BlockAnnouncement;
                        type ResponseStream = T::WatchBlocksStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WatchBlocksRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReadService>::watch_blocks(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WatchBlocksSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.ReadService/GetBlock" => {
                    #[allow(non_camel_case_types)]
                    struct GetBlockSvc<T: ReadService>(pub Arc<T>);
                    impl<
                        T: ReadService,
                    > tonic::server::UnaryService<super::GetBlockRequest>
                    for GetBlockSvc<T> {
                        type Response = super::GetBlockResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBlockRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReadService>::get_block(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBlockSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.ReadService/GetBlockRange" => {
                    #[allow(non_camel_case_types)]
                    struct GetBlockRangeSvc<T: ReadService>(pub Arc<T>);
                    impl<
                        T: ReadService,
                    > tonic::server::UnaryService<super::GetBlockRangeRequest>
                    for GetBlockRangeSvc<T> {
                        type Response = super::GetBlockRangeResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetBlockRangeRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReadService>::get_block_range(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetBlockRangeSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.ReadService/GetTip" => {
                    #[allow(non_camel_case_types)]
                    struct GetTipSvc<T: ReadService>(pub Arc<T>);
                    impl<
                        T: ReadService,
                    > tonic::server::UnaryService<super::GetTipRequest>
                    for GetTipSvc<T> {
                        type Response = super::GetTipResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetTipRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReadService>::get_tip(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetTipSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.ReadService/GetClientState" => {
                    #[allow(non_camel_case_types)]
                    struct GetClientStateSvc<T: ReadService>(pub Arc<T>);
                    impl<
                        T: ReadService,
                    > tonic::server::UnaryService<super::GetClientStateRequest>
                    for GetClientStateSvc<T> {
                        type Response = super::GetClientStateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetClientStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReadService>::get_client_state(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetClientStateSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.ReadService/ListRelationships" => {
                    #[allow(non_camel_case_types)]
                    struct ListRelationshipsSvc<T: ReadService>(pub Arc<T>);
                    impl<
                        T: ReadService,
                    > tonic::server::UnaryService<super::ListRelationshipsRequest>
                    for ListRelationshipsSvc<T> {
                        type Response = super::ListRelationshipsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListRelationshipsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReadService>::list_relationships(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListRelationshipsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.ReadService/ListResources" => {
                    #[allow(non_camel_case_types)]
                    struct ListResourcesSvc<T: ReadService>(pub Arc<T>);
                    impl<
                        T: ReadService,
                    > tonic::server::UnaryService<super::ListResourcesRequest>
                    for ListResourcesSvc<T> {
                        type Response = super::ListResourcesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListResourcesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReadService>::list_resources(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListResourcesSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.ReadService/ListEntities" => {
                    #[allow(non_camel_case_types)]
                    struct ListEntitiesSvc<T: ReadService>(pub Arc<T>);
                    impl<
                        T: ReadService,
                    > tonic::server::UnaryService<super::ListEntitiesRequest>
                    for ListEntitiesSvc<T> {
                        type Response = super::ListEntitiesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListEntitiesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as ReadService>::list_entities(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListEntitiesSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for ReadServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "ledger.v1.ReadService";
    impl<T> tonic::server::NamedService for ReadServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated client implementations.
pub mod write_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct WriteServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WriteServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WriteServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WriteServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WriteServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Submit a transaction
        pub async fn write(
            &mut self,
            request: impl tonic::IntoRequest<super::WriteRequest>,
        ) -> std::result::Result<tonic::Response<super::WriteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.WriteService/Write",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.WriteService", "Write"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit multiple transactions in a batch
        pub async fn batch_write(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchWriteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchWriteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.WriteService/BatchWrite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.WriteService", "BatchWrite"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod write_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with WriteServiceServer.
    #[async_trait]
    pub trait WriteService: std::marker::Send + std::marker::Sync + 'static {
        /// Submit a transaction
        async fn write(
            &self,
            request: tonic::Request<super::WriteRequest>,
        ) -> std::result::Result<tonic::Response<super::WriteResponse>, tonic::Status>;
        /// Submit multiple transactions in a batch
        async fn batch_write(
            &self,
            request: tonic::Request<super::BatchWriteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchWriteResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct WriteServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> WriteServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for WriteServiceServer<T>
    where
        T: WriteService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/ledger.v1.WriteService/Write" => {
                    #[allow(non_camel_case_types)]
                    struct WriteSvc<T: WriteService>(pub Arc<T>);
                    impl<
                        T: WriteService,
                    > tonic::server::UnaryService<super::WriteRequest> for WriteSvc<T> {
                        type Response = super::WriteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::WriteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WriteService>::write(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = WriteSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.WriteService/BatchWrite" => {
                    #[allow(non_camel_case_types)]
                    struct BatchWriteSvc<T: WriteService>(pub Arc<T>);
                    impl<
                        T: WriteService,
                    > tonic::server::UnaryService<super::BatchWriteRequest>
                    for BatchWriteSvc<T> {
                        type Response = super::BatchWriteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchWriteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as WriteService>::batch_write(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BatchWriteSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for WriteServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "ledger.v1.WriteService";
    impl<T> tonic::server::NamedService for WriteServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated client implementations.
pub mod admin_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct AdminServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdminServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdminServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AdminServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AdminServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a new namespace. NamespaceId is leader-assigned from \_meta:seq:namespace.
        pub async fn create_namespace(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateNamespaceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/CreateNamespace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "CreateNamespace"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a namespace (marks for garbage collection, fails if vaults exist)
        pub async fn delete_namespace(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteNamespaceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/DeleteNamespace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "DeleteNamespace"));
            self.inner.unary(req, path, codec).await
        }
        /// Get namespace info including shard assignment
        pub async fn get_namespace(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNamespaceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/GetNamespace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "GetNamespace"));
            self.inner.unary(req, path, codec).await
        }
        /// List all namespaces (paginated)
        pub async fn list_namespaces(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNamespacesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNamespacesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/ListNamespaces",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "ListNamespaces"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a new vault
        pub async fn create_vault(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateVaultResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/CreateVault",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "CreateVault"));
            self.inner.unary(req, path, codec).await
        }
        /// Delete a vault (marks for garbage collection)
        pub async fn delete_vault(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteVaultResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/DeleteVault",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "DeleteVault"));
            self.inner.unary(req, path, codec).await
        }
        /// Get vault info
        pub async fn get_vault(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetVaultResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/GetVault",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "GetVault"));
            self.inner.unary(req, path, codec).await
        }
        /// List all vaults on this node
        pub async fn list_vaults(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVaultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListVaultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/ListVaults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "ListVaults"));
            self.inner.unary(req, path, codec).await
        }
        /// Request to join an existing cluster. Called by a new node contacting a peer.
        /// The receiving node forwards to the leader, which adds the node as a learner,
        /// waits for it to catch up, then promotes to voter.
        pub async fn join_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::JoinClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::JoinClusterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/JoinCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "JoinCluster"));
            self.inner.unary(req, path, codec).await
        }
        /// Gracefully leave the cluster. Node is removed from Raft membership.
        pub async fn leave_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::LeaveClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LeaveClusterResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/LeaveCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "LeaveCluster"));
            self.inner.unary(req, path, codec).await
        }
        /// Get current cluster membership information.
        pub async fn get_cluster_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetClusterInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetClusterInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/GetClusterInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "GetClusterInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// Get node information for pre-bootstrap coordination.
        /// Available even before cluster is formed. Used by nodes to discover
        /// each other's Snowflake IDs and determine who should bootstrap.
        pub async fn get_node_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNodeInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNodeInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/GetNodeInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "GetNodeInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// Trigger snapshot
        pub async fn create_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSnapshotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateSnapshotResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/CreateSnapshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "CreateSnapshot"));
            self.inner.unary(req, path, codec).await
        }
        /// Run integrity check
        pub async fn check_integrity(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckIntegrityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CheckIntegrityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/CheckIntegrity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "CheckIntegrity"));
            self.inner.unary(req, path, codec).await
        }
        /// Recover a diverged vault by replaying blocks from archive.
        /// This clears the vault's state, replays transactions from block archive,
        /// and verifies state roots match. Only works on diverged vaults unless force=true.
        pub async fn recover_vault(
            &mut self,
            request: impl tonic::IntoRequest<super::RecoverVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RecoverVaultResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/RecoverVault",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "RecoverVault"));
            self.inner.unary(req, path, codec).await
        }
        /// Simulate vault divergence for testing.
        /// Forces a vault into the Diverged state without actual state corruption.
        /// Only available when the server is built with the "test-utils" feature.
        pub async fn simulate_divergence(
            &mut self,
            request: impl tonic::IntoRequest<super::SimulateDivergenceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SimulateDivergenceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/SimulateDivergence",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "SimulateDivergence"));
            self.inner.unary(req, path, codec).await
        }
        /// Force a garbage collection cycle for expired entities.
        /// Useful for testing TTL behavior and operational debugging.
        /// Only the leader can run GC; followers return an error.
        pub async fn force_gc(
            &mut self,
            request: impl tonic::IntoRequest<super::ForceGcRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ForceGcResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/ForceGc",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "ForceGc"));
            self.inner.unary(req, path, codec).await
        }
        /// Update runtime-reconfigurable parameters without server restart.
        /// Supports rate limit thresholds, hot key detection, compaction intervals,
        /// and validation limits. Non-reconfigurable parameters (listen address,
        /// data directory, Raft topology) are rejected with INVALID_ARGUMENT.
        /// Set dry_run=true to validate without applying changes.
        pub async fn update_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/UpdateConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "UpdateConfig"));
            self.inner.unary(req, path, codec).await
        }
        /// Get the current runtime configuration.
        pub async fn get_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/GetConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "GetConfig"));
            self.inner.unary(req, path, codec).await
        }
        /// Create a backup of the current shard state.
        /// Triggers a consistent snapshot, compresses it, and writes to the configured
        /// backup destination. Includes chain commitment for integrity verification.
        pub async fn create_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBackupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateBackupResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/CreateBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "CreateBackup"));
            self.inner.unary(req, path, codec).await
        }
        /// List available backups with metadata.
        pub async fn list_backups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBackupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBackupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/ListBackups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "ListBackups"));
            self.inner.unary(req, path, codec).await
        }
        /// Restore from a backup. Stops the shard, restores state from backup,
        /// and resumes. Requires explicit confirmation via the confirm field.
        pub async fn restore_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::RestoreBackupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RestoreBackupResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.AdminService/RestoreBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.AdminService", "RestoreBackup"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod admin_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with AdminServiceServer.
    #[async_trait]
    pub trait AdminService: std::marker::Send + std::marker::Sync + 'static {
        /// Create a new namespace. NamespaceId is leader-assigned from \_meta:seq:namespace.
        async fn create_namespace(
            &self,
            request: tonic::Request<super::CreateNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateNamespaceResponse>,
            tonic::Status,
        >;
        /// Delete a namespace (marks for garbage collection, fails if vaults exist)
        async fn delete_namespace(
            &self,
            request: tonic::Request<super::DeleteNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteNamespaceResponse>,
            tonic::Status,
        >;
        /// Get namespace info including shard assignment
        async fn get_namespace(
            &self,
            request: tonic::Request<super::GetNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNamespaceResponse>,
            tonic::Status,
        >;
        /// List all namespaces (paginated)
        async fn list_namespaces(
            &self,
            request: tonic::Request<super::ListNamespacesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNamespacesResponse>,
            tonic::Status,
        >;
        /// Create a new vault
        async fn create_vault(
            &self,
            request: tonic::Request<super::CreateVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateVaultResponse>,
            tonic::Status,
        >;
        /// Delete a vault (marks for garbage collection)
        async fn delete_vault(
            &self,
            request: tonic::Request<super::DeleteVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteVaultResponse>,
            tonic::Status,
        >;
        /// Get vault info
        async fn get_vault(
            &self,
            request: tonic::Request<super::GetVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetVaultResponse>,
            tonic::Status,
        >;
        /// List all vaults on this node
        async fn list_vaults(
            &self,
            request: tonic::Request<super::ListVaultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListVaultsResponse>,
            tonic::Status,
        >;
        /// Request to join an existing cluster. Called by a new node contacting a peer.
        /// The receiving node forwards to the leader, which adds the node as a learner,
        /// waits for it to catch up, then promotes to voter.
        async fn join_cluster(
            &self,
            request: tonic::Request<super::JoinClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::JoinClusterResponse>,
            tonic::Status,
        >;
        /// Gracefully leave the cluster. Node is removed from Raft membership.
        async fn leave_cluster(
            &self,
            request: tonic::Request<super::LeaveClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LeaveClusterResponse>,
            tonic::Status,
        >;
        /// Get current cluster membership information.
        async fn get_cluster_info(
            &self,
            request: tonic::Request<super::GetClusterInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetClusterInfoResponse>,
            tonic::Status,
        >;
        /// Get node information for pre-bootstrap coordination.
        /// Available even before cluster is formed. Used by nodes to discover
        /// each other's Snowflake IDs and determine who should bootstrap.
        async fn get_node_info(
            &self,
            request: tonic::Request<super::GetNodeInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetNodeInfoResponse>,
            tonic::Status,
        >;
        /// Trigger snapshot
        async fn create_snapshot(
            &self,
            request: tonic::Request<super::CreateSnapshotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateSnapshotResponse>,
            tonic::Status,
        >;
        /// Run integrity check
        async fn check_integrity(
            &self,
            request: tonic::Request<super::CheckIntegrityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CheckIntegrityResponse>,
            tonic::Status,
        >;
        /// Recover a diverged vault by replaying blocks from archive.
        /// This clears the vault's state, replays transactions from block archive,
        /// and verifies state roots match. Only works on diverged vaults unless force=true.
        async fn recover_vault(
            &self,
            request: tonic::Request<super::RecoverVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RecoverVaultResponse>,
            tonic::Status,
        >;
        /// Simulate vault divergence for testing.
        /// Forces a vault into the Diverged state without actual state corruption.
        /// Only available when the server is built with the "test-utils" feature.
        async fn simulate_divergence(
            &self,
            request: tonic::Request<super::SimulateDivergenceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SimulateDivergenceResponse>,
            tonic::Status,
        >;
        /// Force a garbage collection cycle for expired entities.
        /// Useful for testing TTL behavior and operational debugging.
        /// Only the leader can run GC; followers return an error.
        async fn force_gc(
            &self,
            request: tonic::Request<super::ForceGcRequest>,
        ) -> std::result::Result<tonic::Response<super::ForceGcResponse>, tonic::Status>;
        /// Update runtime-reconfigurable parameters without server restart.
        /// Supports rate limit thresholds, hot key detection, compaction intervals,
        /// and validation limits. Non-reconfigurable parameters (listen address,
        /// data directory, Raft topology) are rejected with INVALID_ARGUMENT.
        /// Set dry_run=true to validate without applying changes.
        async fn update_config(
            &self,
            request: tonic::Request<super::UpdateConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateConfigResponse>,
            tonic::Status,
        >;
        /// Get the current runtime configuration.
        async fn get_config(
            &self,
            request: tonic::Request<super::GetConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetConfigResponse>,
            tonic::Status,
        >;
        /// Create a backup of the current shard state.
        /// Triggers a consistent snapshot, compresses it, and writes to the configured
        /// backup destination. Includes chain commitment for integrity verification.
        async fn create_backup(
            &self,
            request: tonic::Request<super::CreateBackupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateBackupResponse>,
            tonic::Status,
        >;
        /// List available backups with metadata.
        async fn list_backups(
            &self,
            request: tonic::Request<super::ListBackupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBackupsResponse>,
            tonic::Status,
        >;
        /// Restore from a backup. Stops the shard, restores state from backup,
        /// and resumes. Requires explicit confirmation via the confirm field.
        async fn restore_backup(
            &self,
            request: tonic::Request<super::RestoreBackupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RestoreBackupResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct AdminServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> AdminServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for AdminServiceServer<T>
    where
        T: AdminService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/ledger.v1.AdminService/CreateNamespace" => {
                    #[allow(non_camel_case_types)]
                    struct CreateNamespaceSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::CreateNamespaceRequest>
                    for CreateNamespaceSvc<T> {
                        type Response = super::CreateNamespaceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateNamespaceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::create_namespace(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateNamespaceSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/DeleteNamespace" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteNamespaceSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::DeleteNamespaceRequest>
                    for DeleteNamespaceSvc<T> {
                        type Response = super::DeleteNamespaceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteNamespaceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::delete_namespace(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteNamespaceSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/GetNamespace" => {
                    #[allow(non_camel_case_types)]
                    struct GetNamespaceSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::GetNamespaceRequest>
                    for GetNamespaceSvc<T> {
                        type Response = super::GetNamespaceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetNamespaceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::get_namespace(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNamespaceSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/ListNamespaces" => {
                    #[allow(non_camel_case_types)]
                    struct ListNamespacesSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::ListNamespacesRequest>
                    for ListNamespacesSvc<T> {
                        type Response = super::ListNamespacesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListNamespacesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::list_namespaces(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListNamespacesSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/CreateVault" => {
                    #[allow(non_camel_case_types)]
                    struct CreateVaultSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::CreateVaultRequest>
                    for CreateVaultSvc<T> {
                        type Response = super::CreateVaultResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateVaultRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::create_vault(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateVaultSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/DeleteVault" => {
                    #[allow(non_camel_case_types)]
                    struct DeleteVaultSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::DeleteVaultRequest>
                    for DeleteVaultSvc<T> {
                        type Response = super::DeleteVaultResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DeleteVaultRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::delete_vault(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DeleteVaultSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/GetVault" => {
                    #[allow(non_camel_case_types)]
                    struct GetVaultSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::GetVaultRequest>
                    for GetVaultSvc<T> {
                        type Response = super::GetVaultResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetVaultRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::get_vault(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetVaultSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/ListVaults" => {
                    #[allow(non_camel_case_types)]
                    struct ListVaultsSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::ListVaultsRequest>
                    for ListVaultsSvc<T> {
                        type Response = super::ListVaultsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListVaultsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::list_vaults(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListVaultsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/JoinCluster" => {
                    #[allow(non_camel_case_types)]
                    struct JoinClusterSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::JoinClusterRequest>
                    for JoinClusterSvc<T> {
                        type Response = super::JoinClusterResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::JoinClusterRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::join_cluster(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = JoinClusterSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/LeaveCluster" => {
                    #[allow(non_camel_case_types)]
                    struct LeaveClusterSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::LeaveClusterRequest>
                    for LeaveClusterSvc<T> {
                        type Response = super::LeaveClusterResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::LeaveClusterRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::leave_cluster(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = LeaveClusterSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/GetClusterInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetClusterInfoSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::GetClusterInfoRequest>
                    for GetClusterInfoSvc<T> {
                        type Response = super::GetClusterInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetClusterInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::get_cluster_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetClusterInfoSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/GetNodeInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetNodeInfoSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::GetNodeInfoRequest>
                    for GetNodeInfoSvc<T> {
                        type Response = super::GetNodeInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetNodeInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::get_node_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetNodeInfoSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/CreateSnapshot" => {
                    #[allow(non_camel_case_types)]
                    struct CreateSnapshotSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::CreateSnapshotRequest>
                    for CreateSnapshotSvc<T> {
                        type Response = super::CreateSnapshotResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::create_snapshot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateSnapshotSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/CheckIntegrity" => {
                    #[allow(non_camel_case_types)]
                    struct CheckIntegritySvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::CheckIntegrityRequest>
                    for CheckIntegritySvc<T> {
                        type Response = super::CheckIntegrityResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CheckIntegrityRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::check_integrity(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CheckIntegritySvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/RecoverVault" => {
                    #[allow(non_camel_case_types)]
                    struct RecoverVaultSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::RecoverVaultRequest>
                    for RecoverVaultSvc<T> {
                        type Response = super::RecoverVaultResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RecoverVaultRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::recover_vault(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RecoverVaultSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/SimulateDivergence" => {
                    #[allow(non_camel_case_types)]
                    struct SimulateDivergenceSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::SimulateDivergenceRequest>
                    for SimulateDivergenceSvc<T> {
                        type Response = super::SimulateDivergenceResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SimulateDivergenceRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::simulate_divergence(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SimulateDivergenceSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/ForceGc" => {
                    #[allow(non_camel_case_types)]
                    struct ForceGcSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::ForceGcRequest>
                    for ForceGcSvc<T> {
                        type Response = super::ForceGcResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ForceGcRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::force_gc(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ForceGcSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/UpdateConfig" => {
                    #[allow(non_camel_case_types)]
                    struct UpdateConfigSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::UpdateConfigRequest>
                    for UpdateConfigSvc<T> {
                        type Response = super::UpdateConfigResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UpdateConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::update_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UpdateConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/GetConfig" => {
                    #[allow(non_camel_case_types)]
                    struct GetConfigSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::GetConfigRequest>
                    for GetConfigSvc<T> {
                        type Response = super::GetConfigResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetConfigRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::get_config(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetConfigSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/CreateBackup" => {
                    #[allow(non_camel_case_types)]
                    struct CreateBackupSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::CreateBackupRequest>
                    for CreateBackupSvc<T> {
                        type Response = super::CreateBackupResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::CreateBackupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::create_backup(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CreateBackupSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/ListBackups" => {
                    #[allow(non_camel_case_types)]
                    struct ListBackupsSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::ListBackupsRequest>
                    for ListBackupsSvc<T> {
                        type Response = super::ListBackupsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListBackupsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::list_backups(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListBackupsSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.AdminService/RestoreBackup" => {
                    #[allow(non_camel_case_types)]
                    struct RestoreBackupSvc<T: AdminService>(pub Arc<T>);
                    impl<
                        T: AdminService,
                    > tonic::server::UnaryService<super::RestoreBackupRequest>
                    for RestoreBackupSvc<T> {
                        type Response = super::RestoreBackupResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RestoreBackupRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as AdminService>::restore_backup(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RestoreBackupSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for AdminServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "ledger.v1.AdminService";
    impl<T> tonic::server::NamedService for AdminServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated client implementations.
pub mod health_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct HealthServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl HealthServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> HealthServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> HealthServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            HealthServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn check(
            &mut self,
            request: impl tonic::IntoRequest<super::HealthCheckRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.HealthService/Check",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.HealthService", "Check"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod health_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with HealthServiceServer.
    #[async_trait]
    pub trait HealthService: std::marker::Send + std::marker::Sync + 'static {
        async fn check(
            &self,
            request: tonic::Request<super::HealthCheckRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct HealthServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> HealthServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for HealthServiceServer<T>
    where
        T: HealthService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/ledger.v1.HealthService/Check" => {
                    #[allow(non_camel_case_types)]
                    struct CheckSvc<T: HealthService>(pub Arc<T>);
                    impl<
                        T: HealthService,
                    > tonic::server::UnaryService<super::HealthCheckRequest>
                    for CheckSvc<T> {
                        type Response = super::HealthCheckResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::HealthCheckRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as HealthService>::check(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = CheckSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for HealthServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "ledger.v1.HealthService";
    impl<T> tonic::server::NamedService for HealthServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated client implementations.
pub mod system_discovery_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SystemDiscoveryServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SystemDiscoveryServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SystemDiscoveryServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SystemDiscoveryServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SystemDiscoveryServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Get known peers (subset of \_system state, lightweight)
        pub async fn get_peers(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPeersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPeersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.SystemDiscoveryService/GetPeers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.SystemDiscoveryService", "GetPeers"));
            self.inner.unary(req, path, codec).await
        }
        /// Announce a new or updated peer to the cluster
        pub async fn announce_peer(
            &mut self,
            request: impl tonic::IntoRequest<super::AnnouncePeerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnnouncePeerResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.SystemDiscoveryService/AnnouncePeer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("ledger.v1.SystemDiscoveryService", "AnnouncePeer"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get full system state (nodes + vault registry)
        pub async fn get_system_state(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSystemStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSystemStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.SystemDiscoveryService/GetSystemState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("ledger.v1.SystemDiscoveryService", "GetSystemState"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod system_discovery_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with SystemDiscoveryServiceServer.
    #[async_trait]
    pub trait SystemDiscoveryService: std::marker::Send + std::marker::Sync + 'static {
        /// Get known peers (subset of \_system state, lightweight)
        async fn get_peers(
            &self,
            request: tonic::Request<super::GetPeersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPeersResponse>,
            tonic::Status,
        >;
        /// Announce a new or updated peer to the cluster
        async fn announce_peer(
            &self,
            request: tonic::Request<super::AnnouncePeerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnnouncePeerResponse>,
            tonic::Status,
        >;
        /// Get full system state (nodes + vault registry)
        async fn get_system_state(
            &self,
            request: tonic::Request<super::GetSystemStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetSystemStateResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct SystemDiscoveryServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> SystemDiscoveryServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>>
    for SystemDiscoveryServiceServer<T>
    where
        T: SystemDiscoveryService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/ledger.v1.SystemDiscoveryService/GetPeers" => {
                    #[allow(non_camel_case_types)]
                    struct GetPeersSvc<T: SystemDiscoveryService>(pub Arc<T>);
                    impl<
                        T: SystemDiscoveryService,
                    > tonic::server::UnaryService<super::GetPeersRequest>
                    for GetPeersSvc<T> {
                        type Response = super::GetPeersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPeersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SystemDiscoveryService>::get_peers(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetPeersSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.SystemDiscoveryService/AnnouncePeer" => {
                    #[allow(non_camel_case_types)]
                    struct AnnouncePeerSvc<T: SystemDiscoveryService>(pub Arc<T>);
                    impl<
                        T: SystemDiscoveryService,
                    > tonic::server::UnaryService<super::AnnouncePeerRequest>
                    for AnnouncePeerSvc<T> {
                        type Response = super::AnnouncePeerResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AnnouncePeerRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SystemDiscoveryService>::announce_peer(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AnnouncePeerSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.SystemDiscoveryService/GetSystemState" => {
                    #[allow(non_camel_case_types)]
                    struct GetSystemStateSvc<T: SystemDiscoveryService>(pub Arc<T>);
                    impl<
                        T: SystemDiscoveryService,
                    > tonic::server::UnaryService<super::GetSystemStateRequest>
                    for GetSystemStateSvc<T> {
                        type Response = super::GetSystemStateResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetSystemStateRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as SystemDiscoveryService>::get_system_state(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetSystemStateSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for SystemDiscoveryServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "ledger.v1.SystemDiscoveryService";
    impl<T> tonic::server::NamedService for SystemDiscoveryServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
/// Generated client implementations.
pub mod raft_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Internal Raft RPC service for consensus protocol.
    /// Used for inter-node communication: vote, log replication, snapshots.
    #[derive(Debug, Clone)]
    pub struct RaftServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RaftServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RaftServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RaftServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            RaftServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Request vote from peer during leader election.
        pub async fn vote(
            &mut self,
            request: impl tonic::IntoRequest<super::RaftVoteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RaftVoteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.RaftService/Vote",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.RaftService", "Vote"));
            self.inner.unary(req, path, codec).await
        }
        /// Replicate log entries to followers.
        pub async fn append_entries(
            &mut self,
            request: impl tonic::IntoRequest<super::RaftAppendEntriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RaftAppendEntriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.RaftService/AppendEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.RaftService", "AppendEntries"));
            self.inner.unary(req, path, codec).await
        }
        /// Install snapshot on a follower that is too far behind.
        pub async fn install_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::RaftInstallSnapshotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RaftInstallSnapshotResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ledger.v1.RaftService/InstallSnapshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ledger.v1.RaftService", "InstallSnapshot"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod raft_service_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with RaftServiceServer.
    #[async_trait]
    pub trait RaftService: std::marker::Send + std::marker::Sync + 'static {
        /// Request vote from peer during leader election.
        async fn vote(
            &self,
            request: tonic::Request<super::RaftVoteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RaftVoteResponse>,
            tonic::Status,
        >;
        /// Replicate log entries to followers.
        async fn append_entries(
            &self,
            request: tonic::Request<super::RaftAppendEntriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RaftAppendEntriesResponse>,
            tonic::Status,
        >;
        /// Install snapshot on a follower that is too far behind.
        async fn install_snapshot(
            &self,
            request: tonic::Request<super::RaftInstallSnapshotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RaftInstallSnapshotResponse>,
            tonic::Status,
        >;
    }
    /// Internal Raft RPC service for consensus protocol.
    /// Used for inter-node communication: vote, log replication, snapshots.
    #[derive(Debug)]
    pub struct RaftServiceServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> RaftServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for RaftServiceServer<T>
    where
        T: RaftService,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/ledger.v1.RaftService/Vote" => {
                    #[allow(non_camel_case_types)]
                    struct VoteSvc<T: RaftService>(pub Arc<T>);
                    impl<
                        T: RaftService,
                    > tonic::server::UnaryService<super::RaftVoteRequest>
                    for VoteSvc<T> {
                        type Response = super::RaftVoteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RaftVoteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RaftService>::vote(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VoteSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.RaftService/AppendEntries" => {
                    #[allow(non_camel_case_types)]
                    struct AppendEntriesSvc<T: RaftService>(pub Arc<T>);
                    impl<
                        T: RaftService,
                    > tonic::server::UnaryService<super::RaftAppendEntriesRequest>
                    for AppendEntriesSvc<T> {
                        type Response = super::RaftAppendEntriesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RaftAppendEntriesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RaftService>::append_entries(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AppendEntriesSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/ledger.v1.RaftService/InstallSnapshot" => {
                    #[allow(non_camel_case_types)]
                    struct InstallSnapshotSvc<T: RaftService>(pub Arc<T>);
                    impl<
                        T: RaftService,
                    > tonic::server::UnaryService<super::RaftInstallSnapshotRequest>
                    for InstallSnapshotSvc<T> {
                        type Response = super::RaftInstallSnapshotResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RaftInstallSnapshotRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as RaftService>::install_snapshot(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = InstallSnapshotSvc(inner);
                        let codec = tonic_prost::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for RaftServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "ledger.v1.RaftService";
    impl<T> tonic::server::NamedService for RaftServiceServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
