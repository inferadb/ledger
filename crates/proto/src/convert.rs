//! Centralized proto conversion functions.
//!
//! Provides `From` and `Into` implementations for converting between domain
//! types (from `inferadb_ledger_types`) and proto types (generated by prost).
//!
//! # Design
//!
//! Rather than scattering `foo_to_proto` and `proto_to_foo` functions across
//! service files, all conversions are centralized here using Rust's `From` trait.
//! Enables idiomatic `.into()` calls and ensures consistent, tested conversions.
//!
//! # Usage
//!
//! ```no_run
//! # use inferadb_ledger_proto::{proto, convert};
//! # use inferadb_ledger_types::LedgerNodeId;
//! # use openraft::Vote;
//! // Domain to proto
//! let domain_vote = Vote::new(1u64, 42u64);
//! let proto_vote: proto::RaftVote = domain_vote.into();
//!
//! // Proto to domain
//! let proto_vote = proto::RaftVote { term: 1, node_id: 42, committed: false };
//! let domain_vote: Vote<LedgerNodeId> = proto_vote.into();
//! ```
//!
//! # Note
//!
//! The `OrganizationStatus` conversion lives in the `raft` crate because it
//! depends on `inferadb_ledger_state::system::OrganizationStatus`.

use chrono::{DateTime, Utc};
use inferadb_ledger_types::{
    BlockRetentionMode, BlockRetentionPolicy, LedgerNodeId, OrganizationId, OrganizationSlug,
    VaultSlug,
    events::{EventAction, EventEmission, EventEntry, EventOutcome, EventScope},
    merkle::MerkleProof as InternalMerkleProof,
};
use openraft::Vote;
use tonic::Status;

use crate::proto;

// =============================================================================
// Vote conversions (openraft::Vote <-> proto::RaftVote)
// =============================================================================

/// Converts a domain [`Vote`] reference to its protobuf representation.
impl From<&Vote<LedgerNodeId>> for proto::RaftVote {
    fn from(vote: &Vote<LedgerNodeId>) -> Self {
        proto::RaftVote {
            term: vote.leader_id.term,
            node_id: vote.leader_id.node_id,
            committed: vote.committed,
        }
    }
}

/// Converts an owned domain [`Vote`] to its protobuf representation.
impl From<Vote<LedgerNodeId>> for proto::RaftVote {
    fn from(vote: Vote<LedgerNodeId>) -> Self {
        (&vote).into()
    }
}

/// Converts a protobuf [`RaftVote`](proto::RaftVote) reference to the domain [`Vote`].
impl From<&proto::RaftVote> for Vote<LedgerNodeId> {
    fn from(proto: &proto::RaftVote) -> Self {
        if proto.committed {
            Vote::new_committed(proto.term, proto.node_id)
        } else {
            Vote::new(proto.term, proto.node_id)
        }
    }
}

/// Converts an owned protobuf [`RaftVote`](proto::RaftVote) to the domain [`Vote`].
impl From<proto::RaftVote> for Vote<LedgerNodeId> {
    fn from(proto: proto::RaftVote) -> Self {
        (&proto).into()
    }
}

// =============================================================================
// Operation conversions (inferadb_ledger_types::Operation <-> proto::Operation)
// =============================================================================

/// Converts a domain [`Operation`](inferadb_ledger_types::Operation) reference to its protobuf
/// representation.
impl From<&inferadb_ledger_types::Operation> for proto::Operation {
    fn from(op: &inferadb_ledger_types::Operation) -> Self {
        use inferadb_ledger_types::Operation as LedgerOp;
        use proto::operation::Op;

        match op {
            LedgerOp::CreateRelationship { resource, relation, subject } => proto::Operation {
                op: Some(Op::CreateRelationship(proto::CreateRelationship {
                    resource: resource.clone(),
                    relation: relation.clone(),
                    subject: subject.clone(),
                })),
            },
            LedgerOp::DeleteRelationship { resource, relation, subject } => proto::Operation {
                op: Some(Op::DeleteRelationship(proto::DeleteRelationship {
                    resource: resource.clone(),
                    relation: relation.clone(),
                    subject: subject.clone(),
                })),
            },
            LedgerOp::SetEntity { key, value, condition, expires_at } => {
                let condition_proto = condition.as_ref().map(|c| c.into());

                proto::Operation {
                    op: Some(Op::SetEntity(proto::SetEntity {
                        key: key.clone(),
                        value: value.clone(),
                        condition: condition_proto,
                        expires_at: *expires_at,
                    })),
                }
            },
            LedgerOp::DeleteEntity { key } => proto::Operation {
                op: Some(Op::DeleteEntity(proto::DeleteEntity { key: key.clone() })),
            },
            LedgerOp::ExpireEntity { key, expired_at } => proto::Operation {
                op: Some(Op::ExpireEntity(proto::ExpireEntity {
                    key: key.clone(),
                    expired_at: *expired_at,
                })),
            },
        }
    }
}

/// Converts an owned domain [`Operation`](inferadb_ledger_types::Operation) to its protobuf
/// representation.
impl From<inferadb_ledger_types::Operation> for proto::Operation {
    fn from(op: inferadb_ledger_types::Operation) -> Self {
        (&op).into()
    }
}

// =============================================================================
// SetCondition conversions (inferadb_ledger_types::SetCondition <-> proto::SetCondition)
// =============================================================================

/// Converts a domain [`SetCondition`](inferadb_ledger_types::SetCondition) reference to its
/// protobuf representation.
impl From<&inferadb_ledger_types::SetCondition> for proto::SetCondition {
    fn from(c: &inferadb_ledger_types::SetCondition) -> Self {
        use proto::set_condition::Condition;

        let condition = match c {
            inferadb_ledger_types::SetCondition::MustNotExist => Condition::NotExists(true),
            inferadb_ledger_types::SetCondition::MustExist => {
                // Proto uses must_exists field for this
                Condition::MustExists(true)
            },
            inferadb_ledger_types::SetCondition::VersionEquals(v) => Condition::Version(*v),
            inferadb_ledger_types::SetCondition::ValueEquals(bytes) => {
                Condition::ValueEquals(bytes.clone())
            },
        };

        proto::SetCondition { condition: Some(condition) }
    }
}

/// Converts an owned domain [`SetCondition`](inferadb_ledger_types::SetCondition) to its protobuf
/// representation.
impl From<inferadb_ledger_types::SetCondition> for proto::SetCondition {
    fn from(c: inferadb_ledger_types::SetCondition) -> Self {
        (&c).into()
    }
}

// =============================================================================
// SetCondition conversions (proto::SetCondition -> inferadb_ledger_types::SetCondition)
// =============================================================================

/// Converts a protobuf [`SetCondition`](proto::SetCondition) reference to an optional domain
/// [`SetCondition`](inferadb_ledger_types::SetCondition).
///
/// Returns `None` if the proto condition field is not set.
/// The `NotExists(false)` and `MustExists(false)` cases map to their logical
/// inverses for backward compatibility with proto3 default values.
impl From<&proto::SetCondition> for Option<inferadb_ledger_types::SetCondition> {
    fn from(proto: &proto::SetCondition) -> Self {
        use proto::set_condition::Condition;

        proto.condition.as_ref().map(|c| match c {
            Condition::NotExists(true) => inferadb_ledger_types::SetCondition::MustNotExist,
            Condition::NotExists(false) => inferadb_ledger_types::SetCondition::MustExist,
            Condition::MustExists(true) => inferadb_ledger_types::SetCondition::MustExist,
            Condition::MustExists(false) => inferadb_ledger_types::SetCondition::MustNotExist,
            Condition::Version(v) => inferadb_ledger_types::SetCondition::VersionEquals(*v),
            Condition::ValueEquals(v) => {
                inferadb_ledger_types::SetCondition::ValueEquals(v.clone())
            },
        })
    }
}

// =============================================================================
// Operation conversions (proto::Operation -> inferadb_ledger_types::Operation)
// =============================================================================

/// Converts a protobuf [`Operation`](proto::Operation) reference to the domain
/// [`Operation`](inferadb_ledger_types::Operation).
///
/// Returns `Err(Status::InvalidArgument)` if the `op` field is not set.
impl TryFrom<&proto::Operation> for inferadb_ledger_types::Operation {
    type Error = Status;

    fn try_from(proto_op: &proto::Operation) -> Result<Self, Self::Error> {
        use proto::operation::Op;

        let op = proto_op
            .op
            .as_ref()
            .ok_or_else(|| Status::invalid_argument("Operation missing op field"))?;

        match op {
            Op::CreateRelationship(cr) => {
                Ok(inferadb_ledger_types::Operation::CreateRelationship {
                    resource: cr.resource.clone(),
                    relation: cr.relation.clone(),
                    subject: cr.subject.clone(),
                })
            },
            Op::DeleteRelationship(dr) => {
                Ok(inferadb_ledger_types::Operation::DeleteRelationship {
                    resource: dr.resource.clone(),
                    relation: dr.relation.clone(),
                    subject: dr.subject.clone(),
                })
            },
            Op::SetEntity(se) => {
                let condition: Option<inferadb_ledger_types::SetCondition> =
                    se.condition.as_ref().and_then(|c| c.into());

                Ok(inferadb_ledger_types::Operation::SetEntity {
                    key: se.key.clone(),
                    value: se.value.clone(),
                    condition,
                    expires_at: se.expires_at,
                })
            },
            Op::DeleteEntity(de) => {
                Ok(inferadb_ledger_types::Operation::DeleteEntity { key: de.key.clone() })
            },
            Op::ExpireEntity(ee) => Ok(inferadb_ledger_types::Operation::ExpireEntity {
                key: ee.key.clone(),
                expired_at: ee.expired_at,
            }),
        }
    }
}

/// Converts an owned protobuf [`Operation`](proto::Operation) to the domain
/// [`Operation`](inferadb_ledger_types::Operation).
///
/// Delegates to the reference-based conversion.
impl TryFrom<proto::Operation> for inferadb_ledger_types::Operation {
    type Error = Status;

    fn try_from(proto_op: proto::Operation) -> Result<Self, Self::Error> {
        Self::try_from(&proto_op)
    }
}

// =============================================================================
// Entity conversions (inferadb_ledger_types::Entity -> proto::Entity)
// =============================================================================

/// Converts a domain [`Entity`](inferadb_ledger_types::Entity) reference to its protobuf
/// representation.
///
/// Entity keys are converted from bytes to UTF-8 via lossy conversion.
/// An `expires_at` of 0 (never expires) maps to `None`.
impl From<&inferadb_ledger_types::Entity> for proto::Entity {
    fn from(e: &inferadb_ledger_types::Entity) -> Self {
        proto::Entity {
            key: String::from_utf8_lossy(&e.key).to_string(),
            value: e.value.clone(),
            version: e.version,
            // Convert 0 (never expires) to None
            expires_at: if e.expires_at == 0 { None } else { Some(e.expires_at) },
        }
    }
}

// =============================================================================
// Relationship conversions (inferadb_ledger_types::Relationship -> proto::Relationship)
// =============================================================================

/// Converts a domain [`Relationship`](inferadb_ledger_types::Relationship) reference to its
/// protobuf representation.
impl From<&inferadb_ledger_types::Relationship> for proto::Relationship {
    fn from(r: &inferadb_ledger_types::Relationship) -> Self {
        proto::Relationship {
            resource: r.resource.clone(),
            relation: r.relation.clone(),
            subject: r.subject.clone(),
        }
    }
}

/// Converts an owned domain [`Relationship`](inferadb_ledger_types::Relationship) to its protobuf
/// representation.
impl From<inferadb_ledger_types::Relationship> for proto::Relationship {
    fn from(r: inferadb_ledger_types::Relationship) -> Self {
        proto::Relationship { resource: r.resource, relation: r.relation, subject: r.subject }
    }
}

// =============================================================================
// BlockRetentionPolicy conversions
// =============================================================================

/// Converts a domain [`BlockRetentionMode`] to its protobuf representation.
impl From<BlockRetentionMode> for proto::BlockRetentionMode {
    fn from(mode: BlockRetentionMode) -> Self {
        match mode {
            BlockRetentionMode::Full => proto::BlockRetentionMode::Full,
            BlockRetentionMode::Compacted => proto::BlockRetentionMode::Compacted,
        }
    }
}

/// Converts a protobuf [`BlockRetentionPolicy`](proto::BlockRetentionPolicy) reference to the
/// domain type.
///
/// Unspecified mode defaults to `Full`. Zero `retention_blocks` defaults to 10,000.
impl From<&proto::BlockRetentionPolicy> for BlockRetentionPolicy {
    fn from(proto_policy: &proto::BlockRetentionPolicy) -> Self {
        let mode = match proto_policy.mode() {
            proto::BlockRetentionMode::Unspecified | proto::BlockRetentionMode::Full => {
                BlockRetentionMode::Full
            },
            proto::BlockRetentionMode::Compacted => BlockRetentionMode::Compacted,
        };

        BlockRetentionPolicy {
            mode,
            retention_blocks: if proto_policy.retention_blocks > 0 {
                proto_policy.retention_blocks
            } else {
                10_000 // Default
            },
        }
    }
}

/// Converts an owned domain [`BlockRetentionPolicy`] to its protobuf representation.
impl From<BlockRetentionPolicy> for proto::BlockRetentionPolicy {
    fn from(policy: BlockRetentionPolicy) -> Self {
        proto::BlockRetentionPolicy {
            mode: proto::BlockRetentionMode::from(policy.mode).into(),
            retention_blocks: policy.retention_blocks,
        }
    }
}

// =============================================================================
// MerkleProof conversions (InternalMerkleProof -> proto::MerkleProof)
// =============================================================================

/// Converts a domain [`MerkleProof`](InternalMerkleProof) reference to its protobuf representation.
///
/// The internal format stores raw sibling hashes with the `leaf_index` to
/// determine direction. The proto format explicitly encodes direction for
/// each sibling.
impl From<&InternalMerkleProof> for proto::MerkleProof {
    fn from(internal: &InternalMerkleProof) -> Self {
        use proto::Direction;

        let mut index = internal.leaf_index;
        let mut siblings = Vec::with_capacity(internal.proof_hashes.len());

        for hash in &internal.proof_hashes {
            // If current index is even (left child), sibling is on the right
            // If current index is odd (right child), sibling is on the left
            let direction = if index.is_multiple_of(2) {
                Direction::Right // sibling is right, so we do hash(current || sibling)
            } else {
                Direction::Left // sibling is left, so we do hash(sibling || current)
            };

            siblings.push(proto::MerkleSibling {
                hash: Some(proto::Hash { value: hash.to_vec() }),
                direction: direction.into(),
            });

            // Move up to parent index
            index /= 2;
        }

        proto::MerkleProof {
            leaf_hash: Some(proto::Hash { value: internal.leaf_hash.to_vec() }),
            siblings,
        }
    }
}

/// Converts an owned domain [`MerkleProof`](InternalMerkleProof) to its protobuf representation.
impl From<InternalMerkleProof> for proto::MerkleProof {
    fn from(internal: InternalMerkleProof) -> Self {
        (&internal).into()
    }
}

// =============================================================================
// VaultSlug conversions (inferadb_ledger_types::VaultSlug <-> proto::VaultSlug)
// =============================================================================

/// Converts a domain [`VaultSlug`] to its protobuf representation.
impl From<VaultSlug> for proto::VaultSlug {
    fn from(slug: VaultSlug) -> Self {
        proto::VaultSlug { slug: slug.value() }
    }
}

/// Converts a protobuf [`VaultSlug`](proto::VaultSlug) to the domain type.
impl From<proto::VaultSlug> for VaultSlug {
    fn from(proto: proto::VaultSlug) -> Self {
        VaultSlug::new(proto.slug)
    }
}

/// Converts a protobuf [`VaultSlug`](proto::VaultSlug) reference to the domain type.
impl From<&proto::VaultSlug> for VaultSlug {
    fn from(proto: &proto::VaultSlug) -> Self {
        VaultSlug::new(proto.slug)
    }
}

// =============================================================================
// VaultEntry to Block conversion (special case - requires ShardBlock context)
// =============================================================================

/// Converts a VaultEntry from storage to a proto Block.
///
/// This is a free function rather than a `From` impl because it requires additional
/// context (the ShardBlock and vault) to populate the block header.
///
/// The `vault` parameter must be provided by the caller (service layer) since
/// the conversion layer does not have access to the `AppliedState` slug index.
/// The vault is the external Snowflake identifier — never the internal
/// sequential `VaultId`.
pub fn vault_entry_to_proto_block(
    entry: &inferadb_ledger_types::VaultEntry,
    shard_block: &inferadb_ledger_types::ShardBlock,
    vault: VaultSlug,
) -> proto::Block {
    use prost_types::Timestamp;

    // Convert VaultEntry transactions to proto transactions
    let transactions = entry
        .transactions
        .iter()
        .map(|tx| proto::Transaction {
            id: Some(proto::TxId { id: tx.id.to_vec() }),
            client_id: Some(proto::ClientId { id: tx.client_id.clone() }),
            sequence: tx.sequence,
            operations: tx.operations.iter().map(|op| op.into()).collect(),
            timestamp: Some(Timestamp {
                seconds: tx.timestamp.timestamp(),
                nanos: tx.timestamp.timestamp_subsec_nanos() as i32,
            }),
            actor: tx.actor.clone(),
        })
        .collect();

    // Build block header
    let header = proto::BlockHeader {
        height: entry.vault_height,
        organization: Some(proto::OrganizationSlug { slug: entry.organization.value() as u64 }),
        vault: Some(vault.into()),
        previous_hash: Some(proto::Hash { value: entry.previous_vault_hash.to_vec() }),
        tx_merkle_root: Some(proto::Hash { value: entry.tx_merkle_root.to_vec() }),
        state_root: Some(proto::Hash { value: entry.state_root.to_vec() }),
        timestamp: Some(Timestamp {
            seconds: shard_block.timestamp.timestamp(),
            nanos: shard_block.timestamp.timestamp_subsec_nanos() as i32,
        }),
        leader_id: Some(proto::NodeId { id: shard_block.leader_id.clone() }),
        term: shard_block.term,
        committed_index: shard_block.committed_index,
    };

    proto::Block { header: Some(header), transactions }
}

// =============================================================================
// Timestamp conversions (chrono::DateTime<Utc> <-> prost_types::Timestamp)
// =============================================================================

/// Converts a chrono [`DateTime<Utc>`] to a [`prost_types::Timestamp`].
fn datetime_to_proto_timestamp(dt: &DateTime<Utc>) -> prost_types::Timestamp {
    prost_types::Timestamp { seconds: dt.timestamp(), nanos: dt.timestamp_subsec_nanos() as i32 }
}

/// Converts a [`prost_types::Timestamp`] to a chrono [`DateTime<Utc>`].
///
/// Falls back to Unix epoch if the timestamp is invalid.
fn proto_timestamp_to_datetime(ts: &prost_types::Timestamp) -> DateTime<Utc> {
    DateTime::from_timestamp(ts.seconds, ts.nanos as u32).unwrap_or(DateTime::UNIX_EPOCH)
}

// =============================================================================
// EventScope conversions (domain <-> proto)
// =============================================================================

/// Converts a domain [`EventScope`] to its protobuf representation.
impl From<EventScope> for proto::EventScope {
    fn from(scope: EventScope) -> Self {
        match scope {
            EventScope::System => proto::EventScope::System,
            EventScope::Organization => proto::EventScope::Organization,
        }
    }
}

/// Converts a protobuf [`EventScope`](proto::EventScope) to the domain type.
///
/// Unspecified defaults to `Organization`.
impl From<proto::EventScope> for EventScope {
    fn from(proto: proto::EventScope) -> Self {
        match proto {
            proto::EventScope::System => EventScope::System,
            proto::EventScope::Organization | proto::EventScope::Unspecified => {
                EventScope::Organization
            },
        }
    }
}

// =============================================================================
// EventOutcome conversions (domain <-> proto)
// =============================================================================

/// Converts a domain [`EventOutcome`] to its protobuf enum value.
impl From<&EventOutcome> for proto::EventOutcome {
    fn from(outcome: &EventOutcome) -> Self {
        match outcome {
            EventOutcome::Success => proto::EventOutcome::Success,
            EventOutcome::Failed { .. } => proto::EventOutcome::Failed,
            EventOutcome::Denied { .. } => proto::EventOutcome::Denied,
        }
    }
}

// =============================================================================
// EventEmissionPath conversions (domain <-> proto)
// =============================================================================

/// Converts a domain [`EventEmission`] to its protobuf enum value.
impl From<&EventEmission> for proto::EventEmissionPath {
    fn from(emission: &EventEmission) -> Self {
        match emission {
            EventEmission::ApplyPhase => proto::EventEmissionPath::EmissionPathApplyPhase,
            EventEmission::HandlerPhase { .. } => {
                proto::EventEmissionPath::EmissionPathHandlerPhase
            },
        }
    }
}

// =============================================================================
// EventEntry conversions (domain -> proto)
// =============================================================================

/// Converts a domain [`EventEntry`] reference to its protobuf representation.
///
/// The domain type's rich enums (`EventOutcome`, `EventEmission`) are flattened
/// into separate fields in the proto message:
/// - `EventOutcome::Failed { code, detail }` → `outcome=FAILED` + `error_code` + `error_detail`
/// - `EventOutcome::Denied { reason }` → `outcome=DENIED` + `denial_reason`
/// - `EventEmission::HandlerPhase { node_id }` → `emission_path=HANDLER_PHASE` + `node_id`
impl From<&EventEntry> for proto::EventEntry {
    fn from(entry: &EventEntry) -> Self {
        let (error_code, error_detail, denial_reason) = match &entry.outcome {
            EventOutcome::Success => (None, None, None),
            EventOutcome::Failed { code, detail } => {
                (Some(code.clone()), Some(detail.clone()), None)
            },
            EventOutcome::Denied { reason } => (None, None, Some(reason.clone())),
        };

        let node_id = match &entry.emission {
            EventEmission::ApplyPhase => None,
            EventEmission::HandlerPhase { node_id } => Some(*node_id),
        };

        proto::EventEntry {
            event_id: entry.event_id.to_vec(),
            source_service: entry.source_service.clone(),
            event_type: entry.event_type.clone(),
            timestamp: Some(datetime_to_proto_timestamp(&entry.timestamp)),
            scope: proto::EventScope::from(entry.scope).into(),
            action: entry.action.as_str().to_string(),
            emission_path: proto::EventEmissionPath::from(&entry.emission).into(),
            principal: entry.principal.clone(),
            organization: Some(proto::OrganizationSlug {
                slug: entry
                    .organization
                    .map(|s| s.value())
                    .unwrap_or(entry.organization_id.value() as u64),
            }),
            vault: entry.vault.map(|s| proto::VaultSlug { slug: s.value() }),
            outcome: proto::EventOutcome::from(&entry.outcome).into(),
            error_code,
            error_detail,
            denial_reason,
            details: entry.details.iter().map(|(k, v)| (k.clone(), v.clone())).collect(),
            block_height: entry.block_height,
            node_id,
            trace_id: entry.trace_id.clone(),
            correlation_id: entry.correlation_id.clone(),
            operations_count: entry.operations_count,
            expires_at: entry.expires_at,
        }
    }
}

/// Converts an owned domain [`EventEntry`] to its protobuf representation.
impl From<EventEntry> for proto::EventEntry {
    fn from(entry: EventEntry) -> Self {
        (&entry).into()
    }
}

// =============================================================================
// EventEntry conversions (proto -> domain)
// =============================================================================

/// Converts a protobuf [`EventEntry`](proto::EventEntry) reference to the domain type.
///
/// Reconstructs rich enums from flattened proto fields:
/// - `outcome=FAILED` + `error_code` + `error_detail` → `EventOutcome::Failed { code, detail }`
/// - `outcome=DENIED` + `denial_reason` → `EventOutcome::Denied { reason }`
/// - `emission_path=HANDLER_PHASE` + `node_id` → `EventEmission::HandlerPhase { node_id }`
impl TryFrom<&proto::EventEntry> for EventEntry {
    type Error = Status;

    fn try_from(proto_entry: &proto::EventEntry) -> Result<Self, Self::Error> {
        let event_id: [u8; 16] = proto_entry
            .event_id
            .as_slice()
            .try_into()
            .map_err(|_| Status::invalid_argument("event_id must be exactly 16 bytes"))?;

        let timestamp = proto_entry
            .timestamp
            .as_ref()
            .map(proto_timestamp_to_datetime)
            .unwrap_or(DateTime::UNIX_EPOCH);

        let scope = proto::EventScope::try_from(proto_entry.scope)
            .unwrap_or(proto::EventScope::Unspecified)
            .into();

        let action: EventAction = proto_entry.action.parse().map_err(|_: String| {
            Status::invalid_argument(format!("unknown action: {}", proto_entry.action))
        })?;

        let outcome = match proto::EventOutcome::try_from(proto_entry.outcome)
            .unwrap_or(proto::EventOutcome::Unspecified)
        {
            proto::EventOutcome::Success | proto::EventOutcome::Unspecified => {
                EventOutcome::Success
            },
            proto::EventOutcome::Failed => EventOutcome::Failed {
                code: proto_entry.error_code.clone().unwrap_or_default(),
                detail: proto_entry.error_detail.clone().unwrap_or_default(),
            },
            proto::EventOutcome::Denied => EventOutcome::Denied {
                reason: proto_entry.denial_reason.clone().unwrap_or_default(),
            },
        };

        let emission = match proto::EventEmissionPath::try_from(proto_entry.emission_path)
            .unwrap_or(proto::EventEmissionPath::EmissionPathUnspecified)
        {
            proto::EventEmissionPath::EmissionPathApplyPhase
            | proto::EventEmissionPath::EmissionPathUnspecified => EventEmission::ApplyPhase,
            proto::EventEmissionPath::EmissionPathHandlerPhase => {
                EventEmission::HandlerPhase { node_id: proto_entry.node_id.unwrap_or(0) }
            },
        };

        let organization = proto_entry.organization.as_ref().map(|o| OrganizationSlug::new(o.slug));
        let organization_id =
            OrganizationId::new(organization.map(|s| s.value()).unwrap_or(0) as i64);

        Ok(EventEntry {
            expires_at: proto_entry.expires_at,
            event_id,
            source_service: proto_entry.source_service.clone(),
            event_type: proto_entry.event_type.clone(),
            timestamp,
            scope,
            action,
            emission,
            principal: proto_entry.principal.clone(),
            organization_id,
            organization,
            vault: proto_entry.vault.as_ref().map(|v| VaultSlug::new(v.slug)),
            outcome,
            details: proto_entry.details.iter().map(|(k, v)| (k.clone(), v.clone())).collect(),
            block_height: proto_entry.block_height,
            trace_id: proto_entry.trace_id.clone(),
            correlation_id: proto_entry.correlation_id.clone(),
            operations_count: proto_entry.operations_count,
        })
    }
}

/// Converts an owned protobuf [`EventEntry`](proto::EventEntry) to the domain type.
impl TryFrom<proto::EventEntry> for EventEntry {
    type Error = Status;

    fn try_from(proto_entry: proto::EventEntry) -> Result<Self, Self::Error> {
        Self::try_from(&proto_entry)
    }
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    #![allow(clippy::unwrap_used, clippy::expect_used, clippy::panic, clippy::disallowed_methods)]

    use std::collections::BTreeMap;

    use inferadb_ledger_types::hash::Hash;

    use super::*;

    // -------------------------------------------------------------------------
    // Vote conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_vote_to_proto_uncommitted() {
        let vote = Vote::new(5, 42);
        let proto: proto::RaftVote = (&vote).into();

        assert_eq!(proto.term, 5);
        assert_eq!(proto.node_id, 42);
        assert!(!proto.committed);
    }

    #[test]
    fn test_vote_to_proto_committed() {
        let vote = Vote::new_committed(10, 99);
        let proto: proto::RaftVote = (&vote).into();

        assert_eq!(proto.term, 10);
        assert_eq!(proto.node_id, 99);
        assert!(proto.committed);
    }

    #[test]
    fn test_proto_to_vote_uncommitted() {
        let proto = proto::RaftVote { term: 7, node_id: 123, committed: false };
        let vote: Vote<LedgerNodeId> = proto.into();

        assert_eq!(vote.leader_id.term, 7);
        assert_eq!(vote.leader_id.node_id, 123);
        assert!(!vote.committed);
    }

    #[test]
    fn test_proto_to_vote_committed() {
        let proto = proto::RaftVote { term: 15, node_id: 456, committed: true };
        let vote: Vote<LedgerNodeId> = proto.into();

        assert_eq!(vote.leader_id.term, 15);
        assert_eq!(vote.leader_id.node_id, 456);
        assert!(vote.committed);
    }

    #[test]
    fn test_vote_roundtrip() {
        // Uncommitted roundtrip
        let original = Vote::new(100, 200);
        let proto: proto::RaftVote = (&original).into();
        let recovered: Vote<LedgerNodeId> = proto.into();

        assert_eq!(original.leader_id.term, recovered.leader_id.term);
        assert_eq!(original.leader_id.node_id, recovered.leader_id.node_id);
        assert_eq!(original.committed, recovered.committed);

        // Committed roundtrip
        let original_committed = Vote::new_committed(50, 60);
        let proto_committed: proto::RaftVote = (&original_committed).into();
        let recovered_committed: Vote<LedgerNodeId> = proto_committed.into();

        assert_eq!(original_committed.leader_id.term, recovered_committed.leader_id.term);
        assert_eq!(original_committed.leader_id.node_id, recovered_committed.leader_id.node_id);
        assert_eq!(original_committed.committed, recovered_committed.committed);
    }

    // -------------------------------------------------------------------------
    // SetCondition conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_condition_must_not_exist() {
        let condition = inferadb_ledger_types::SetCondition::MustNotExist;
        let proto: proto::SetCondition = (&condition).into();

        assert!(matches!(proto.condition, Some(proto::set_condition::Condition::NotExists(true))));
    }

    #[test]
    fn test_condition_must_exist() {
        let condition = inferadb_ledger_types::SetCondition::MustExist;
        let proto: proto::SetCondition = (&condition).into();

        assert!(matches!(proto.condition, Some(proto::set_condition::Condition::MustExists(true))));
    }

    #[test]
    fn test_condition_version_equals() {
        let condition = inferadb_ledger_types::SetCondition::VersionEquals(42);
        let proto: proto::SetCondition = (&condition).into();

        assert!(matches!(proto.condition, Some(proto::set_condition::Condition::Version(42))));
    }

    #[test]
    fn test_condition_value_equals() {
        let condition = inferadb_ledger_types::SetCondition::ValueEquals(vec![1, 2, 3, 4]);
        let proto: proto::SetCondition = (&condition).into();

        match proto.condition {
            Some(proto::set_condition::Condition::ValueEquals(bytes)) => {
                assert_eq!(bytes, vec![1, 2, 3, 4]);
            },
            _ => panic!("Expected ValueEquals condition"),
        }
    }

    // -------------------------------------------------------------------------
    // Operation conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_operation_create_relationship() {
        let op = inferadb_ledger_types::Operation::CreateRelationship {
            resource: "doc:123".to_string(),
            relation: "viewer".to_string(),
            subject: "user:456".to_string(),
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::CreateRelationship(cr)) => {
                assert_eq!(cr.resource, "doc:123");
                assert_eq!(cr.relation, "viewer");
                assert_eq!(cr.subject, "user:456");
            },
            _ => panic!("Expected CreateRelationship operation"),
        }
    }

    #[test]
    fn test_operation_delete_relationship() {
        let op = inferadb_ledger_types::Operation::DeleteRelationship {
            resource: "folder:abc".to_string(),
            relation: "editor".to_string(),
            subject: "team:xyz".to_string(),
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::DeleteRelationship(dr)) => {
                assert_eq!(dr.resource, "folder:abc");
                assert_eq!(dr.relation, "editor");
                assert_eq!(dr.subject, "team:xyz");
            },
            _ => panic!("Expected DeleteRelationship operation"),
        }
    }

    #[test]
    fn test_operation_set_entity_simple() {
        let op = inferadb_ledger_types::Operation::SetEntity {
            key: "config:timeout".to_string(),
            value: vec![0, 0, 0, 30],
            condition: None,
            expires_at: None,
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::SetEntity(se)) => {
                assert_eq!(se.key, "config:timeout");
                assert_eq!(se.value, vec![0, 0, 0, 30]);
                assert!(se.condition.is_none());
                assert!(se.expires_at.is_none());
            },
            _ => panic!("Expected SetEntity operation"),
        }
    }

    #[test]
    fn test_operation_set_entity_with_condition_and_ttl() {
        let op = inferadb_ledger_types::Operation::SetEntity {
            key: "session:abc".to_string(),
            value: vec![1, 2, 3],
            condition: Some(inferadb_ledger_types::SetCondition::MustNotExist),
            expires_at: Some(1700000000),
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::SetEntity(se)) => {
                assert_eq!(se.key, "session:abc");
                assert_eq!(se.value, vec![1, 2, 3]);
                assert!(se.condition.is_some());
                assert_eq!(se.expires_at, Some(1700000000));
            },
            _ => panic!("Expected SetEntity operation"),
        }
    }

    #[test]
    fn test_operation_delete_entity() {
        let op = inferadb_ledger_types::Operation::DeleteEntity { key: "temp:data".to_string() };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::DeleteEntity(de)) => {
                assert_eq!(de.key, "temp:data");
            },
            _ => panic!("Expected DeleteEntity operation"),
        }
    }

    #[test]
    fn test_operation_expire_entity() {
        let op = inferadb_ledger_types::Operation::ExpireEntity {
            key: "cache:item".to_string(),
            expired_at: 1699999999,
        };
        let proto: proto::Operation = (&op).into();

        match proto.op {
            Some(proto::operation::Op::ExpireEntity(ee)) => {
                assert_eq!(ee.key, "cache:item");
                assert_eq!(ee.expired_at, 1699999999);
            },
            _ => panic!("Expected ExpireEntity operation"),
        }
    }

    // -------------------------------------------------------------------------
    // MerkleProof conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_merkle_proof_empty() {
        let internal = InternalMerkleProof {
            leaf_index: 0,
            leaf_hash: Hash::default(),
            proof_hashes: vec![],
            root: Hash::default(),
        };
        let proto: proto::MerkleProof = (&internal).into();

        assert!(proto.leaf_hash.is_some());
        assert!(proto.siblings.is_empty());
    }

    #[test]
    fn test_merkle_proof_single_sibling() {
        let leaf_hash = Hash::from([1u8; 32]);
        let sibling_hash = Hash::from([2u8; 32]);

        let internal = InternalMerkleProof {
            leaf_index: 0, // Even index = sibling is on the right
            leaf_hash,
            proof_hashes: vec![sibling_hash],
            root: Hash::default(),
        };
        let proto: proto::MerkleProof = (&internal).into();

        assert_eq!(proto.siblings.len(), 1);
        assert_eq!(proto.siblings[0].direction, proto::Direction::Right as i32);
    }

    #[test]
    fn test_merkle_proof_direction_alternating() {
        let internal = InternalMerkleProof {
            leaf_index: 5, // Binary: 101 -> directions: Left, Right, Left
            leaf_hash: Hash::default(),
            proof_hashes: vec![Hash::default(), Hash::default(), Hash::default()],
            root: Hash::default(),
        };
        let proto: proto::MerkleProof = (&internal).into();

        assert_eq!(proto.siblings.len(), 3);
        // Index 5 is odd -> Left
        assert_eq!(proto.siblings[0].direction, proto::Direction::Left as i32);
        // Index 2 (5/2) is even -> Right
        assert_eq!(proto.siblings[1].direction, proto::Direction::Right as i32);
        // Index 1 (2/2) is odd -> Left
        assert_eq!(proto.siblings[2].direction, proto::Direction::Left as i32);
    }

    // -------------------------------------------------------------------------
    // VaultSlug conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_vault_slug_to_proto() {
        let slug = VaultSlug::new(123_456_789);
        let proto: proto::VaultSlug = slug.into();
        assert_eq!(proto.slug, 123_456_789);
    }

    #[test]
    fn test_proto_to_vault_slug() {
        let proto = proto::VaultSlug { slug: 987_654_321 };
        let slug: VaultSlug = proto.into();
        assert_eq!(slug.value(), 987_654_321);
    }

    #[test]
    fn test_proto_ref_to_vault_slug() {
        let proto = proto::VaultSlug { slug: 555_666_777 };
        let slug = VaultSlug::from(&proto);
        assert_eq!(slug.value(), 555_666_777);
    }

    #[test]
    fn test_vault_slug_roundtrip() {
        let original = VaultSlug::new(42_000_000);
        let proto: proto::VaultSlug = original.into();
        let recovered = VaultSlug::from(proto);
        assert_eq!(original, recovered);
    }

    // -------------------------------------------------------------------------
    // VaultEntry to Block conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_vault_entry_to_proto_block_empty_transactions() {
        use chrono::Utc;

        let vault = VaultSlug::new(9_999_999);

        let entry = inferadb_ledger_types::VaultEntry {
            organization: inferadb_ledger_types::OrganizationId::new(1),
            vault: inferadb_ledger_types::VaultId::new(2),
            vault_height: 10,
            previous_vault_hash: Hash::from([0xABu8; 32]),
            transactions: vec![],
            tx_merkle_root: Hash::from([0xCDu8; 32]),
            state_root: Hash::from([0xEFu8; 32]),
        };

        let shard_block = inferadb_ledger_types::ShardBlock {
            shard_id: inferadb_ledger_types::ShardId::new(1),
            shard_height: 100,
            previous_shard_hash: Hash::default(),
            vault_entries: vec![],
            timestamp: Utc::now(),
            leader_id: "node-1".to_string(),
            term: 5,
            committed_index: 99,
        };

        let block = vault_entry_to_proto_block(&entry, &shard_block, vault);

        let header = block.header.expect("Block should have header");
        assert_eq!(header.height, 10);
        assert_eq!(header.organization.unwrap().slug, 1);
        // Vault slug is the external Snowflake identifier, not the internal VaultId
        assert_eq!(header.vault.unwrap().slug, 9_999_999);
        assert_eq!(header.term, 5);
        assert_eq!(header.committed_index, 99);
        assert!(block.transactions.is_empty());
    }

    #[test]
    fn test_vault_entry_to_proto_block_with_transaction() {
        use chrono::Utc;

        let vault = VaultSlug::new(77_777_777);

        let tx = inferadb_ledger_types::Transaction {
            id: *uuid::Uuid::new_v4().as_bytes(),
            client_id: "client-123".to_string(),
            sequence: 1,
            operations: vec![inferadb_ledger_types::Operation::CreateRelationship {
                resource: "doc:1".to_string(),
                relation: "owner".to_string(),
                subject: "user:1".to_string(),
            }],
            timestamp: Utc::now(),
            actor: "user:1".to_string(),
        };

        let entry = inferadb_ledger_types::VaultEntry {
            organization: inferadb_ledger_types::OrganizationId::new(5),
            vault: inferadb_ledger_types::VaultId::new(10),
            vault_height: 1,
            previous_vault_hash: Hash::default(),
            transactions: vec![tx],
            tx_merkle_root: Hash::default(),
            state_root: Hash::default(),
        };

        let shard_block = inferadb_ledger_types::ShardBlock {
            shard_id: inferadb_ledger_types::ShardId::new(1),
            shard_height: 50,
            previous_shard_hash: Hash::default(),
            vault_entries: vec![],
            timestamp: Utc::now(),
            leader_id: "leader-node".to_string(),
            term: 3,
            committed_index: 49,
        };

        let block = vault_entry_to_proto_block(&entry, &shard_block, vault);

        let header = block.header.expect("Block should have header");
        assert_eq!(header.vault.unwrap().slug, 77_777_777);
        assert_eq!(block.transactions.len(), 1);
        let proto_tx = &block.transactions[0];
        assert_eq!(proto_tx.client_id.as_ref().unwrap().id, "client-123");
        assert_eq!(proto_tx.sequence, 1);
        assert_eq!(proto_tx.operations.len(), 1);
    }

    #[test]
    fn test_vault_entry_to_proto_block_slug_independent_of_vault_id() {
        use chrono::Utc;

        // The vault slug is independent of the internal VaultId — verify they differ
        let vault = VaultSlug::new(12_345_678);

        let entry = inferadb_ledger_types::VaultEntry {
            organization: inferadb_ledger_types::OrganizationId::new(1),
            vault: inferadb_ledger_types::VaultId::new(99), // Internal ID is 99
            vault_height: 1,
            previous_vault_hash: Hash::default(),
            transactions: vec![],
            tx_merkle_root: Hash::default(),
            state_root: Hash::default(),
        };

        let shard_block = inferadb_ledger_types::ShardBlock {
            shard_id: inferadb_ledger_types::ShardId::new(1),
            shard_height: 1,
            previous_shard_hash: Hash::default(),
            vault_entries: vec![],
            timestamp: Utc::now(),
            leader_id: "node-1".to_string(),
            term: 1,
            committed_index: 0,
        };

        let block = vault_entry_to_proto_block(&entry, &shard_block, vault);
        let header = block.header.unwrap();

        // Vault slug in header should be 12_345_678 (external), NOT 99 (internal)
        assert_eq!(header.vault.unwrap().slug, 12_345_678);
    }

    // -------------------------------------------------------------------------
    // Proto -> Domain SetCondition conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_proto_to_condition_not_exists() {
        let proto = proto::SetCondition {
            condition: Some(proto::set_condition::Condition::NotExists(true)),
        };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert_eq!(result, Some(inferadb_ledger_types::SetCondition::MustNotExist));
    }

    #[test]
    fn test_proto_to_condition_must_exists() {
        let proto = proto::SetCondition {
            condition: Some(proto::set_condition::Condition::MustExists(true)),
        };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert_eq!(result, Some(inferadb_ledger_types::SetCondition::MustExist));
    }

    #[test]
    fn test_proto_to_condition_version() {
        let proto =
            proto::SetCondition { condition: Some(proto::set_condition::Condition::Version(42)) };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert_eq!(result, Some(inferadb_ledger_types::SetCondition::VersionEquals(42)));
    }

    #[test]
    fn test_proto_to_condition_value_equals() {
        let proto = proto::SetCondition {
            condition: Some(proto::set_condition::Condition::ValueEquals(vec![1, 2, 3])),
        };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert_eq!(result, Some(inferadb_ledger_types::SetCondition::ValueEquals(vec![1, 2, 3])));
    }

    #[test]
    fn test_proto_to_condition_none_returns_none() {
        let proto = proto::SetCondition { condition: None };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert!(result.is_none());
    }

    #[test]
    fn test_proto_to_condition_inverted_booleans() {
        // NotExists(false) should map to MustExist
        let proto = proto::SetCondition {
            condition: Some(proto::set_condition::Condition::NotExists(false)),
        };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert_eq!(result, Some(inferadb_ledger_types::SetCondition::MustExist));

        // MustExists(false) should map to MustNotExist
        let proto = proto::SetCondition {
            condition: Some(proto::set_condition::Condition::MustExists(false)),
        };
        let result: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
        assert_eq!(result, Some(inferadb_ledger_types::SetCondition::MustNotExist));
    }

    // -------------------------------------------------------------------------
    // Proto -> Domain Operation conversion tests (TryFrom)
    // -------------------------------------------------------------------------

    #[test]
    fn test_try_from_create_relationship() {
        let proto_op = proto::Operation {
            op: Some(proto::operation::Op::CreateRelationship(proto::CreateRelationship {
                resource: "doc:1".to_string(),
                relation: "viewer".to_string(),
                subject: "user:2".to_string(),
            })),
        };
        let result = inferadb_ledger_types::Operation::try_from(&proto_op).unwrap();
        assert_eq!(
            result,
            inferadb_ledger_types::Operation::CreateRelationship {
                resource: "doc:1".to_string(),
                relation: "viewer".to_string(),
                subject: "user:2".to_string(),
            }
        );
    }

    #[test]
    fn test_try_from_set_entity_with_condition() {
        let proto_op = proto::Operation {
            op: Some(proto::operation::Op::SetEntity(proto::SetEntity {
                key: "key:1".to_string(),
                value: vec![1, 2, 3],
                condition: Some(proto::SetCondition {
                    condition: Some(proto::set_condition::Condition::Version(5)),
                }),
                expires_at: Some(1700000000),
            })),
        };
        let result = inferadb_ledger_types::Operation::try_from(&proto_op).unwrap();
        assert_eq!(
            result,
            inferadb_ledger_types::Operation::SetEntity {
                key: "key:1".to_string(),
                value: vec![1, 2, 3],
                condition: Some(inferadb_ledger_types::SetCondition::VersionEquals(5)),
                expires_at: Some(1700000000),
            }
        );
    }

    #[test]
    fn test_try_from_missing_op_field() {
        let proto_op = proto::Operation { op: None };
        let result = inferadb_ledger_types::Operation::try_from(&proto_op);
        assert!(result.is_err());
        let status = result.unwrap_err();
        assert_eq!(status.code(), tonic::Code::InvalidArgument);
    }

    #[test]
    fn test_try_from_delete_entity() {
        let proto_op = proto::Operation {
            op: Some(proto::operation::Op::DeleteEntity(proto::DeleteEntity {
                key: "key:del".to_string(),
            })),
        };
        let result = inferadb_ledger_types::Operation::try_from(&proto_op).unwrap();
        assert_eq!(
            result,
            inferadb_ledger_types::Operation::DeleteEntity { key: "key:del".to_string() }
        );
    }

    #[test]
    fn test_try_from_expire_entity() {
        let proto_op = proto::Operation {
            op: Some(proto::operation::Op::ExpireEntity(proto::ExpireEntity {
                key: "key:exp".to_string(),
                expired_at: 1699999999,
            })),
        };
        let result = inferadb_ledger_types::Operation::try_from(&proto_op).unwrap();
        assert_eq!(
            result,
            inferadb_ledger_types::Operation::ExpireEntity {
                key: "key:exp".to_string(),
                expired_at: 1699999999,
            }
        );
    }

    // -------------------------------------------------------------------------
    // Entity conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_entity_to_proto() {
        let entity = inferadb_ledger_types::Entity {
            key: b"test-key".to_vec(),
            value: vec![1, 2, 3],
            expires_at: 1700000000,
            version: 42,
        };
        let proto_entity: proto::Entity = (&entity).into();
        assert_eq!(proto_entity.key, "test-key");
        assert_eq!(proto_entity.value, vec![1, 2, 3]);
        assert_eq!(proto_entity.version, 42);
        assert_eq!(proto_entity.expires_at, Some(1700000000));
    }

    #[test]
    fn test_entity_to_proto_never_expires() {
        let entity = inferadb_ledger_types::Entity {
            key: b"perm-key".to_vec(),
            value: vec![],
            expires_at: 0,
            version: 1,
        };
        let proto_entity: proto::Entity = (&entity).into();
        assert!(proto_entity.expires_at.is_none());
    }

    // -------------------------------------------------------------------------
    // Relationship conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_relationship_to_proto() {
        let rel = inferadb_ledger_types::Relationship {
            resource: "doc:123".to_string(),
            relation: "viewer".to_string(),
            subject: "user:456".to_string(),
        };
        let proto_rel: proto::Relationship = (&rel).into();
        assert_eq!(proto_rel.resource, "doc:123");
        assert_eq!(proto_rel.relation, "viewer");
        assert_eq!(proto_rel.subject, "user:456");
    }

    #[test]
    fn test_relationship_to_proto_owned() {
        let rel = inferadb_ledger_types::Relationship {
            resource: "folder:abc".to_string(),
            relation: "editor".to_string(),
            subject: "team:xyz".to_string(),
        };
        let proto_rel: proto::Relationship = rel.into();
        assert_eq!(proto_rel.resource, "folder:abc");
        assert_eq!(proto_rel.relation, "editor");
        assert_eq!(proto_rel.subject, "team:xyz");
    }

    // -------------------------------------------------------------------------
    // BlockRetentionPolicy conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_retention_policy_full_roundtrip() {
        let policy =
            BlockRetentionPolicy { mode: BlockRetentionMode::Full, retention_blocks: 10_000 };
        let proto_policy: proto::BlockRetentionPolicy = policy.into();
        let recovered = BlockRetentionPolicy::from(&proto_policy);
        assert_eq!(recovered.mode, BlockRetentionMode::Full);
        assert_eq!(recovered.retention_blocks, 10_000);
    }

    #[test]
    fn test_retention_policy_compacted_roundtrip() {
        let policy =
            BlockRetentionPolicy { mode: BlockRetentionMode::Compacted, retention_blocks: 5_000 };
        let proto_policy: proto::BlockRetentionPolicy = policy.into();
        let recovered = BlockRetentionPolicy::from(&proto_policy);
        assert_eq!(recovered.mode, BlockRetentionMode::Compacted);
        assert_eq!(recovered.retention_blocks, 5_000);
    }

    #[test]
    fn test_retention_policy_zero_blocks_defaults() {
        let proto_policy = proto::BlockRetentionPolicy {
            mode: proto::BlockRetentionMode::Full.into(),
            retention_blocks: 0,
        };
        let recovered = BlockRetentionPolicy::from(&proto_policy);
        assert_eq!(recovered.retention_blocks, 10_000); // Default
    }

    #[test]
    fn test_retention_mode_unspecified_defaults_to_full() {
        let proto_policy = proto::BlockRetentionPolicy {
            mode: proto::BlockRetentionMode::Unspecified.into(),
            retention_blocks: 100,
        };
        let recovered = BlockRetentionPolicy::from(&proto_policy);
        assert_eq!(recovered.mode, BlockRetentionMode::Full);
    }

    // -------------------------------------------------------------------------
    // EventScope conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_event_scope_system_to_proto() {
        let proto_scope = proto::EventScope::from(EventScope::System);
        assert_eq!(proto_scope, proto::EventScope::System);
    }

    #[test]
    fn test_event_scope_organization_to_proto() {
        let proto_scope = proto::EventScope::from(EventScope::Organization);
        assert_eq!(proto_scope, proto::EventScope::Organization);
    }

    #[test]
    fn test_event_scope_proto_to_domain() {
        assert_eq!(EventScope::from(proto::EventScope::System), EventScope::System);
        assert_eq!(EventScope::from(proto::EventScope::Organization), EventScope::Organization);
    }

    #[test]
    fn test_event_scope_unspecified_defaults_to_organization() {
        assert_eq!(EventScope::from(proto::EventScope::Unspecified), EventScope::Organization);
    }

    // -------------------------------------------------------------------------
    // EventOutcome conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_event_outcome_success_to_proto() {
        let proto_outcome = proto::EventOutcome::from(&EventOutcome::Success);
        assert_eq!(proto_outcome, proto::EventOutcome::Success);
    }

    #[test]
    fn test_event_outcome_failed_to_proto() {
        let outcome =
            EventOutcome::Failed { code: "E1001".to_string(), detail: "disk full".to_string() };
        let proto_outcome = proto::EventOutcome::from(&outcome);
        assert_eq!(proto_outcome, proto::EventOutcome::Failed);
    }

    #[test]
    fn test_event_outcome_denied_to_proto() {
        let outcome = EventOutcome::Denied { reason: "rate limited".to_string() };
        let proto_outcome = proto::EventOutcome::from(&outcome);
        assert_eq!(proto_outcome, proto::EventOutcome::Denied);
    }

    // -------------------------------------------------------------------------
    // EventEmissionPath conversion tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_event_emission_apply_phase_to_proto() {
        let proto_ep = proto::EventEmissionPath::from(&EventEmission::ApplyPhase);
        assert_eq!(proto_ep, proto::EventEmissionPath::EmissionPathApplyPhase);
    }

    #[test]
    fn test_event_emission_handler_phase_to_proto() {
        let proto_ep = proto::EventEmissionPath::from(&EventEmission::HandlerPhase { node_id: 42 });
        assert_eq!(proto_ep, proto::EventEmissionPath::EmissionPathHandlerPhase);
    }

    // -------------------------------------------------------------------------
    // EventEntry domain -> proto -> domain roundtrip tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_event_entry_success_roundtrip() {
        use std::collections::BTreeMap;

        use chrono::Utc;

        let entry = EventEntry {
            expires_at: 1_700_000_000,
            event_id: [1u8; 16],
            source_service: "ledger".to_string(),
            event_type: "ledger.vault.created".to_string(),
            timestamp: Utc::now(),
            scope: EventScope::Organization,
            action: EventAction::VaultCreated,
            emission: EventEmission::ApplyPhase,
            principal: "system".to_string(),
            organization_id: OrganizationId::new(42),
            organization: Some(OrganizationSlug::new(12345)),
            vault: Some(VaultSlug::new(67890)),
            outcome: EventOutcome::Success,
            details: BTreeMap::from([("key".to_string(), "val".to_string())]),
            block_height: Some(100),
            trace_id: Some("abc-123".to_string()),
            correlation_id: Some("corr-456".to_string()),
            operations_count: Some(5),
        };

        let proto_entry: proto::EventEntry = (&entry).into();
        let recovered = EventEntry::try_from(&proto_entry).unwrap();

        assert_eq!(recovered.event_id, entry.event_id);
        assert_eq!(recovered.source_service, entry.source_service);
        assert_eq!(recovered.event_type, entry.event_type);
        assert_eq!(recovered.scope, entry.scope);
        assert_eq!(recovered.action, entry.action);
        assert_eq!(recovered.emission, entry.emission);
        assert_eq!(recovered.principal, entry.principal);
        assert_eq!(recovered.organization, entry.organization);
        assert_eq!(recovered.vault, entry.vault);
        assert_eq!(recovered.outcome, entry.outcome);
        assert_eq!(recovered.details, entry.details);
        assert_eq!(recovered.block_height, entry.block_height);
        assert_eq!(recovered.trace_id, entry.trace_id);
        assert_eq!(recovered.correlation_id, entry.correlation_id);
        assert_eq!(recovered.operations_count, entry.operations_count);
        assert_eq!(recovered.expires_at, entry.expires_at);
    }

    #[test]
    fn test_event_entry_failed_outcome_roundtrip() {
        use chrono::Utc;

        let entry = EventEntry {
            expires_at: 0,
            event_id: [2u8; 16],
            source_service: "ledger".to_string(),
            event_type: "ledger.write.committed".to_string(),
            timestamp: Utc::now(),
            scope: EventScope::Organization,
            action: EventAction::WriteCommitted,
            emission: EventEmission::ApplyPhase,
            principal: "user:1".to_string(),
            organization_id: OrganizationId::new(1),
            organization: Some(OrganizationSlug::new(100)),
            vault: None,
            outcome: EventOutcome::Failed {
                code: "E2001".to_string(),
                detail: "constraint violation".to_string(),
            },
            details: BTreeMap::new(),
            block_height: None,
            trace_id: None,
            correlation_id: None,
            operations_count: None,
        };

        let proto_entry: proto::EventEntry = (&entry).into();
        assert_eq!(proto_entry.error_code, Some("E2001".to_string()));
        assert_eq!(proto_entry.error_detail, Some("constraint violation".to_string()));
        assert!(proto_entry.denial_reason.is_none());

        let recovered = EventEntry::try_from(&proto_entry).unwrap();
        assert_eq!(recovered.outcome, entry.outcome);
    }

    #[test]
    fn test_event_entry_denied_outcome_roundtrip() {
        use chrono::Utc;

        let entry = EventEntry {
            expires_at: 1_800_000_000,
            event_id: [3u8; 16],
            source_service: "ledger".to_string(),
            event_type: "ledger.request.rate_limited".to_string(),
            timestamp: Utc::now(),
            scope: EventScope::Organization,
            action: EventAction::RequestRateLimited,
            emission: EventEmission::HandlerPhase { node_id: 7 },
            principal: "client:abc".to_string(),
            organization_id: OrganizationId::new(5),
            organization: Some(OrganizationSlug::new(555)),
            vault: None,
            outcome: EventOutcome::Denied { reason: "rate limit exceeded".to_string() },
            details: BTreeMap::new(),
            block_height: None,
            trace_id: None,
            correlation_id: None,
            operations_count: None,
        };

        let proto_entry: proto::EventEntry = (&entry).into();
        assert!(proto_entry.error_code.is_none());
        assert!(proto_entry.error_detail.is_none());
        assert_eq!(proto_entry.denial_reason, Some("rate limit exceeded".to_string()));
        assert_eq!(proto_entry.node_id, Some(7));

        let recovered = EventEntry::try_from(&proto_entry).unwrap();
        assert_eq!(recovered.outcome, entry.outcome);
        assert_eq!(recovered.emission, entry.emission);
    }

    #[test]
    fn test_event_entry_handler_phase_preserves_node_id() {
        use chrono::Utc;

        let entry = EventEntry {
            expires_at: 0,
            event_id: [4u8; 16],
            source_service: "ledger".to_string(),
            event_type: "ledger.request.quota_exceeded".to_string(),
            timestamp: Utc::now(),
            scope: EventScope::Organization,
            action: EventAction::QuotaExceeded,
            emission: EventEmission::HandlerPhase { node_id: 42 },
            principal: "system".to_string(),
            organization_id: OrganizationId::new(1),
            organization: None,
            vault: None,
            outcome: EventOutcome::Success,
            details: BTreeMap::new(),
            block_height: None,
            trace_id: None,
            correlation_id: None,
            operations_count: None,
        };

        let proto_entry: proto::EventEntry = (&entry).into();
        assert_eq!(
            proto_entry.emission_path,
            proto::EventEmissionPath::EmissionPathHandlerPhase as i32,
        );
        assert_eq!(proto_entry.node_id, Some(42));

        let recovered = EventEntry::try_from(&proto_entry).unwrap();
        assert_eq!(recovered.emission, EventEmission::HandlerPhase { node_id: 42 });
    }

    #[test]
    fn test_event_entry_system_scope_roundtrip() {
        use chrono::Utc;

        let entry = EventEntry {
            expires_at: 1_700_000_000,
            event_id: [5u8; 16],
            source_service: "ledger".to_string(),
            event_type: "ledger.organization.created".to_string(),
            timestamp: Utc::now(),
            scope: EventScope::System,
            action: EventAction::OrganizationCreated,
            emission: EventEmission::ApplyPhase,
            principal: "system".to_string(),
            organization_id: OrganizationId::new(0),
            organization: Some(OrganizationSlug::new(0)),
            vault: None,
            outcome: EventOutcome::Success,
            details: BTreeMap::new(),
            block_height: Some(50),
            trace_id: None,
            correlation_id: None,
            operations_count: None,
        };

        let proto_entry: proto::EventEntry = (&entry).into();
        assert_eq!(proto_entry.scope, proto::EventScope::System as i32);

        let recovered = EventEntry::try_from(&proto_entry).unwrap();
        assert_eq!(recovered.scope, EventScope::System);
        assert_eq!(recovered.action, EventAction::OrganizationCreated);
    }

    #[test]
    fn test_event_entry_invalid_event_id_length() {
        let proto_entry = proto::EventEntry {
            event_id: vec![1, 2, 3], // Only 3 bytes, need 16
            source_service: "ledger".to_string(),
            event_type: "ledger.vault.created".to_string(),
            action: "vault_created".to_string(),
            ..Default::default()
        };

        let result = EventEntry::try_from(&proto_entry);
        assert!(result.is_err());
        let status = result.unwrap_err();
        assert_eq!(status.code(), tonic::Code::InvalidArgument);
    }

    #[test]
    fn test_event_entry_unknown_action() {
        let proto_entry = proto::EventEntry {
            event_id: vec![0u8; 16],
            source_service: "ledger".to_string(),
            event_type: "ledger.unknown.action".to_string(),
            action: "totally_unknown_action".to_string(),
            ..Default::default()
        };

        let result = EventEntry::try_from(&proto_entry);
        assert!(result.is_err());
        let status = result.unwrap_err();
        assert_eq!(status.code(), tonic::Code::InvalidArgument);
    }

    #[test]
    fn test_event_entry_all_actions_roundtrip() {
        use chrono::Utc;

        for action in EventAction::ALL {
            let entry = EventEntry {
                expires_at: 0,
                event_id: [0u8; 16],
                source_service: "ledger".to_string(),
                event_type: action.event_type().to_string(),
                timestamp: Utc::now(),
                scope: action.scope(),
                action: *action,
                emission: EventEmission::ApplyPhase,
                principal: "test".to_string(),
                organization_id: OrganizationId::new(0),
                organization: None,
                vault: None,
                outcome: EventOutcome::Success,
                details: BTreeMap::new(),
                block_height: None,
                trace_id: None,
                correlation_id: None,
                operations_count: None,
            };

            let proto_entry: proto::EventEntry = (&entry).into();
            assert_eq!(proto_entry.action, action.as_str());

            let recovered = EventEntry::try_from(&proto_entry).unwrap();
            assert_eq!(recovered.action, *action, "failed for {:?}", action);
        }
    }

    // -------------------------------------------------------------------------
    // Property-based roundtrip tests
    // -------------------------------------------------------------------------

    mod proptests {
        #![allow(
            clippy::unwrap_used,
            clippy::expect_used,
            clippy::panic,
            clippy::disallowed_methods
        )]

        use inferadb_ledger_test_utils::strategies::{
            arb_entity, arb_event_entry, arb_operation, arb_relationship, arb_set_condition,
            arb_vault_slug,
        };
        use proptest::prelude::*;

        use super::*;

        proptest! {
            /// Operation roundtrip: domain -> proto -> domain preserves all data.
            #[test]
            fn operation_roundtrip(op in arb_operation()) {
                let proto: proto::Operation = (&op).into();
                let recovered = inferadb_ledger_types::Operation::try_from(&proto).unwrap();
                prop_assert_eq!(op, recovered);
            }

            /// SetCondition roundtrip: domain -> proto -> domain preserves all data.
            #[test]
            fn set_condition_roundtrip(cond in arb_set_condition()) {
                let proto: proto::SetCondition = (&cond).into();
                let recovered: Option<inferadb_ledger_types::SetCondition> = (&proto).into();
                prop_assert_eq!(Some(cond), recovered);
            }

            /// Relationship roundtrip: domain -> proto -> domain preserves fields.
            #[test]
            fn relationship_roundtrip(rel in arb_relationship()) {
                let proto: proto::Relationship = (&rel).into();
                let recovered = inferadb_ledger_types::Relationship {
                    resource: proto.resource,
                    relation: proto.relation,
                    subject: proto.subject,
                };
                prop_assert_eq!(rel, recovered);
            }

            /// Entity roundtrip: domain -> proto -> domain preserves data
            /// (key encoding may differ for non-UTF8 keys via lossy conversion).
            #[test]
            fn entity_to_proto_preserves_value(entity in arb_entity()) {
                let proto: proto::Entity = (&entity).into();
                prop_assert_eq!(&proto.value, &entity.value);
                prop_assert_eq!(proto.version, entity.version);
                if entity.expires_at == 0 {
                    prop_assert!(proto.expires_at.is_none());
                } else {
                    prop_assert_eq!(proto.expires_at, Some(entity.expires_at));
                }
            }

            /// VaultSlug roundtrip: domain -> proto -> domain preserves value.
            #[test]
            fn vault_slug_roundtrip(slug in arb_vault_slug()) {
                let proto: proto::VaultSlug = slug.into();
                let recovered = VaultSlug::from(proto);
                prop_assert_eq!(slug, recovered);
            }

            /// EventEntry roundtrip: domain -> proto -> domain preserves all fields.
            ///
            /// Verifies that all `EventAction` variants, all `EventOutcome` variants,
            /// and all `EventEmission` variants survive the conversion.
            #[test]
            fn event_entry_proto_roundtrip(entry in arb_event_entry()) {
                let proto_entry: proto::EventEntry = (&entry).into();
                let recovered = EventEntry::try_from(&proto_entry).unwrap();

                prop_assert_eq!(&entry.event_id, &recovered.event_id);
                prop_assert_eq!(&entry.source_service, &recovered.source_service);
                prop_assert_eq!(&entry.event_type, &recovered.event_type);
                prop_assert_eq!(entry.scope, recovered.scope);
                prop_assert_eq!(entry.action, recovered.action);
                prop_assert_eq!(&entry.emission, &recovered.emission);
                prop_assert_eq!(&entry.principal, &recovered.principal);
                prop_assert_eq!(entry.vault, recovered.vault);
                prop_assert_eq!(&entry.outcome, &recovered.outcome);
                prop_assert_eq!(&entry.details, &recovered.details);
                prop_assert_eq!(entry.block_height, recovered.block_height);
                prop_assert_eq!(&entry.trace_id, &recovered.trace_id);
                prop_assert_eq!(&entry.correlation_id, &recovered.correlation_id);
                prop_assert_eq!(entry.operations_count, recovered.operations_count);
                prop_assert_eq!(entry.expires_at, recovered.expires_at);
            }
        }
    }
}
