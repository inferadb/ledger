syntax = "proto3";

package ledger.v1;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/inferadb/ledger/gen/go/ledger/v1;ledgerv1";

// API Version: 1
// The server validates x-ledger-api-version headers on client-facing RPCs.
// Fields planned for removal must be annotated with [deprecated = true] and a
// comment specifying the removal version, e.g.:
//   string old_field = 5 [deprecated = true]; // Removed in API v2

// =============================================================================
// Core Types
// =============================================================================

// 256-bit hash (SHA-256)
message Hash {
  bytes value = 1; // 32 bytes
}

// External organization identifier (Snowflake-generated slug)
// This is the only identifier exposed to API consumers.
// Internal sequential OrganizationId(i64) is used for storage but never appears in the API.
// Special case: slug = 0 is reserved for _system
message OrganizationSlug {
  uint64 slug = 1;
}

// External Snowflake identifier for a vault.
// This is the only vault identifier exposed to API consumers.
// Internal sequential VaultId(i64) is used for storage but never appears in the API.
message VaultSlug {
  uint64 slug = 1;
}

// Unique shard identifier (Raft group hosting multiple organizations)
message ShardId {
  uint32 id = 1;
}

// Unique node identifier
message NodeId {
  string id = 1;
}

// Unique user identifier (global, stored in _system organization)
// Sequential int64 assigned by Ledger leader (see ID Generation Strategy in DESIGN.md)
message UserId {
  int64 id = 1;
}

// User account status (lifecycle state machine)
enum UserStatus {
  USER_STATUS_UNSPECIFIED = 0;
  USER_STATUS_ACTIVE = 1;      // User can authenticate
  USER_STATUS_PENDING_ORG = 2; // Pending organization creation (saga in progress)
  USER_STATUS_SUSPENDED = 3;   // User cannot authenticate
  USER_STATUS_DELETING = 4;    // Deletion cascade in progress
  USER_STATUS_DELETED = 5;     // Tombstone for audit
}

// User role for global service authorization.
// Organization-level permissions are separate (derived from membership records).
enum UserRole {
  USER_ROLE_UNSPECIFIED = 0;  // Treated as USER (regular user)
  USER_ROLE_USER = 1;         // Regular user
  USER_ROLE_ADMIN = 2;        // Global service administrator
}

// User record (stored in _system organization as Entity with key "user:{id}")
// Users can have multiple email addresses via separate UserEmail entities.
// Organization access is derived from membership records (member:{id} in each org).
// ID assigned by Ledger leader from sequence counter "_meta:seq:user"
message User {
  UserId id = 1;
  string name = 2;              // Display name (1-200 characters)
  int64 primary_email_id = 3;   // References UserEmail.id
  UserStatus status = 4;        // Lifecycle state
  google.protobuf.Timestamp created_at = 5;
  google.protobuf.Timestamp updated_at = 6;
  UserRole role = 7;            // Authorization role (default: USER)
}

// User email address (stored in _system organization as Entity with key "user_email:{id}")
// Each user can have multiple emails; primary is tracked by UserEmail.primary field.
// Constraint: Primary email cannot be deleted (must reassign primary first).
// Global email uniqueness is enforced via index: "_idx:email:{email}" → email_id
// ID assigned by Ledger leader from sequence counter "_meta:seq:user_email"
message UserEmail {
  int64 id = 1;                 // Sequential ID (Ledger-assigned)
  UserId user_id = 2;           // Owning user
  string email = 3;             // Normalized to lowercase (max 320 chars per RFC 5321)
  bool verified = 4;            // Whether email has been verified
  bool primary = 5;             // Whether this is the user's primary email
  google.protobuf.Timestamp created_at = 6;
  google.protobuf.Timestamp verified_at = 7; // When verified (null if unverified)
}

// Email verification token (stored in _system organization with TTL)
// Key: "email_verify:{id}", Index: "_idx:email_verify:token:{token}" → token_id
// Tokens expire after 24 hours via Ledger's TTL mechanism.
// ID assigned by Ledger leader from sequence counter "_meta:seq:email_verify"
message EmailVerificationToken {
  int64 id = 1; // Sequential ID (Ledger-assigned)
  int64 user_email_id = 2; // Email being verified
  string token = 3; // 64-char hex string (32 random bytes)
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp expires_at = 5; // For application-level validation
  google.protobuf.Timestamp used_at = 6; // When token was consumed (null if unused)
}

// Unique client identifier (for idempotency)
message ClientId {
  string id = 1; // Opaque string (max 256 chars, typically API key ID)
}

// Unique transaction identifier
message TxId {
  bytes id = 1; // UUID as 16 bytes
}

// =============================================================================
// Block & Transaction Types
// =============================================================================

message BlockHeader {
  uint64 height = 1;
  OrganizationSlug organization = 2; // Owning organization
  VaultSlug vault = 3; // Vault within organization
  Hash previous_hash = 4;
  Hash tx_merkle_root = 5;
  Hash state_root = 6;
  google.protobuf.Timestamp timestamp = 7;
  // Note: leader_id is included in proto for API completeness but excluded from
  // the 148-byte deterministic block hash computation. This ensures blocks hash
  // identically regardless of which leader committed them. The leader_id is stored
  // in ShardBlock and populated when extracting VaultBlock for client responses.
  NodeId leader_id = 8;
  uint64 term = 9;
  uint64 committed_index = 10;
}

message Block {
  BlockHeader header = 1;
  repeated Transaction transactions = 2;
}

// Lightweight block notification for streaming (excludes transaction bodies)
message BlockAnnouncement {
  OrganizationSlug organization = 1; // Owning organization
  VaultSlug vault = 2; // Vault within organization
  uint64 height = 3;
  Hash block_hash = 4;
  Hash state_root = 5;
  google.protobuf.Timestamp timestamp = 6;
}

message Transaction {
  TxId id = 1;
  ClientId client_id = 2;
  uint64 sequence = 3;
  repeated Operation operations = 4;
  google.protobuf.Timestamp timestamp = 5;
  // Actor identity, ALWAYS server-assigned from authenticated context.
  // Clients cannot specify this - derived from auth:
  //   - Session token → "user:{user_id}"
  //   - API key → "client:{client_id}"
  //   - Internal operation → "system:{component}" (e.g., "system:gc")
  // Format: {type}:{id}, max 128 characters.
  string actor = 6;
}

message Operation {
  oneof op {
    CreateRelationship create_relationship = 1;
    DeleteRelationship delete_relationship = 2;
    SetEntity set_entity = 3;
    DeleteEntity delete_entity = 4;
    ExpireEntity expire_entity = 5; // GC-initiated removal (distinct from user delete)
  }
}

message CreateRelationship {
  string resource = 1; // Format: "type:id" (max 512 chars total)
  string relation = 2; // Relation name (max 64 chars, e.g., "viewer", "editor")
  string subject = 3; // Format: "type:id" or "type:id#relation" (max 512 chars)
}

message DeleteRelationship {
  string resource = 1; // Format: "type:id" (max 512 chars total)
  string relation = 2; // Relation name (max 64 chars)
  string subject = 3; // Format: "type:id" or "type:id#relation" (max 512 chars)
}

message SetEntity {
  string key = 1; // Entity key (max 1024 bytes, UTF-8)
  bytes value = 2; // Entity value (max 1MB)
  optional uint64 expires_at = 3; // Unix epoch seconds; 0 or omit = never expires
  optional SetCondition condition = 4; // Optional conditional write (CAS)
}

// Condition for compare-and-set writes (used for coordination primitives)
message SetCondition {
  oneof condition {
    bool not_exists = 1; // Only set if key doesn't exist
    uint64 version = 2; // Only set if key was last modified at this block height
    bytes value_equals = 3; // Only set if current value matches exactly
    bool must_exists = 4; // Only set if key already exists (for safe updates)
  }
}

message DeleteEntity {
  string key = 1; // Entity key (max 1024 bytes, UTF-8)
}

// GC-initiated entity removal (distinct from user deletion for audit trail)
message ExpireEntity {
  string key = 1; // Entity key (max 1024 bytes, UTF-8)
  uint64 expired_at = 2; // When the entity's TTL was reached (Unix epoch seconds)
}

// Relationship tuple (used in query results)
message Relationship {
  string resource = 1; // Format: "type:id" (max 512 chars)
  string relation = 2; // Relation name (max 64 chars)
  string subject = 3; // Format: "type:id" or "type:id#relation" (max 512 chars)
}

// Entity (used in query results)
message Entity {
  string key = 1; // Entity key (max 1024 bytes, UTF-8)
  bytes value = 2; // Entity value (max 1MB)
  optional uint64 expires_at = 3; // Unix epoch seconds; 0 = never expires
  uint64 version = 4; // Block height when last modified (for conditional writes)
}

// =============================================================================
// Merkle Proof Types
// =============================================================================

enum Direction {
  DIRECTION_UNSPECIFIED = 0;
  DIRECTION_LEFT = 1;
  DIRECTION_RIGHT = 2;
}

// Read consistency levels for read operations.
// Trade-off between consistency and performance/availability.
enum ReadConsistency {
  READ_CONSISTENCY_UNSPECIFIED = 0; // Server default (typically EVENTUAL)
  READ_CONSISTENCY_EVENTUAL = 1; // Read from any replica (fastest, may be stale)
  READ_CONSISTENCY_LINEARIZABLE = 2; // Read from leader (strong consistency, higher latency)
}

// Merkle inclusion proof for transaction in block.
// Verification: recompute root from leaf_hash up through siblings.
// The leaf_hash is SHA-256(canonical_tx_encoding) - see DESIGN.md "Transaction Hash".
message MerkleProof {
  Hash leaf_hash = 1; // SHA-256 of transaction (not included separately)
  repeated MerkleSibling siblings = 2; // Siblings from leaf to root (bottom-up order)
}

message MerkleSibling {
  Hash hash = 1;
  Direction direction = 2; // Where sibling sits: LEFT means hash(sibling || current)
}

// Chain proof linking a trusted height to a response height.
// Used to verify that block at response_height descends from trusted_height.
//
// Ordering: headers[0].height == trusted_height + 1, ascending to response_height.
// The trusted header itself is NOT included (client already has it).
// Verification: chain previous_hash links and verify final header matches response.
//
// Example: trusted_height=100, response_height=103
//   headers = [BlockHeader(101), BlockHeader(102), BlockHeader(103)]
//   Verify: headers[0].previous_hash == sha256(trusted_header)
//           headers[1].previous_hash == sha256(headers[0])
//           headers[2].previous_hash == sha256(headers[1])
message ChainProof {
  repeated BlockHeader headers = 1; // Ascending height order, excludes trusted header
}

// State proof for entity existence verification.
// Unlike transaction proofs (O(log n) Merkle path), state proofs require
// bucket contents because state uses bucket-based hashing for O(1) writes.
message StateProof {
  bytes key = 1; // Entity key
  bytes value = 2; // Entity value
  uint64 expires_at = 3; // TTL (0 = never)
  uint64 version = 4; // Block height when last modified
  uint32 bucket_id = 5; // Bucket assignment (seahash(key) % 256)
  Hash bucket_root = 6; // Computed bucket root
  repeated Hash other_bucket_roots = 7; // 255 other bucket roots (index skips bucket_id)
  uint64 block_height = 8; // Block height this proof is valid for
  Hash state_root = 9; // Expected state_root (for verification)
}

// =============================================================================
// Read Service
// =============================================================================

service ReadService {
  // Read a value from the state tree (unverified, fastest)
  rpc Read(ReadRequest) returns (ReadResponse);

  // Batch read multiple keys in a single RPC call.
  // Amortizes network overhead across multiple reads for higher throughput.
  // All reads use the same organization/vault scope and consistency level.
  rpc BatchRead(BatchReadRequest) returns (BatchReadResponse);

  // Read with merkle proof for client-side verification.
  // Supports both current and historical reads via optional at_height.
  // Use include_chain_proof=true to verify against a trusted checkpoint.
  rpc VerifiedRead(VerifiedReadRequest) returns (VerifiedReadResponse);

  // Read state at a specific block height with proof.
  // Similar to VerifiedRead with at_height, but at_height is required.
  // Supports chain proofs for verification against trusted checkpoints.
  rpc HistoricalRead(HistoricalReadRequest) returns (HistoricalReadResponse);

  // Stream block announcements as they're committed (lightweight notifications)
  rpc WatchBlocks(WatchBlocksRequest) returns (stream BlockAnnouncement);

  // Get block by height
  rpc GetBlock(GetBlockRequest) returns (GetBlockResponse);

  // Get multiple blocks for sync/catchup (max 1000 blocks per request)
  rpc GetBlockRange(GetBlockRangeRequest) returns (GetBlockRangeResponse);

  // Get current chain tip
  rpc GetTip(GetTipRequest) returns (GetTipResponse);

  // Get client's last committed sequence (for recovery after client restart)
  rpc GetClientState(GetClientStateRequest) returns (GetClientStateResponse);

  // Query relationships with optional filters (uses dual indexes)
  rpc ListRelationships(ListRelationshipsRequest) returns (ListRelationshipsResponse);

  // List distinct resources matching a type prefix
  rpc ListResources(ListResourcesRequest) returns (ListResourcesResponse);

  // List entities matching a key prefix (for Control data queries)
  rpc ListEntities(ListEntitiesRequest) returns (ListEntitiesResponse);
}

message ReadRequest {
  OrganizationSlug organization = 1;
  optional VaultSlug vault = 2; // Omit for organization-level reads
  string key = 3;
  ReadConsistency consistency = 4; // Default: EVENTUAL (any replica)
}

message ReadResponse {
  optional bytes value = 1;
  uint64 block_height = 2;
}

// Batch read request: read multiple keys in a single RPC for higher throughput.
// All reads share the same organization, vault, and consistency level.
message BatchReadRequest {
  OrganizationSlug organization = 1;
  optional VaultSlug vault = 2;
  repeated string keys = 3;           // Keys to read (max 1000)
  ReadConsistency consistency = 4;    // Applied to all reads
}

// Batch read response: results for all requested keys.
message BatchReadResponse {
  repeated BatchReadResult results = 1;
  uint64 block_height = 2;            // Block height at time of read
}

// Result for a single key in a batch read.
message BatchReadResult {
  string key = 1;
  optional bytes value = 2;           // None if key not found
  bool found = 3;                     // Explicit found flag for clarity
}

// Verified read: retrieve state with cryptographic proofs for client-side verification.
// Always returns: block_header + merkle_proof (required for verification).
// Use case: Clients that verify state locally, don't trust the server.
//
// For historical reads WITHOUT proofs (audits, debugging), use HistoricalRead
// with include_proof=false to avoid proof generation overhead.
message VerifiedReadRequest {
  OrganizationSlug organization = 1;
  optional VaultSlug vault = 2; // Omit for organization-level reads
  string key = 3;
  optional uint64 at_height = 4; // Read at specific height (0 or omit = current)
  bool include_chain_proof = 5; // Also include chain proof to trusted_height
  optional uint64 trusted_height = 6; // Chain proof starts from this checkpoint
}

message VerifiedReadResponse {
  optional bytes value = 1;
  uint64 block_height = 2;
  BlockHeader block_header = 3;
  MerkleProof merkle_proof = 4;
  optional ChainProof chain_proof = 5;
}

// Historical read: retrieve state at a specific past block height.
// Use case: Audits, compliance queries, debugging past state.
// Performance: Requires snapshot reconstruction (5-20ms hot, 100ms-10s cold).
//
// For verified historical reads with proofs, prefer VerifiedRead(at_height) which
// is optimized for the verification use case. HistoricalRead is for unverified
// archival queries where proof generation would add unnecessary overhead.
message HistoricalReadRequest {
  OrganizationSlug organization = 1;
  optional VaultSlug vault = 2; // Omit for organization-level reads
  string key = 3;
  uint64 at_height = 4; // Required: block height to read from
  bool include_proof = 5; // Include block_header + merkle_proof (default: false)
  bool include_chain_proof = 6; // Also include chain proof (requires include_proof=true)
  optional uint64 trusted_height = 7; // Chain proof starts from this checkpoint
}

message HistoricalReadResponse {
  optional bytes value = 1; // None if key didn't exist at at_height
  uint64 block_height = 2; // Echoes at_height for confirmation
  // Proofs (present only if include_proof=true):
  optional BlockHeader block_header = 3;
  optional MerkleProof merkle_proof = 4;
  optional ChainProof chain_proof = 5; // Present if include_chain_proof was true
}

message WatchBlocksRequest {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
  // First block height to stream. Must be >= 1 (0 is rejected with INVALID_ARGUMENT).
  //
  // Streaming behavior:
  // 1. Historical replay: Streams committed blocks from start_height to current tip
  // 2. Real-time push: After historical replay, stream stays open and pushes new
  //    blocks as they are committed (zero-polling live synchronization)
  // 3. Stream lifetime: Remains open indefinitely until client disconnects
  //
  // Backpressure handling:
  // - Uses tokio::sync::broadcast internally with buffer size 1024
  // - Slow consumers that fall >1024 blocks behind receive a Lagged error
  // - On Lagged error, reconnect with start_height = last_received_height + 1
  //
  // Typical usage for live sync:
  //   stream = WatchBlocks(start_height = last_known_height + 1)
  //   for block in stream:
  //     process(block)
  //     last_known_height = block.height
  uint64 start_height = 3;
}

message GetBlockRequest {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
  uint64 height = 3;
}

message GetBlockResponse {
  Block block = 1;
}

// Fetch multiple blocks for sync/catchup.
// Use case: Client reconnecting after downtime needs to catch up.
message GetBlockRangeRequest {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
  uint64 start_height = 3; // First block to return (inclusive)
  uint64 end_height = 4; // Last block to return (inclusive), max range: 1000 blocks
}

message GetBlockRangeResponse {
  repeated Block blocks = 1; // Ordered by height ascending
  uint64 current_tip = 2; // Current chain tip (for client to know if more syncing needed)
}

message GetTipRequest {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
}

message GetTipResponse {
  uint64 height = 1;
  Hash block_hash = 2;
  Hash state_root = 3;
}

message GetClientStateRequest {
  OrganizationSlug organization = 1;
  optional VaultSlug vault = 2; // Omit for organization-level writes
  ClientId client_id = 3;
}

message GetClientStateResponse {
  uint64 last_committed_sequence = 1;
}

message ListRelationshipsRequest {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
  optional string resource = 3; // Filter by resource (exact match)
  optional string relation = 4; // Filter by relation (exact match)
  optional string subject = 5; // Filter by subject (exact match)
  optional uint64 at_height = 6; // Read at specific height (0 or omit = current)
  uint32 limit = 7; // Max results (0 = default limit)
  // Opaque pagination cursor from previous response. Server-managed; do not parse or modify.
  // Encodes position and query context for consistent pagination across requests.
  string page_token = 8;
  ReadConsistency consistency = 9; // Default: EVENTUAL (any replica)
}

message ListRelationshipsResponse {
  repeated Relationship relationships = 1;
  uint64 block_height = 2;
  string next_page_token = 3; // Opaque cursor for next page; empty if no more results
}

message ListResourcesRequest {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
  string resource_type = 3; // Type prefix (e.g., "document" matches "document:*")
  optional uint64 at_height = 4; // Read at specific height (0 or omit = current)
  uint32 limit = 5; // Max results (0 = default limit)
  // Opaque pagination cursor from previous response. Server-managed; do not parse or modify.
  string page_token = 6;
  ReadConsistency consistency = 7; // Default: EVENTUAL (any replica)
}

message ListResourcesResponse {
  repeated string resources = 1; // Full resource IDs (e.g., ["document:1", "document:2"])
  uint64 block_height = 2;
  string next_page_token = 3; // Opaque cursor for next page; empty if no more results
}

message ListEntitiesRequest {
  OrganizationSlug organization = 1;
  string key_prefix = 2; // e.g., "user:", "_idx:email:", "session:"
  optional uint64 at_height = 3; // Read at specific height (0 or omit = current)
  bool include_expired = 4; // Include entities past expires_at (default: false)
  uint32 limit = 5; // Max results (0 = default limit)
  // Opaque pagination cursor from previous response. Server-managed; do not parse or modify.
  string page_token = 6;
  ReadConsistency consistency = 7; // Default: EVENTUAL (any replica)
  optional VaultSlug vault = 8; // Omit for organization-level entities
}

message ListEntitiesResponse {
  repeated Entity entities = 1;
  uint64 block_height = 2;
  string next_page_token = 3; // Opaque cursor for next page; empty if no more results
}

// =============================================================================
// Write Service
// =============================================================================

service WriteService {
  // Submit a transaction
  rpc Write(WriteRequest) returns (WriteResponse);

  // Submit multiple transactions in a batch
  rpc BatchWrite(BatchWriteRequest) returns (BatchWriteResponse);
}

// Note: actor is NOT specified by client. Server assigns Transaction.actor
// from authenticated context (session token, API key, or system identity).
message WriteRequest {
  OrganizationSlug organization = 1;
  optional VaultSlug vault = 2; // Required for relationships; omit for organization-level entities
  ClientId client_id = 3;
  bytes idempotency_key = 4; // 16-byte UUID for idempotent retries (server rejects reuse with different payload)
  repeated Operation operations = 5;
  bool include_tx_proof = 6; // Request block_header + tx_proof in response for verification
}

message WriteResponse {
  oneof result {
    WriteSuccess success = 1;
    WriteError error = 2;
  }
}

message WriteSuccess {
  TxId tx_id = 1;
  uint64 block_height = 2;
  // For client-side verification (both present or both absent):
  optional BlockHeader block_header = 3; // Contains tx_merkle_root for proof verification
  optional MerkleProof tx_proof = 4; // Proof tx is in block (verify against block_header.tx_merkle_root)
  uint64 assigned_sequence = 5; // Server-assigned sequence number for this write
}

// Detailed error for conditional write failures.
// Provides enough context for clients to retry with correct values.
message WriteError {
  WriteErrorCode code = 1;
  string key = 2; // Which key's condition failed (CAS errors)
  optional uint64 current_version = 3; // Actual version (for version mismatch)
  optional bytes current_value = 4; // Actual value (for value_equals mismatch, if small)
  string message = 5; // Human-readable error description

  // Idempotency recovery fields (populated for ALREADY_COMMITTED)
  optional TxId committed_tx_id = 6; // For ALREADY_COMMITTED: original tx_id
  optional uint64 committed_block_height = 7; // For ALREADY_COMMITTED: original block_height
  optional uint64 assigned_sequence = 8; // For ALREADY_COMMITTED: server-assigned sequence
}

enum WriteErrorCode {
  WRITE_ERROR_CODE_UNSPECIFIED = 0;
  WRITE_ERROR_CODE_KEY_EXISTS = 1; // not_exists condition failed: key already exists
  WRITE_ERROR_CODE_KEY_NOT_FOUND = 2; // version/value_equals condition: key doesn't exist
  WRITE_ERROR_CODE_VERSION_MISMATCH = 3; // version condition: block height differs
  WRITE_ERROR_CODE_VALUE_MISMATCH = 4; // value_equals condition: value differs

  // Idempotency errors
  WRITE_ERROR_CODE_ALREADY_COMMITTED = 5; // Duplicate: idempotency_key already committed (same payload)
  // Recovery: use committed_tx_id, committed_block_height, assigned_sequence
  WRITE_ERROR_CODE_IDEMPOTENCY_KEY_REUSED = 6; // Conflict: idempotency_key reused with different payload
  // Recovery: generate new idempotency_key and retry
}

// Error codes for read operations.
// Used in gRPC status details for structured error handling.
enum ReadErrorCode {
  READ_ERROR_CODE_UNSPECIFIED = 0;

  // Requested height is outside retention window (pruned from storage).
  // Recovery: Use a more recent height, or re-sync from current tip.
  // Pagination: If height becomes unavailable mid-pagination, restart
  // query at current tip with fresh page_token.
  READ_ERROR_CODE_HEIGHT_UNAVAILABLE = 1;
}

// Structured error details attached to gRPC `Status.details` for machine-readable
// error handling. SDK clients decode this to populate `SdkError` fields without
// parsing error message strings.
//
// Encoding: `prost::Message::encode_to_vec()` → `Status::with_details(bytes)`.
// Decoding: `ErrorDetails::decode(status.details())`.
//
// Backward-compatible: clients that don't parse details continue working
// unchanged — they still see the human-readable `Status.message`.
message ErrorDetails {
  // Machine-readable error code (numeric string, e.g., "3203").
  // Maps to `ErrorCode::as_u16()` from the types crate.
  string error_code = 1;
  // Whether the client should retry this operation.
  bool is_retryable = 2;
  // Suggested delay before retrying (milliseconds). Present only for
  // rate-limited or backpressure errors.
  optional int32 retry_after_ms = 3;
  // Structured key-value context (e.g., {"organization": "42", "field": "key"}).
  map<string, string> context = 4;
  // Human-readable recovery guidance (e.g., "Reduce request rate").
  optional string suggested_action = 5;
}

// Batch write with all-or-nothing atomicity.
//
// Semantics:
// - All writes are committed in a SINGLE block (shared block_height in response)
// - Writes are applied in ARRAY ORDER (writes[0] before writes[1], etc.)
// - If ANY write's condition fails (e.g., CAS mismatch), the ENTIRE batch fails
// - On failure, no writes are applied—the vault state is unchanged
//
// Idempotency: Uses BATCH-LEVEL client_id/idempotency_key (not per-write).
// The entire batch is the idempotency unit—retry with same (client_id, idempotency_key)
// returns the original result. Per-write values in operations[] are IGNORED.
//
// Use cases:
// - Multi-key transactions requiring atomic commit
// - Ordered operations where later writes depend on earlier writes' effects
message BatchWriteRequest {
  OrganizationSlug organization = 1;
  optional VaultSlug vault = 2; // All writes target same vault scope
  ClientId client_id = 3; // Batch-level idempotency (per-write client_id ignored)
  bytes idempotency_key = 4; // 16-byte UUID for idempotent retries (server rejects reuse with different payload)
  repeated BatchWriteOperation operations = 5; // Operations in this batch
  bool include_tx_proofs = 6; // Request block_header + tx_proofs in response for verification
}

// Logical grouping of operations within a BatchWriteRequest.
// Purpose: Allows expressing ordered operation groups within an atomic batch.
// Processing: Groups are processed in array order (operations[0], then operations[1], etc.)
//             All groups share the batch's organization, vault, client_id, and idempotency_key.
// Atomicity: The ENTIRE batch is atomic—if any operation fails, no changes are applied.
message BatchWriteOperation {
  repeated Operation operations = 1; // Operations in this group
}

// Response for batch write.
// All-or-nothing: either all writes succeed or none are applied.
message BatchWriteResponse {
  oneof result {
    BatchWriteSuccess success = 1;
    WriteError error = 2; // First failing write; no writes applied
  }
}

message BatchWriteSuccess {
  TxId tx_id = 1; // Single transaction ID for entire batch
  uint64 block_height = 2; // Block containing this transaction
  // For client-side verification (optional):
  optional BlockHeader block_header = 3; // Contains tx_merkle_root for proof verification
  optional MerkleProof tx_proof = 4; // Proof this tx is in block
  uint64 assigned_sequence = 5; // Server-assigned sequence number for this batch
}

// =============================================================================
// Admin Service
// =============================================================================

service AdminService {
  // ==========================================================================
  // Organization Management
  // ==========================================================================

  // Create a new organization. An OrganizationSlug (Snowflake ID) is generated
  // and returned. Internal sequential OrganizationId is never exposed.
  rpc CreateOrganization(CreateOrganizationRequest) returns (CreateOrganizationResponse);

  // Delete an organization (marks for garbage collection, fails if vaults exist)
  rpc DeleteOrganization(DeleteOrganizationRequest) returns (DeleteOrganizationResponse);

  // Get organization info including shard assignment.
  // Lookup by slug only — organization names are not unique.
  rpc GetOrganization(GetOrganizationRequest) returns (GetOrganizationResponse);

  // List all organizations (paginated)
  rpc ListOrganizations(ListOrganizationsRequest) returns (ListOrganizationsResponse);

  // ==========================================================================
  // Vault Management
  // ==========================================================================

  // Create a new vault
  rpc CreateVault(CreateVaultRequest) returns (CreateVaultResponse);

  // Delete a vault (marks for garbage collection)
  rpc DeleteVault(DeleteVaultRequest) returns (DeleteVaultResponse);

  // Get vault info
  rpc GetVault(GetVaultRequest) returns (GetVaultResponse);

  // List all vaults on this node
  rpc ListVaults(ListVaultsRequest) returns (ListVaultsResponse);

  // ==========================================================================
  // Cluster Membership
  // ==========================================================================

  // Request to join an existing cluster. Called by a new node contacting a peer.
  // The receiving node forwards to the leader, which adds the node as a learner,
  // waits for it to catch up, then promotes to voter.
  rpc JoinCluster(JoinClusterRequest) returns (JoinClusterResponse);

  // Gracefully leave the cluster. Node is removed from Raft membership.
  rpc LeaveCluster(LeaveClusterRequest) returns (LeaveClusterResponse);

  // Get current cluster membership information.
  rpc GetClusterInfo(GetClusterInfoRequest) returns (GetClusterInfoResponse);

  // Get node information for pre-bootstrap coordination.
  // Available even before cluster is formed. Used by nodes to discover
  // each other's Snowflake IDs and determine who should bootstrap.
  rpc GetNodeInfo(GetNodeInfoRequest) returns (GetNodeInfoResponse);

  // Transfer leadership to a specific node before shutdown or maintenance.
  // If target_node_id is 0, the leader picks the most caught-up follower.
  // Returns once the target has won the election or the timeout expires.
  rpc TransferLeadership(TransferLeadershipRequest) returns (TransferLeadershipResponse);

  // ==========================================================================
  // Maintenance Operations
  // ==========================================================================

  // Trigger snapshot
  rpc CreateSnapshot(CreateSnapshotRequest) returns (CreateSnapshotResponse);

  // Run integrity check
  rpc CheckIntegrity(CheckIntegrityRequest) returns (CheckIntegrityResponse);

  // Recover a diverged vault by replaying blocks from archive.
  // This clears the vault's state, replays transactions from block archive,
  // and verifies state roots match. Only works on diverged vaults unless force=true.
  rpc RecoverVault(RecoverVaultRequest) returns (RecoverVaultResponse);

  // Simulate vault divergence for testing.
  // Forces a vault into the Diverged state without actual state corruption.
  // Only available when the server is built with the "test-utils" feature.
  rpc SimulateDivergence(SimulateDivergenceRequest) returns (SimulateDivergenceResponse);

  // Force a garbage collection cycle for expired entities.
  // Useful for testing TTL behavior and operational debugging.
  // Only the leader can run GC; followers return an error.
  rpc ForceGc(ForceGcRequest) returns (ForceGcResponse);

  // Update runtime-reconfigurable parameters without server restart.
  // Supports rate limit thresholds, hot key detection, compaction intervals,
  // and validation limits. Non-reconfigurable parameters (listen address,
  // data directory, Raft topology) are rejected with INVALID_ARGUMENT.
  // Set dry_run=true to validate without applying changes.
  rpc UpdateConfig(UpdateConfigRequest) returns (UpdateConfigResponse);

  // Get the current runtime configuration.
  rpc GetConfig(GetConfigRequest) returns (GetConfigResponse);

  // ==========================================================================
  // Backup & Restore
  // ==========================================================================

  // Create a backup of the current shard state.
  // Triggers a consistent snapshot, compresses it, and writes to the configured
  // backup destination. Includes chain commitment for integrity verification.
  rpc CreateBackup(CreateBackupRequest) returns (CreateBackupResponse);

  // List available backups with metadata.
  rpc ListBackups(ListBackupsRequest) returns (ListBackupsResponse);

  // Restore from a backup. Stops the shard, restores state from backup,
  // and resumes. Requires explicit confirmation via the confirm field.
  rpc RestoreBackup(RestoreBackupRequest) returns (RestoreBackupResponse);
}

// -----------------------------------------------------------------------------
// Organization Messages
// -----------------------------------------------------------------------------

// Per-organization resource quota limits.
// Applied to new organizations; defaults from server config if not specified.
message OrganizationQuota {
  uint64 max_storage_bytes = 1; // Maximum cumulative storage bytes
  uint32 max_vaults = 2; // Maximum number of vaults
  uint32 max_write_ops_per_sec = 3; // Maximum write ops/sec
  uint32 max_read_ops_per_sec = 4; // Maximum read ops/sec
}

// Create a new organization. An OrganizationSlug (Snowflake ID) is generated
// by the leader and returned. The organization is assigned to the shard with
// lowest load, or to the specified shard.
message CreateOrganizationRequest {
  string name = 1; // Human-readable name (e.g., "acme_corp")
  optional ShardId shard_id = 2; // Target shard (auto-assigned if not specified)
  optional OrganizationQuota quota = 3; // Resource quota (server default if not specified)
}

message CreateOrganizationResponse {
  OrganizationSlug slug = 1;
  ShardId shard_id = 2; // Assigned shard
}

message DeleteOrganizationRequest {
  OrganizationSlug slug = 1;
}

message DeleteOrganizationResponse {
  google.protobuf.Timestamp deleted_at = 1;
}

// Get organization info by slug only.
// Organization names are not unique, so name-based lookup is not supported.
message GetOrganizationRequest {
  OrganizationSlug slug = 1;
}

// Organization info (routing metadata from _system)
// Note: leader_hint is computed dynamically from Raft state via GetSystemState
message GetOrganizationResponse {
  OrganizationSlug slug = 1;
  string name = 2;
  ShardId shard_id = 3;             // Which shard hosts this organization
  repeated NodeId member_nodes = 4; // Nodes in the shard
  OrganizationStatus status = 5;    // Lifecycle state
  uint64 config_version = 6;        // For cache invalidation
  google.protobuf.Timestamp created_at = 7;
}

enum OrganizationStatus {
  ORGANIZATION_STATUS_UNSPECIFIED = 0;
  ORGANIZATION_STATUS_ACTIVE = 1;    // Accepting requests
  ORGANIZATION_STATUS_MIGRATING = 2; // Being migrated to another shard
  ORGANIZATION_STATUS_SUSPENDED = 3; // Billing or policy suspension
  ORGANIZATION_STATUS_DELETING = 4;  // Deletion in progress
  ORGANIZATION_STATUS_DELETED = 5;   // Tombstone
}

message ListOrganizationsRequest {
  optional bytes page_token = 1;
  uint32 page_size = 2; // Default: 100, Max: 1000
}

message ListOrganizationsResponse {
  repeated GetOrganizationResponse organizations = 1;
  optional bytes next_page_token = 2; // Absent if no more pages
}

// -----------------------------------------------------------------------------
// Vault Messages
// -----------------------------------------------------------------------------

// Create a new vault. A VaultSlug (Snowflake ID) is generated
// and returned. Internal sequential VaultId is never exposed.
message CreateVaultRequest {
  OrganizationSlug organization = 1;
  uint32 replication_factor = 2;
  repeated NodeId initial_nodes = 3;
  optional BlockRetentionPolicy retention_policy = 4; // Default: FULL
}

// Block retention modes for storage/compliance trade-off.
// See DESIGN.md "Snapshot & Retention Policy" for details.
enum BlockRetentionMode {
  BLOCK_RETENTION_MODE_UNSPECIFIED = 0;
  // Keep all blocks with full transactions indefinitely.
  // Use case: SOC 2, HIPAA compliance requiring full audit trail.
  BLOCK_RETENTION_MODE_FULL = 1;
  // After snapshot, remove transaction bodies for old blocks (headers preserved).
  // Use case: High-volume workloads prioritizing storage efficiency.
  BLOCK_RETENTION_MODE_COMPACTED = 2;
}

message BlockRetentionPolicy {
  BlockRetentionMode mode = 1;
  // For COMPACTED mode: blocks newer than tip - retention_blocks keep full transactions.
  // Ignored for FULL mode. Default: 10000 blocks.
  uint64 retention_blocks = 2;
}

message CreateVaultResponse {
  VaultSlug vault = 1;
  BlockHeader genesis = 2;
}

message DeleteVaultRequest {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
}

message DeleteVaultResponse {
  google.protobuf.Timestamp deleted_at = 1;
}

message GetVaultRequest {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
}

message GetVaultResponse {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
  uint64 height = 3;
  Hash state_root = 4;
  repeated NodeId nodes = 5;
  NodeId leader = 6;
  VaultStatus status = 7;
  BlockRetentionPolicy retention_policy = 8;
}

enum VaultStatus {
  VAULT_STATUS_UNSPECIFIED = 0;
  VAULT_STATUS_ACTIVE = 1;
  VAULT_STATUS_READ_ONLY = 2;
  VAULT_STATUS_DELETED = 3;
}

message ListVaultsRequest {
  // Empty - lists all vaults on this node
}

message ListVaultsResponse {
  repeated GetVaultResponse vaults = 1;
}

message CreateSnapshotRequest {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
}

message CreateSnapshotResponse {
  uint64 block_height = 1;
  Hash state_root = 2;
  string snapshot_path = 3;
}

message CheckIntegrityRequest {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
  bool full_check = 3; // Replay from genesis vs quick check
}

message CheckIntegrityResponse {
  bool healthy = 1;
  repeated IntegrityIssue issues = 2;
}

message IntegrityIssue {
  uint64 block_height = 1;
  string issue_type = 2; // "chain_break", "state_divergence", etc.
  string description = 3;
}

// Recover a diverged vault by replaying blocks from archive.
message RecoverVaultRequest {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
  // Force recovery even if vault is healthy (for testing/maintenance).
  // Required for manual intervention after automatic recovery exhausted.
  bool force = 3;
}

message RecoverVaultResponse {
  bool success = 1;
  string message = 2; // Error details if !success
  // New vault health status after recovery attempt.
  VaultHealthProto health_status = 3;
  // Final block height after recovery.
  uint64 final_height = 4;
  // Final state root after recovery (should match expected).
  Hash final_state_root = 5;
}

// Request to simulate vault divergence for testing.
// This forces a vault into the Diverged state without actual corruption.
message SimulateDivergenceRequest {
  OrganizationSlug organization = 1;
  VaultSlug vault = 2;
  // Expected state root (fake value for simulation).
  Hash expected_state_root = 3;
  // Computed state root (fake value for simulation).
  Hash computed_state_root = 4;
  // Height at which "divergence" occurred.
  uint64 at_height = 5;
}

message SimulateDivergenceResponse {
  bool success = 1;
  string message = 2;
  // Vault health status after simulation (should be DIVERGED).
  VaultHealthProto health_status = 3;
}

// Force a garbage collection cycle for expired entities.
// If organization and vault are specified, only that vault is scanned.
// If omitted, all vaults are scanned (cluster-wide GC).
message ForceGcRequest {
  optional OrganizationSlug organization = 1;
  optional VaultSlug vault = 2;
}

message ForceGcResponse {
  bool success = 1;
  string message = 2;
  // Number of expired entities that were removed.
  uint64 expired_count = 3;
  // Number of vaults that were scanned.
  uint64 vaults_scanned = 4;
}

// Vault health status (mirrors internal VaultHealthStatus enum).
enum VaultHealthProto {
  VAULT_HEALTH_PROTO_UNSPECIFIED = 0;
  VAULT_HEALTH_PROTO_HEALTHY = 1;
  VAULT_HEALTH_PROTO_DIVERGED = 2;
  VAULT_HEALTH_PROTO_RECOVERING = 3;
}

// -----------------------------------------------------------------------------
// Runtime Configuration Messages
// -----------------------------------------------------------------------------

// Update runtime-reconfigurable configuration parameters.
// Only fields that are set will be updated; unset fields retain current values.
// Set dry_run=true to validate without applying.
message UpdateConfigRequest {
  // JSON-encoded RuntimeConfig (only reconfigurable fields).
  // Reconfigurable subset: rate_limit, hot_key, compaction, validation.
  string config_json = 1;
  // If true, validate the config without applying changes.
  bool dry_run = 2;
}

message UpdateConfigResponse {
  // Whether the update was applied (false for dry_run or validation failure).
  bool applied = 1;
  // Human-readable summary: fields changed, or validation error details.
  string message = 2;
  // JSON-encoded current RuntimeConfig after the update (or before, for dry_run).
  string current_config_json = 3;
  // List of field paths that were changed (e.g., ["rate_limit", "hot_key"]).
  repeated string changed_fields = 4;
}

// Get current runtime configuration.
message GetConfigRequest {}

message GetConfigResponse {
  // JSON-encoded current RuntimeConfig.
  string config_json = 1;
}

// -----------------------------------------------------------------------------
// Backup & Restore Messages
// -----------------------------------------------------------------------------

// Backup type indicator.
enum BackupType {
  // Full backup containing all database pages.
  BACKUP_TYPE_FULL = 0;
  // Incremental backup containing only pages changed since the base backup.
  BACKUP_TYPE_INCREMENTAL = 1;
}

// Create a consistent backup of shard state.
message CreateBackupRequest {
  // Optional tag for identifying this backup (e.g., "pre-migration").
  optional string tag = 1;
  // For incremental backup: ID of the base (full) backup.
  // When provided, only pages changed since the base are included.
  // Omit for a full backup.
  optional string base_backup_id = 2;
}

message CreateBackupResponse {
  // Unique backup identifier (timestamp-based).
  string backup_id = 1;
  // Shard height at backup time.
  uint64 shard_height = 2;
  // Path where the backup was written.
  string backup_path = 3;
  // Size of the backup in bytes.
  uint64 size_bytes = 4;
  // SHA-256 checksum of the backup file.
  Hash checksum = 5;
}

// List available backups.
message ListBackupsRequest {
  // Maximum number of backups to return (0 = all).
  uint32 limit = 1;
}

message ListBackupsResponse {
  repeated BackupInfo backups = 1;
}

// Metadata about an available backup.
message BackupInfo {
  // Unique backup identifier.
  string backup_id = 1;
  // Shard height at backup time.
  uint64 shard_height = 2;
  // Path where the backup is stored.
  string backup_path = 3;
  // Size in bytes.
  uint64 size_bytes = 4;
  // When the backup was created.
  google.protobuf.Timestamp created_at = 5;
  // SHA-256 checksum for integrity verification.
  Hash checksum = 6;
  // Chain commitment at backup time (for integrity verification at restore).
  Hash chain_commitment_hash = 7;
  // Snapshot format version.
  uint32 schema_version = 8;
  // Optional user-provided tag.
  string tag = 9;
  // Backup type (full or incremental).
  BackupType backup_type = 10;
  // For incremental backups, the ID of the base (full) backup.
  optional string base_backup_id = 11;
  // Number of pages in this backup.
  optional uint64 page_count = 12;
}

// Restore state from a backup. Requires explicit confirmation.
message RestoreBackupRequest {
  // Backup identifier to restore from.
  string backup_id = 1;
  // Must be true to proceed. Safety gate to prevent accidental restores.
  bool confirm = 2;
}

message RestoreBackupResponse {
  // Whether the restore succeeded.
  bool success = 1;
  // Human-readable result message.
  string message = 2;
  // Shard height after restore.
  uint64 restored_height = 3;
}

// -----------------------------------------------------------------------------
// Cluster Membership Messages
// -----------------------------------------------------------------------------

// Request to join an existing cluster.
// The node provides its ID and address so the leader can add it to Raft.
message JoinClusterRequest {
  uint64 node_id = 1; // Numeric node ID for Raft
  string address = 2; // gRPC address (e.g., "10.0.0.5:50051")
}

message JoinClusterResponse {
  bool success = 1;
  string message = 2; // Error details if !success
  uint64 leader_id = 3; // Current leader (for redirect if needed)
  string leader_address = 4; // Leader's gRPC address
}

// Request to gracefully leave the cluster.
message LeaveClusterRequest {
  uint64 node_id = 1; // Node requesting to leave
}

message LeaveClusterResponse {
  bool success = 1;
  string message = 2;
}

// Get current cluster membership.
message GetClusterInfoRequest {}

message GetClusterInfoResponse {
  repeated ClusterMember members = 1;
  uint64 leader_id = 2;
  uint64 term = 3; // Current Raft term
}

// Request for node identity (empty - no parameters needed).
message GetNodeInfoRequest {}

// Node identity for bootstrap coordination.
// Available before cluster formation to support coordinated bootstrap.
message GetNodeInfoResponse {
  // Node's Snowflake ID (auto-generated, persisted).
  uint64 node_id = 1;
  // Node's gRPC address (e.g., "192.168.1.10:50051").
  string address = 2;
  // True if node is already part of a cluster.
  bool is_cluster_member = 3;
  // Current Raft term (0 if not in cluster).
  uint64 term = 4;
}

// A member of the Raft cluster.
message ClusterMember {
  uint64 node_id = 1;
  string address = 2;
  ClusterMemberRole role = 3;
  bool is_leader = 4;
}

enum ClusterMemberRole {
  CLUSTER_MEMBER_ROLE_UNSPECIFIED = 0;
  CLUSTER_MEMBER_ROLE_VOTER = 1; // Full voting member
  CLUSTER_MEMBER_ROLE_LEARNER = 2; // Receiving logs but can't vote
}

// =============================================================================
// Events Service
// =============================================================================

// Unified audit event query and ingestion API.
//
// Events come from three sources:
// - Ledger apply-phase (deterministic, Raft-replicated): committed writes, vault/org lifecycle
// - Ledger handler-phase (node-local): denials, admin operations
// - External services (Engine/Control via IngestEvents): authorization decisions, management ops
//
// All events share the same EventEntry format and live in the same Events table.
// System events are accessible via SYSTEM_ORGANIZATION_SLUG (slug = 0).
service EventsService {
  // List events for an organization with filtering and pagination.
  rpc ListEvents(ListEventsRequest) returns (ListEventsResponse);

  // Get a single event by ID.
  rpc GetEvent(GetEventRequest) returns (GetEventResponse);

  // Count events matching a filter.
  rpc CountEvents(CountEventsRequest) returns (CountEventsResponse);

  // Ingest events from external services (Engine, Control).
  // Uses handler-phase semantics (node-local, no Raft).
  rpc IngestEvents(IngestEventsRequest) returns (IngestEventsResponse);
}

// Scope of an audit event.
enum EventScope {
  EVENT_SCOPE_UNSPECIFIED = 0;
  // Cluster-wide administrative events (org_id = 0).
  EVENT_SCOPE_SYSTEM = 1;
  // Per-organization tenant events.
  EVENT_SCOPE_ORGANIZATION = 2;
}

// Outcome of an audited operation.
enum EventOutcome {
  EVENT_OUTCOME_UNSPECIFIED = 0;
  // Operation completed successfully.
  EVENT_OUTCOME_SUCCESS = 1;
  // Operation failed with an error.
  EVENT_OUTCOME_FAILED = 2;
  // Operation was denied (rate limited, unauthorized, etc.).
  EVENT_OUTCOME_DENIED = 3;
}

// Emission path indicating the consistency model of an event.
enum EventEmissionPath {
  EMISSION_PATH_UNSPECIFIED = 0;
  // Deterministic, Raft-replicated — identical on all nodes.
  EMISSION_PATH_APPLY_PHASE = 1;
  // Node-local, best-effort — exists only on the handling node.
  EMISSION_PATH_HANDLER_PHASE = 2;
}

// Structured audit event record.
//
// Follows the canonical log line ("wide event") pattern — a single structured
// record with rich contextual fields. Queryable via ListEvents.
message EventEntry {
  // Unique event identifier (UUID, 16 bytes).
  bytes event_id = 1;
  // Originating service ("ledger", "engine", or "control").
  string source_service = 2;
  // Hierarchical dot-separated type (e.g., "ledger.vault.created").
  string event_type = 3;
  // Block timestamp (apply-phase) or wall clock (handler-phase).
  google.protobuf.Timestamp timestamp = 4;
  // System or organization scope.
  EventScope scope = 5;
  // What happened (snake_case action name, e.g., "vault_created").
  string action = 6;
  // Consistency model of this event.
  EventEmissionPath emission_path = 7;
  // Who performed the action (server-assigned actor).
  string principal = 8;
  // Owning organization (slug = 0 for system events).
  OrganizationSlug organization = 9;
  // Vault context (when applicable).
  optional VaultSlug vault = 10;
  // Success, failure, or denial.
  EventOutcome outcome = 11;
  // Error code (present when outcome = FAILED).
  optional string error_code = 12;
  // Error description (present when outcome = FAILED).
  optional string error_detail = 13;
  // Denial reason (present when outcome = DENIED).
  optional string denial_reason = 14;
  // Action-specific key-value context.
  map<string, string> details = 15;
  // Reference to blockchain block (for committed writes).
  optional uint64 block_height = 16;
  // Node that generated this event (present for handler-phase events).
  optional uint64 node_id = 17;
  // Distributed tracing correlation (W3C Trace Context).
  optional string trace_id = 18;
  // Business-level correlation for multi-step operations.
  optional string correlation_id = 19;
  // Number of operations (for write actions).
  optional uint32 operations_count = 20;
  // Unix timestamp for TTL expiry (0 = no expiry).
  uint64 expires_at = 21;
}

// Filter criteria for event queries.
message EventFilter {
  // Start of time range (inclusive). Omit for unbounded start.
  optional google.protobuf.Timestamp start_time = 1;
  // End of time range (exclusive). Omit for unbounded end.
  optional google.protobuf.Timestamp end_time = 2;
  // Filter by action names (snake_case). Empty = all actions.
  repeated string actions = 3;
  // Filter by event type prefix (e.g., "ledger.vault" matches "ledger.vault.created").
  // Case-sensitive starts_with matching. Empty = all types.
  optional string event_type_prefix = 4;
  // Filter by principal. Empty = all principals.
  optional string principal = 5;
  // Filter by outcome. UNSPECIFIED = all outcomes.
  EventOutcome outcome = 6;
  // Filter by emission path. UNSPECIFIED = all paths.
  EventEmissionPath emission_path = 7;
  // Filter by business correlation ID.
  optional string correlation_id = 8;
}

// List events for an organization with filtering and pagination.
message ListEventsRequest {
  // Organization to query (slug = 0 for system events).
  OrganizationSlug organization = 1;
  // Optional filter criteria.
  EventFilter filter = 2;
  // Max results per page (0 = default, max 1000).
  uint32 limit = 3;
  // Opaque pagination cursor from previous response.
  string page_token = 4;
}

message ListEventsResponse {
  // Matching events in chronological order.
  repeated EventEntry entries = 1;
  // Opaque cursor for next page; empty if no more results.
  string next_page_token = 2;
  // Estimated total count (may be approximate for large datasets).
  optional uint64 total_estimate = 3;
}

// Get a single event by ID.
message GetEventRequest {
  // Organization that owns the event.
  OrganizationSlug organization = 1;
  // Event identifier (UUID bytes).
  bytes event_id = 2;
}

message GetEventResponse {
  // The requested event.
  EventEntry entry = 1;
}

// Count events matching a filter.
message CountEventsRequest {
  // Organization to query (slug = 0 for system events).
  OrganizationSlug organization = 1;
  // Optional filter criteria.
  EventFilter filter = 2;
}

message CountEventsResponse {
  // Number of matching events.
  uint64 count = 1;
}

// A single event for external ingestion (from Engine or Control).
message IngestEventEntry {
  // Hierarchical dot-separated type (must start with source_service prefix).
  string event_type = 1;
  // Who performed the action.
  string principal = 2;
  // Outcome of the operation.
  EventOutcome outcome = 3;
  // Action-specific key-value context.
  map<string, string> details = 4;
  // Distributed tracing correlation.
  optional string trace_id = 5;
  // Business-level correlation ID.
  optional string correlation_id = 6;
  // Vault context (when applicable).
  optional VaultSlug vault = 7;
  // Event timestamp (defaults to server receive time if omitted).
  optional google.protobuf.Timestamp timestamp = 8;
  // Error code (when outcome = FAILED).
  optional string error_code = 9;
  // Error description (when outcome = FAILED).
  optional string error_detail = 10;
  // Denial reason (when outcome = DENIED).
  optional string denial_reason = 11;
}

// Ingest events from an external service.
message IngestEventsRequest {
  // Source service identifier (validated against allow-list).
  string source_service = 1;
  // Organization that owns these events.
  OrganizationSlug organization = 2;
  // Events to ingest (max batch size enforced by server config).
  repeated IngestEventEntry entries = 3;
}

// Reason an individual event was rejected during ingestion.
message RejectedEvent {
  // Zero-based index into the request's entries array.
  uint32 index = 1;
  // Human-readable rejection reason.
  string reason = 2;
}

message IngestEventsResponse {
  // Number of events accepted and written.
  uint32 accepted_count = 1;
  // Number of events rejected.
  uint32 rejected_count = 2;
  // Per-event rejection details.
  repeated RejectedEvent rejections = 3;
}

// =============================================================================
// Health Service
// =============================================================================

service HealthService {
  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);
}

message HealthCheckRequest {
  optional OrganizationSlug organization = 1; // Organization for vault health check
  optional VaultSlug vault = 2; // Omit to check node health
}

message HealthCheckResponse {
  HealthStatus status = 1;
  string message = 2;
  map<string, string> details = 3;
}

enum HealthStatus {
  HEALTH_STATUS_UNSPECIFIED = 0;
  HEALTH_STATUS_HEALTHY = 1;
  HEALTH_STATUS_DEGRADED = 2;
  HEALTH_STATUS_UNAVAILABLE = 3;
}

// =============================================================================
// System Discovery Service
// =============================================================================

service SystemDiscoveryService {
  // Get known peers (subset of _system state, lightweight)
  rpc GetPeers(GetPeersRequest) returns (GetPeersResponse);

  // Announce a new or updated peer to the cluster
  rpc AnnouncePeer(AnnouncePeerRequest) returns (AnnouncePeerResponse);

  // Get full system state (nodes + organization registry)
  rpc GetSystemState(GetSystemStateRequest) returns (GetSystemStateResponse);
}

message GetPeersRequest {
  uint32 max_peers = 1; // Limit response size (0 = no limit)
}

message GetPeersResponse {
  repeated PeerInfo peers = 1;
  uint64 system_version = 2; // For cache invalidation
}

message PeerInfo {
  NodeId node_id = 1;
  // IP addresses only (no port). IPv4 or IPv6, e.g., ["10.0.0.1", "fd00::1"].
  // Must be private/WireGuard IPs—public IPs rejected.
  // Connect via: addresses[i] + ":" + grpc_port
  repeated string addresses = 2;
  uint32 grpc_port = 3; // gRPC port (same for all addresses), typically 5000
  google.protobuf.Timestamp last_seen = 4;
}

message AnnouncePeerRequest {
  PeerInfo peer = 1;
}

message AnnouncePeerResponse {
  bool accepted = 1;
}

message GetSystemStateRequest {
  uint64 if_version_greater_than = 1; // Return empty if version <= this (cache optimization)
}

message GetSystemStateResponse {
  uint64 version = 1;
  repeated NodeInfo nodes = 2;
  repeated OrganizationRegistry organizations = 3; // Routing table: organization → shard
}

// Node role in the cluster (Raft membership type)
enum NodeRole {
  NODE_ROLE_UNSPECIFIED = 0;
  NODE_ROLE_VOTER = 1;   // Participates in Raft elections (max 5 per cluster)
  NODE_ROLE_LEARNER = 2; // Replicates data but doesn't vote (for scaling)
}

message NodeInfo {
  NodeId node_id = 1;
  // IP addresses only (no port). IPv4 or IPv6, e.g., ["10.0.0.1", "fd00::1"].
  // Must be private/WireGuard IPs—public IPs rejected.
  // Connect via: addresses[i] + ":" + grpc_port
  repeated string addresses = 2;
  uint32 grpc_port = 3; // gRPC port (same for all addresses), typically 5000
  NodeRole role = 4;    // Voter or Learner
  google.protobuf.Timestamp last_heartbeat = 5;
  google.protobuf.Timestamp joined_at = 6; // For voter election ordering
}

// Routing entry: organization → shard assignment
// Note: leader_hint is computed dynamically from Raft state, not stored here
message OrganizationRegistry {
  OrganizationSlug slug = 1;
  string name = 2;                // Human-readable organization name
  ShardId shard_id = 3;           // Which Raft group hosts this organization
  repeated NodeId members = 4;    // Nodes in the shard
  OrganizationStatus status = 5;  // Lifecycle state
  uint64 config_version = 6;      // For cache invalidation
  google.protobuf.Timestamp created_at = 7;
}

// =============================================================================
// Raft Internal Service (inter-node communication)
// =============================================================================

// Internal Raft RPC service for consensus protocol.
// Used for inter-node communication: vote, log replication, snapshots.
service RaftService {
  // Request vote from peer during leader election.
  rpc Vote(RaftVoteRequest) returns (RaftVoteResponse);

  // Replicate log entries to followers.
  rpc AppendEntries(RaftAppendEntriesRequest) returns (RaftAppendEntriesResponse);

  // Install snapshot on a follower that is too far behind.
  rpc InstallSnapshot(RaftInstallSnapshotRequest) returns (RaftInstallSnapshotResponse);

  // Trigger an immediate leader election on this node.
  // Called by the current leader during leadership transfer.
  // This is an internal RPC — not exposed to external clients.
  rpc TriggerElection(TriggerElectionRequest) returns (TriggerElectionResponse);
}

// Raft vote (term + node_id + committed flag).
message RaftVote {
  uint64 term = 1;
  uint64 node_id = 2;
  bool committed = 3;
}

// Raft log entry identifier.
message RaftLogId {
  uint64 term = 1;
  uint64 index = 2;
}

// Vote request during leader election.
message RaftVoteRequest {
  RaftVote vote = 1;
  optional RaftLogId last_log_id = 2;
  // Shard ID for multi-shard routing (defaults to system shard 0).
  optional uint64 shard_id = 3;
}

// Vote response.
message RaftVoteResponse {
  RaftVote vote = 1;
  bool vote_granted = 2;
  optional RaftLogId last_log_id = 3;
}

// Log replication request.
message RaftAppendEntriesRequest {
  RaftVote vote = 1;
  optional RaftLogId prev_log_id = 2;
  repeated bytes entries = 3; // Serialized log entries
  optional RaftLogId leader_commit = 4;
  // Shard ID for multi-shard routing (defaults to system shard 0).
  optional uint64 shard_id = 5;
}

// Log replication response.
message RaftAppendEntriesResponse {
  RaftVote vote = 1;
  bool success = 2;
  bool conflict = 3;
}

// Snapshot installation request.
message RaftInstallSnapshotRequest {
  RaftVote vote = 1;
  RaftSnapshotMeta meta = 2;
  uint64 offset = 3;
  bytes data = 4;
  bool done = 5;
  // Shard ID for multi-shard routing (defaults to system shard 0).
  optional uint64 shard_id = 6;
}

// Snapshot installation response.
message RaftInstallSnapshotResponse {
  RaftVote vote = 1;
}

// Snapshot metadata.
message RaftSnapshotMeta {
  optional RaftLogId last_log_id = 1;
  RaftMembership last_membership = 2;
  string snapshot_id = 3;
}

// Raft cluster membership configuration.
message RaftMembership {
  repeated RaftMembershipConfig configs = 1;
}

// Single membership configuration (joint consensus may have multiple).
message RaftMembershipConfig {
  // Map of node_id -> address
  map<uint64, string> members = 1;
}

// ==========================================================================
// Leader Transfer
// ==========================================================================

message TransferLeadershipRequest {
  // Target node ID. If 0, the leader picks the best candidate.
  uint64 target_node_id = 1;
  // Maximum time to wait for the transfer to complete (milliseconds).
  // Default: 10000 (10 seconds). Capped at 60000 (60 seconds).
  uint32 timeout_ms = 2;
}

message TransferLeadershipResponse {
  bool success = 1;
  // Node ID that became the new leader (0 if transfer failed).
  uint64 new_leader_id = 2;
  string message = 3;
}

message TriggerElectionRequest {
  // Term the current leader is in. Target rejects if stale.
  uint64 leader_term = 1;
  // Node ID of the leader requesting the transfer.
  uint64 leader_id = 2;
}

message TriggerElectionResponse {
  bool accepted = 1;
  string message = 2;
}
