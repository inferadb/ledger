syntax = "proto3";

package ledger.v1;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/inferadb/ledger/gen/go/ledger/v1;ledgerv1";

// =============================================================================
// Core Types
// =============================================================================

// 256-bit hash (SHA-256)
message Hash {
  bytes value = 1; // 32 bytes
}

// Unique namespace identifier (one per organization)
// Sequential int64 assigned by Ledger leader from "_meta:seq:namespace"
// Special case: namespace_id = 0 is reserved for _system
message NamespaceId {
  int64 id = 1;
}

// Unique vault identifier (relationship store within a namespace)
// Sequential int64 assigned by Ledger leader from "_meta:seq:vault"
message VaultId {
  int64 id = 1;
}

// Unique shard identifier (Raft group hosting multiple namespaces)
message ShardId {
  uint32 id = 1;
}

// Unique node identifier
message NodeId {
  string id = 1;
}

// Unique user identifier (global, stored in _system namespace)
// Sequential int64 assigned by Ledger leader (see ID Generation Strategy in DESIGN.md)
message UserId {
  int64 id = 1;
}

// User record (stored in _system namespace as Entity with key "user:{id}")
// Users can have multiple email addresses via separate UserEmail entities.
// Namespace access is derived from membership records (member:{id} in each org namespace).
// ID assigned by Ledger leader from sequence counter "_meta:seq:user"
message User {
  UserId id = 1;
  string name = 2; // Display name (1-200 characters)
  string password_hash = 3; // Argon2id PHC string format (empty for passkey-only users)
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
  google.protobuf.Timestamp tos_accepted_at = 6; // When Terms of Service was accepted
  google.protobuf.Timestamp deleted_at = 7; // Soft-delete timestamp (null if active)
  bool disabled = 8; // Admin-disabled flag
  int64 primary_email_id = 9; // References UserEmail.id (single source of truth)
}

// User email address (stored in _system namespace as Entity with key "user_email:{id}")
// Each user can have multiple emails; primary is referenced by User.primary_email_id.
// Constraint: Primary email cannot be deleted (must reassign primary first).
// Global email uniqueness is enforced via index: "_idx:email:{email}" → email_id
// ID assigned by Ledger leader from sequence counter "_meta:seq:user_email"
message UserEmail {
  int64 id = 1; // Sequential ID (Ledger-assigned)
  UserId user_id = 2; // Owning user
  string email = 3; // Normalized to lowercase (max 320 chars per RFC 5321)
  google.protobuf.Timestamp verified_at = 4; // When verified (null if unverified)
  google.protobuf.Timestamp created_at = 5;
}

// Email verification token (stored in _system namespace with TTL)
// Key: "email_verify:{id}", Index: "_idx:email_verify:token:{token}" → token_id
// Tokens expire after 24 hours via Ledger's TTL mechanism.
// ID assigned by Ledger leader from sequence counter "_meta:seq:email_verify"
message EmailVerificationToken {
  int64 id = 1; // Sequential ID (Ledger-assigned)
  int64 user_email_id = 2; // Email being verified
  string token = 3; // 64-char hex string (32 random bytes)
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp expires_at = 5; // For application-level validation
  google.protobuf.Timestamp used_at = 6; // When token was consumed (null if unused)
}

// Unique client identifier (for idempotency)
message ClientId {
  string id = 1; // Opaque string (max 256 chars, typically API key ID)
}

// Unique transaction identifier
message TxId {
  bytes id = 1; // UUID as 16 bytes
}

// =============================================================================
// Block & Transaction Types
// =============================================================================

message BlockHeader {
  uint64 height = 1;
  NamespaceId namespace_id = 2; // Owning namespace (organization)
  VaultId vault_id = 3; // Vault within namespace
  Hash previous_hash = 4;
  Hash tx_merkle_root = 5;
  Hash state_root = 6;
  google.protobuf.Timestamp timestamp = 7;
  NodeId leader_id = 8;
  uint64 term = 9;
  uint64 committed_index = 10;
}

message Block {
  BlockHeader header = 1;
  repeated Transaction transactions = 2;
}

// Lightweight block notification for streaming (excludes transaction bodies)
message BlockAnnouncement {
  NamespaceId namespace_id = 1; // Owning namespace
  VaultId vault_id = 2; // Vault within namespace
  uint64 height = 3;
  Hash block_hash = 4;
  Hash state_root = 5;
  google.protobuf.Timestamp timestamp = 6;
}

message Transaction {
  TxId id = 1;
  ClientId client_id = 2;
  uint64 sequence = 3;
  repeated Operation operations = 4;
  google.protobuf.Timestamp timestamp = 5;
  // Actor identity, ALWAYS server-assigned from authenticated context.
  // Clients cannot specify this - derived from auth:
  //   - Session token → "user:{user_id}"
  //   - API key → "client:{client_id}"
  //   - Internal operation → "system:{component}" (e.g., "system:gc")
  // Format: {type}:{id}, max 128 characters.
  string actor = 6;
}

message Operation {
  oneof op {
    CreateRelationship create_relationship = 1;
    DeleteRelationship delete_relationship = 2;
    SetEntity set_entity = 3;
    DeleteEntity delete_entity = 4;
    ExpireEntity expire_entity = 5; // GC-initiated removal (distinct from user delete)
  }
}

message CreateRelationship {
  string resource = 1; // Format: "type:id" (max 512 chars total)
  string relation = 2; // Relation name (max 64 chars, e.g., "viewer", "editor")
  string subject = 3; // Format: "type:id" or "type:id#relation" (max 512 chars)
}

message DeleteRelationship {
  string resource = 1; // Format: "type:id" (max 512 chars total)
  string relation = 2; // Relation name (max 64 chars)
  string subject = 3; // Format: "type:id" or "type:id#relation" (max 512 chars)
}

message SetEntity {
  string key = 1; // Entity key (max 1024 bytes, UTF-8)
  bytes value = 2; // Entity value (max 1MB)
  optional uint64 expires_at = 3; // Unix epoch seconds; 0 or omit = never expires
  optional SetCondition condition = 4; // Optional conditional write (CAS)
}

// Condition for compare-and-set writes (used for coordination primitives)
message SetCondition {
  oneof condition {
    bool not_exists = 1; // Only set if key doesn't exist
    uint64 version = 2; // Only set if key was last modified at this block height
    bytes value_equals = 3; // Only set if current value matches exactly
    bool must_exists = 4; // Only set if key already exists (for safe updates)
  }
}

message DeleteEntity {
  string key = 1; // Entity key (max 1024 bytes, UTF-8)
}

// GC-initiated entity removal (distinct from user deletion for audit trail)
message ExpireEntity {
  string key = 1; // Entity key (max 1024 bytes, UTF-8)
  uint64 expired_at = 2; // When the entity's TTL was reached (Unix epoch seconds)
}

// Relationship tuple (used in query results)
message Relationship {
  string resource = 1; // Format: "type:id" (max 512 chars)
  string relation = 2; // Relation name (max 64 chars)
  string subject = 3; // Format: "type:id" or "type:id#relation" (max 512 chars)
}

// Entity (used in query results)
message Entity {
  string key = 1; // Entity key (max 1024 bytes, UTF-8)
  bytes value = 2; // Entity value (max 1MB)
  optional uint64 expires_at = 3; // Unix epoch seconds; 0 = never expires
  uint64 version = 4; // Block height when last modified (for conditional writes)
}

// =============================================================================
// Merkle Proof Types
// =============================================================================

enum Direction {
  DIRECTION_UNSPECIFIED = 0;
  DIRECTION_LEFT = 1;
  DIRECTION_RIGHT = 2;
}

// Read consistency levels for read operations.
// Trade-off between consistency and performance/availability.
enum ReadConsistency {
  READ_CONSISTENCY_UNSPECIFIED = 0; // Server default (typically EVENTUAL)
  READ_CONSISTENCY_EVENTUAL = 1; // Read from any replica (fastest, may be stale)
  READ_CONSISTENCY_LINEARIZABLE = 2; // Read from leader (strong consistency, higher latency)
}

// Merkle inclusion proof for transaction in block.
// Verification: recompute root from leaf_hash up through siblings.
// The leaf_hash is SHA-256(canonical_tx_encoding) - see DESIGN.md "Transaction Hash".
message MerkleProof {
  Hash leaf_hash = 1; // SHA-256 of transaction (not included separately)
  repeated MerkleSibling siblings = 2; // Siblings from leaf to root (bottom-up order)
}

message MerkleSibling {
  Hash hash = 1;
  Direction direction = 2; // Where sibling sits: LEFT means hash(sibling || current)
}

// Chain proof linking a trusted height to a response height.
// Used to verify that block at response_height descends from trusted_height.
//
// Ordering: headers[0].height == trusted_height + 1, ascending to response_height.
// The trusted header itself is NOT included (client already has it).
// Verification: chain previous_hash links and verify final header matches response.
//
// Example: trusted_height=100, response_height=103
//   headers = [BlockHeader(101), BlockHeader(102), BlockHeader(103)]
//   Verify: headers[0].previous_hash == sha256(trusted_header)
//           headers[1].previous_hash == sha256(headers[0])
//           headers[2].previous_hash == sha256(headers[1])
message ChainProof {
  repeated BlockHeader headers = 1; // Ascending height order, excludes trusted header
}

// State proof for entity existence verification.
// Unlike transaction proofs (O(log n) Merkle path), state proofs require
// bucket contents because state uses bucket-based hashing for O(1) writes.
message StateProof {
  bytes key = 1; // Entity key
  bytes value = 2; // Entity value
  uint64 expires_at = 3; // TTL (0 = never)
  uint64 version = 4; // Block height when last modified
  uint32 bucket_id = 5; // Bucket assignment (seahash(key) % 256)
  Hash bucket_root = 6; // Computed bucket root
  repeated Hash other_bucket_roots = 7; // 255 other bucket roots (index skips bucket_id)
  uint64 block_height = 8; // Block height this proof is valid for
  Hash state_root = 9; // Expected state_root (for verification)
}

// =============================================================================
// Read Service
// =============================================================================

service ReadService {
  // Read a value from the state tree (unverified, fastest)
  rpc Read(ReadRequest) returns (ReadResponse);

  // Read with merkle proof for client-side verification.
  // Supports both current and historical reads via optional at_height.
  // Use include_chain_proof=true to verify against a trusted checkpoint.
  rpc VerifiedRead(VerifiedReadRequest) returns (VerifiedReadResponse);

  // Read state at a specific block height with proof.
  // Similar to VerifiedRead with at_height, but at_height is required.
  // Supports chain proofs for verification against trusted checkpoints.
  rpc HistoricalRead(HistoricalReadRequest) returns (HistoricalReadResponse);

  // Stream block announcements as they're committed (lightweight notifications)
  rpc WatchBlocks(WatchBlocksRequest) returns (stream BlockAnnouncement);

  // Get block by height
  rpc GetBlock(GetBlockRequest) returns (GetBlockResponse);

  // Get multiple blocks for sync/catchup (max 1000 blocks per request)
  rpc GetBlockRange(GetBlockRangeRequest) returns (GetBlockRangeResponse);

  // Get current chain tip
  rpc GetTip(GetTipRequest) returns (GetTipResponse);

  // Get client's last committed sequence (for recovery after client restart)
  rpc GetClientState(GetClientStateRequest) returns (GetClientStateResponse);

  // Query relationships with optional filters (uses dual indexes)
  rpc ListRelationships(ListRelationshipsRequest) returns (ListRelationshipsResponse);

  // List distinct resources matching a type prefix
  rpc ListResources(ListResourcesRequest) returns (ListResourcesResponse);

  // List entities matching a key prefix (for Control data queries)
  rpc ListEntities(ListEntitiesRequest) returns (ListEntitiesResponse);
}

message ReadRequest {
  NamespaceId namespace_id = 1;
  optional VaultId vault_id = 2; // Omit for namespace-level entity reads
  string key = 3;
  ReadConsistency consistency = 4; // Default: EVENTUAL (any replica)
}

message ReadResponse {
  optional bytes value = 1;
  uint64 block_height = 2;
}

// Verified read: retrieve state with cryptographic proofs for client-side verification.
// Always returns: block_header + merkle_proof (required for verification).
// Use case: Clients that verify state locally, don't trust the server.
//
// For historical reads WITHOUT proofs (audits, debugging), use HistoricalRead
// with include_proof=false to avoid proof generation overhead.
message VerifiedReadRequest {
  NamespaceId namespace_id = 1;
  optional VaultId vault_id = 2; // Omit for namespace-level entity reads
  string key = 3;
  optional uint64 at_height = 4; // Read at specific height (0 or omit = current)
  bool include_chain_proof = 5; // Also include chain proof to trusted_height
  optional uint64 trusted_height = 6; // Chain proof starts from this checkpoint
}

message VerifiedReadResponse {
  optional bytes value = 1;
  uint64 block_height = 2;
  BlockHeader block_header = 3;
  MerkleProof merkle_proof = 4;
  optional ChainProof chain_proof = 5;
}

// Historical read: retrieve state at a specific past block height.
// Use case: Audits, compliance queries, debugging past state.
// Performance: Requires snapshot reconstruction (5-20ms hot, 100ms-10s cold).
//
// For verified historical reads with proofs, prefer VerifiedRead(at_height) which
// is optimized for the verification use case. HistoricalRead is for unverified
// archival queries where proof generation would add unnecessary overhead.
message HistoricalReadRequest {
  NamespaceId namespace_id = 1;
  optional VaultId vault_id = 2; // Omit for namespace-level entity reads
  string key = 3;
  uint64 at_height = 4; // Required: block height to read from
  bool include_proof = 5; // Include block_header + merkle_proof (default: false)
  bool include_chain_proof = 6; // Also include chain proof (requires include_proof=true)
  optional uint64 trusted_height = 7; // Chain proof starts from this checkpoint
}

message HistoricalReadResponse {
  optional bytes value = 1; // None if key didn't exist at at_height
  uint64 block_height = 2; // Echoes at_height for confirmation
  // Proofs (present only if include_proof=true):
  optional BlockHeader block_header = 3;
  optional MerkleProof merkle_proof = 4;
  optional ChainProof chain_proof = 5; // Present if include_chain_proof was true
}

message WatchBlocksRequest {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
  // First block height to stream. Must be >= 1 (0 is rejected with INVALID_ARGUMENT).
  //
  // Behavior:
  // - If start_height <= current tip: replays committed blocks first, then streams new
  // - If start_height > current tip: waits for that block, then streams
  //
  // Typical usage:
  //   tip = GetTip()
  //   stream = WatchBlocks(start_height = tip.height + 1)
  uint64 start_height = 3;
}

message GetBlockRequest {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
  uint64 height = 3;
}

message GetBlockResponse {
  Block block = 1;
}

// Fetch multiple blocks for sync/catchup.
// Use case: Client reconnecting after downtime needs to catch up.
message GetBlockRangeRequest {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
  uint64 start_height = 3; // First block to return (inclusive)
  uint64 end_height = 4; // Last block to return (inclusive), max range: 1000 blocks
}

message GetBlockRangeResponse {
  repeated Block blocks = 1; // Ordered by height ascending
  uint64 current_tip = 2; // Current chain tip (for client to know if more syncing needed)
}

message GetTipRequest {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
}

message GetTipResponse {
  uint64 height = 1;
  Hash block_hash = 2;
  Hash state_root = 3;
}

message GetClientStateRequest {
  NamespaceId namespace_id = 1;
  optional VaultId vault_id = 2; // Omit for namespace-level entity writes
  ClientId client_id = 3;
}

message GetClientStateResponse {
  uint64 last_committed_sequence = 1;
}

message ListRelationshipsRequest {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
  optional string resource = 3; // Filter by resource (exact match)
  optional string relation = 4; // Filter by relation (exact match)
  optional string subject = 5; // Filter by subject (exact match)
  optional uint64 at_height = 6; // Read at specific height (0 or omit = current)
  uint32 limit = 7; // Max results (0 = default limit)
  // Opaque pagination cursor from previous response. Server-managed; do not parse or modify.
  // Encodes position and query context for consistent pagination across requests.
  string page_token = 8;
  ReadConsistency consistency = 9; // Default: EVENTUAL (any replica)
}

message ListRelationshipsResponse {
  repeated Relationship relationships = 1;
  uint64 block_height = 2;
  string next_page_token = 3; // Opaque cursor for next page; empty if no more results
}

message ListResourcesRequest {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
  string resource_type = 3; // Type prefix (e.g., "document" matches "document:*")
  optional uint64 at_height = 4; // Read at specific height (0 or omit = current)
  uint32 limit = 5; // Max results (0 = default limit)
  // Opaque pagination cursor from previous response. Server-managed; do not parse or modify.
  string page_token = 6;
  ReadConsistency consistency = 7; // Default: EVENTUAL (any replica)
}

message ListResourcesResponse {
  repeated string resources = 1; // Full resource IDs (e.g., ["document:1", "document:2"])
  uint64 block_height = 2;
  string next_page_token = 3; // Opaque cursor for next page; empty if no more results
}

message ListEntitiesRequest {
  NamespaceId namespace_id = 1;
  string key_prefix = 2; // e.g., "user:", "_idx:email:", "session:"
  optional uint64 at_height = 3; // Read at specific height (0 or omit = current)
  bool include_expired = 4; // Include entities past expires_at (default: false)
  uint32 limit = 5; // Max results (0 = default limit)
  // Opaque pagination cursor from previous response. Server-managed; do not parse or modify.
  string page_token = 6;
  ReadConsistency consistency = 7; // Default: EVENTUAL (any replica)
}

message ListEntitiesResponse {
  repeated Entity entities = 1;
  uint64 block_height = 2;
  string next_page_token = 3; // Opaque cursor for next page; empty if no more results
}

// =============================================================================
// Write Service
// =============================================================================

service WriteService {
  // Submit a transaction
  rpc Write(WriteRequest) returns (WriteResponse);

  // Submit multiple transactions in a batch
  rpc BatchWrite(BatchWriteRequest) returns (BatchWriteResponse);
}

// Note: actor is NOT specified by client. Server assigns Transaction.actor
// from authenticated context (session token, API key, or system identity).
message WriteRequest {
  NamespaceId namespace_id = 1;
  optional VaultId vault_id = 2; // Required for relationships; omit for namespace-level entities
  ClientId client_id = 3;
  uint64 sequence = 4;
  repeated Operation operations = 5;
  bool include_tx_proof = 6; // Request block_header + tx_proof in response for verification
}

message WriteResponse {
  oneof result {
    WriteSuccess success = 1;
    WriteError error = 2;
  }
}

message WriteSuccess {
  TxId tx_id = 1;
  uint64 block_height = 2;
  // For client-side verification (both present or both absent):
  optional BlockHeader block_header = 3; // Contains tx_merkle_root for proof verification
  optional MerkleProof tx_proof = 4; // Proof tx is in block (verify against block_header.tx_merkle_root)
}

// Detailed error for conditional write failures.
// Provides enough context for clients to retry with correct values.
message WriteError {
  WriteErrorCode code = 1;
  string key = 2; // Which key's condition failed (CAS errors)
  optional uint64 current_version = 3; // Actual version (for version mismatch)
  optional bytes current_value = 4; // Actual value (for value_equals mismatch, if small)
  string message = 5; // Human-readable error description

  // Sequence error recovery fields (populated for ALREADY_COMMITTED and SEQUENCE_GAP)
  optional TxId committed_tx_id = 6; // For ALREADY_COMMITTED: original tx_id
  optional uint64 committed_block_height = 7; // For ALREADY_COMMITTED: original block_height
  optional uint64 last_committed_sequence = 8; // For SEQUENCE_GAP: server's last seen sequence
}

enum WriteErrorCode {
  WRITE_ERROR_CODE_UNSPECIFIED = 0;
  WRITE_ERROR_CODE_KEY_EXISTS = 1; // not_exists condition failed: key already exists
  WRITE_ERROR_CODE_KEY_NOT_FOUND = 2; // version/value_equals condition: key doesn't exist
  WRITE_ERROR_CODE_VERSION_MISMATCH = 3; // version condition: block height differs
  WRITE_ERROR_CODE_VALUE_MISMATCH = 4; // value_equals condition: value differs

  // Sequence errors (split for client recovery)
  WRITE_ERROR_CODE_ALREADY_COMMITTED = 5; // Duplicate: sequence already committed
  // Recovery: use committed_tx_id, committed_block_height
  WRITE_ERROR_CODE_SEQUENCE_GAP = 6; // Gap: sequence > last_committed + 1
  // Recovery: use last_committed_sequence, call GetClientState
}

// Error codes for read operations.
// Used in gRPC status details for structured error handling.
enum ReadErrorCode {
  READ_ERROR_CODE_UNSPECIFIED = 0;

  // Requested height is outside retention window (pruned from storage).
  // Recovery: Use a more recent height, or re-sync from current tip.
  // Pagination: If height becomes unavailable mid-pagination, restart
  // query at current tip with fresh page_token.
  READ_ERROR_CODE_HEIGHT_UNAVAILABLE = 1;
}

// Batch write with all-or-nothing atomicity.
//
// Semantics:
// - All writes are committed in a SINGLE block (shared block_height in response)
// - Writes are applied in ARRAY ORDER (writes[0] before writes[1], etc.)
// - If ANY write's condition fails (e.g., CAS mismatch), the ENTIRE batch fails
// - On failure, no writes are applied—the vault state is unchanged
//
// Idempotency: Uses BATCH-LEVEL client_id/sequence (not per-write).
// The entire batch is the idempotency unit—retry with same (client_id, sequence)
// returns the original result. Per-write client_id/sequence in writes[] are IGNORED.
//
// Use cases:
// - Multi-key transactions requiring atomic commit
// - Ordered operations where later writes depend on earlier writes' effects
message BatchWriteRequest {
  NamespaceId namespace_id = 1;
  optional VaultId vault_id = 2; // All writes must target same scope
  ClientId client_id = 3; // Batch-level idempotency (per-write client_id ignored)
  uint64 sequence = 4; // Batch-level sequence (per-write sequence ignored)
  repeated BatchWriteOperation operations = 5; // Operations in this batch
  bool include_tx_proofs = 6; // Request block_header + tx_proofs in response for verification
}

// Logical grouping of operations within a BatchWriteRequest.
// Purpose: Allows expressing ordered operation groups within an atomic batch.
// Processing: Groups are processed in array order (operations[0], then operations[1], etc.)
//             All groups share the batch's namespace_id, vault_id, client_id, and sequence.
// Atomicity: The ENTIRE batch is atomic—if any operation fails, no changes are applied.
message BatchWriteOperation {
  repeated Operation operations = 1; // Operations in this group
}

// Response for batch write.
// All-or-nothing: either all writes succeed or none are applied.
message BatchWriteResponse {
  oneof result {
    BatchWriteSuccess success = 1;
    WriteError error = 2; // First failing write; no writes applied
  }
}

message BatchWriteSuccess {
  TxId tx_id = 1; // Single transaction ID for entire batch
  uint64 block_height = 2; // Block containing this transaction
  // For client-side verification (optional):
  optional BlockHeader block_header = 3; // Contains tx_merkle_root for proof verification
  optional MerkleProof tx_proof = 4; // Proof this tx is in block
}

// =============================================================================
// Admin Service
// =============================================================================

service AdminService {
  // ==========================================================================
  // Namespace Management
  // ==========================================================================

  // Create a new namespace. NamespaceId is leader-assigned from _meta:seq:namespace.
  rpc CreateNamespace(CreateNamespaceRequest) returns (CreateNamespaceResponse);

  // Delete a namespace (marks for garbage collection, fails if vaults exist)
  rpc DeleteNamespace(DeleteNamespaceRequest) returns (DeleteNamespaceResponse);

  // Get namespace info including shard assignment
  rpc GetNamespace(GetNamespaceRequest) returns (GetNamespaceResponse);

  // List all namespaces (paginated)
  rpc ListNamespaces(ListNamespacesRequest) returns (ListNamespacesResponse);

  // ==========================================================================
  // Vault Management
  // ==========================================================================

  // Create a new vault
  rpc CreateVault(CreateVaultRequest) returns (CreateVaultResponse);

  // Delete a vault (marks for garbage collection)
  rpc DeleteVault(DeleteVaultRequest) returns (DeleteVaultResponse);

  // Get vault info
  rpc GetVault(GetVaultRequest) returns (GetVaultResponse);

  // List all vaults on this node
  rpc ListVaults(ListVaultsRequest) returns (ListVaultsResponse);

  // ==========================================================================
  // Cluster Membership
  // ==========================================================================

  // Request to join an existing cluster. Called by a new node contacting a peer.
  // The receiving node forwards to the leader, which adds the node as a learner,
  // waits for it to catch up, then promotes to voter.
  rpc JoinCluster(JoinClusterRequest) returns (JoinClusterResponse);

  // Gracefully leave the cluster. Node is removed from Raft membership.
  rpc LeaveCluster(LeaveClusterRequest) returns (LeaveClusterResponse);

  // Get current cluster membership information.
  rpc GetClusterInfo(GetClusterInfoRequest) returns (GetClusterInfoResponse);

  // ==========================================================================
  // Maintenance Operations
  // ==========================================================================

  // Trigger snapshot
  rpc CreateSnapshot(CreateSnapshotRequest) returns (CreateSnapshotResponse);

  // Run integrity check
  rpc CheckIntegrity(CheckIntegrityRequest) returns (CheckIntegrityResponse);

  // Recover a diverged vault by replaying blocks from archive.
  // This clears the vault's state, replays transactions from block archive,
  // and verifies state roots match. Only works on diverged vaults unless force=true.
  rpc RecoverVault(RecoverVaultRequest) returns (RecoverVaultResponse);

  // Simulate vault divergence for testing.
  // Forces a vault into the Diverged state without actual state corruption.
  // Only available when the server is built with the "test-utils" feature.
  rpc SimulateDivergence(SimulateDivergenceRequest) returns (SimulateDivergenceResponse);

  // Force a garbage collection cycle for expired entities.
  // Useful for testing TTL behavior and operational debugging.
  // Only the leader can run GC; followers return an error.
  rpc ForceGc(ForceGcRequest) returns (ForceGcResponse);
}

// -----------------------------------------------------------------------------
// Namespace Messages
// -----------------------------------------------------------------------------

// Create a new namespace. NamespaceId is leader-assigned from _meta:seq:namespace.
// The namespace is assigned to the shard with lowest load.
message CreateNamespaceRequest {
  string name = 1; // Human-readable name (e.g., "acme_corp")
}

message CreateNamespaceResponse {
  NamespaceId namespace_id = 1;
  ShardId shard_id = 2; // Assigned shard
}

message DeleteNamespaceRequest {
  NamespaceId namespace_id = 1;
}

message DeleteNamespaceResponse {
  google.protobuf.Timestamp deleted_at = 1;
}

message GetNamespaceRequest {
  // Lookup by ID or name (exactly one must be set)
  oneof lookup {
    NamespaceId namespace_id = 1;
    string name = 2;
  }
}

// Namespace registry info (routing metadata from _system)
message GetNamespaceResponse {
  NamespaceId namespace_id = 1;
  string name = 2;
  ShardId shard_id = 3; // Which shard hosts this namespace
  repeated NodeId member_nodes = 4; // Nodes in the shard
  optional NodeId leader_hint = 5; // May be stale
  uint64 config_version = 6;
  NamespaceStatus status = 7;
}

enum NamespaceStatus {
  NAMESPACE_STATUS_UNSPECIFIED = 0;
  NAMESPACE_STATUS_ACTIVE = 1;
  NAMESPACE_STATUS_DELETED = 2;
}

message ListNamespacesRequest {
  optional bytes page_token = 1;
  uint32 page_size = 2; // Default: 100, Max: 1000
}

message ListNamespacesResponse {
  repeated GetNamespaceResponse namespaces = 1;
  optional bytes next_page_token = 2; // Absent if no more pages
}

// -----------------------------------------------------------------------------
// Vault Messages
// -----------------------------------------------------------------------------

// Create a new vault. VaultId is leader-assigned from _meta:seq:vault
// and returned in CreateVaultResponse.
message CreateVaultRequest {
  NamespaceId namespace_id = 1;
  uint32 replication_factor = 2;
  repeated NodeId initial_nodes = 3;
  optional BlockRetentionPolicy retention_policy = 4; // Default: FULL
}

// Block retention modes for storage/compliance trade-off.
// See DESIGN.md "Snapshot & Retention Policy" for details.
enum BlockRetentionMode {
  BLOCK_RETENTION_MODE_UNSPECIFIED = 0;
  // Keep all blocks with full transactions indefinitely.
  // Use case: SOC 2, HIPAA compliance requiring full audit trail.
  BLOCK_RETENTION_MODE_FULL = 1;
  // After snapshot, remove transaction bodies for old blocks (headers preserved).
  // Use case: High-volume workloads prioritizing storage efficiency.
  BLOCK_RETENTION_MODE_COMPACTED = 2;
}

message BlockRetentionPolicy {
  BlockRetentionMode mode = 1;
  // For COMPACTED mode: blocks newer than tip - retention_blocks keep full transactions.
  // Ignored for FULL mode. Default: 10000 blocks.
  uint64 retention_blocks = 2;
}

message CreateVaultResponse {
  VaultId vault_id = 1;
  BlockHeader genesis = 2;
}

message DeleteVaultRequest {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
}

message DeleteVaultResponse {
  google.protobuf.Timestamp deleted_at = 1;
}

message GetVaultRequest {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
}

message GetVaultResponse {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
  uint64 height = 3;
  Hash state_root = 4;
  repeated NodeId nodes = 5;
  NodeId leader = 6;
  VaultStatus status = 7;
  BlockRetentionPolicy retention_policy = 8;
}

enum VaultStatus {
  VAULT_STATUS_UNSPECIFIED = 0;
  VAULT_STATUS_ACTIVE = 1;
  VAULT_STATUS_READ_ONLY = 2;
  VAULT_STATUS_DELETED = 3;
}

message ListVaultsRequest {
  // Empty - lists all vaults on this node
}

message ListVaultsResponse {
  repeated GetVaultResponse vaults = 1;
}

message CreateSnapshotRequest {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
}

message CreateSnapshotResponse {
  uint64 block_height = 1;
  Hash state_root = 2;
  string snapshot_path = 3;
}

message CheckIntegrityRequest {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
  bool full_check = 3; // Replay from genesis vs quick check
}

message CheckIntegrityResponse {
  bool healthy = 1;
  repeated IntegrityIssue issues = 2;
}

message IntegrityIssue {
  uint64 block_height = 1;
  string issue_type = 2; // "chain_break", "state_divergence", etc.
  string description = 3;
}

// Recover a diverged vault by replaying blocks from archive.
message RecoverVaultRequest {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
  // Force recovery even if vault is healthy (for testing/maintenance).
  // Required for manual intervention after automatic recovery exhausted.
  bool force = 3;
}

message RecoverVaultResponse {
  bool success = 1;
  string message = 2; // Error details if !success
  // New vault health status after recovery attempt.
  VaultHealthProto health_status = 3;
  // Final block height after recovery.
  uint64 final_height = 4;
  // Final state root after recovery (should match expected).
  Hash final_state_root = 5;
}

// Request to simulate vault divergence for testing.
// This forces a vault into the Diverged state without actual corruption.
message SimulateDivergenceRequest {
  NamespaceId namespace_id = 1;
  VaultId vault_id = 2;
  // Expected state root (fake value for simulation).
  Hash expected_state_root = 3;
  // Computed state root (fake value for simulation).
  Hash computed_state_root = 4;
  // Height at which "divergence" occurred.
  uint64 at_height = 5;
}

message SimulateDivergenceResponse {
  bool success = 1;
  string message = 2;
  // Vault health status after simulation (should be DIVERGED).
  VaultHealthProto health_status = 3;
}

// Force a garbage collection cycle for expired entities.
// If namespace_id and vault_id are specified, only that vault is scanned.
// If omitted, all vaults are scanned (cluster-wide GC).
message ForceGcRequest {
  optional NamespaceId namespace_id = 1;
  optional VaultId vault_id = 2;
}

message ForceGcResponse {
  bool success = 1;
  string message = 2;
  // Number of expired entities that were removed.
  uint64 expired_count = 3;
  // Number of vaults that were scanned.
  uint64 vaults_scanned = 4;
}

// Vault health status (mirrors internal VaultHealthStatus enum).
enum VaultHealthProto {
  VAULT_HEALTH_PROTO_UNSPECIFIED = 0;
  VAULT_HEALTH_PROTO_HEALTHY = 1;
  VAULT_HEALTH_PROTO_DIVERGED = 2;
  VAULT_HEALTH_PROTO_RECOVERING = 3;
}

// -----------------------------------------------------------------------------
// Cluster Membership Messages
// -----------------------------------------------------------------------------

// Request to join an existing cluster.
// The node provides its ID and address so the leader can add it to Raft.
message JoinClusterRequest {
  uint64 node_id = 1; // Numeric node ID for Raft
  string address = 2; // gRPC address (e.g., "10.0.0.5:50051")
}

message JoinClusterResponse {
  bool success = 1;
  string message = 2; // Error details if !success
  uint64 leader_id = 3; // Current leader (for redirect if needed)
  string leader_address = 4; // Leader's gRPC address
}

// Request to gracefully leave the cluster.
message LeaveClusterRequest {
  uint64 node_id = 1; // Node requesting to leave
}

message LeaveClusterResponse {
  bool success = 1;
  string message = 2;
}

// Get current cluster membership.
message GetClusterInfoRequest {}

message GetClusterInfoResponse {
  repeated ClusterMember members = 1;
  uint64 leader_id = 2;
  uint64 term = 3; // Current Raft term
}

// A member of the Raft cluster.
message ClusterMember {
  uint64 node_id = 1;
  string address = 2;
  ClusterMemberRole role = 3;
  bool is_leader = 4;
}

enum ClusterMemberRole {
  CLUSTER_MEMBER_ROLE_UNSPECIFIED = 0;
  CLUSTER_MEMBER_ROLE_VOTER = 1; // Full voting member
  CLUSTER_MEMBER_ROLE_LEARNER = 2; // Receiving logs but can't vote
}

// =============================================================================
// Health Service
// =============================================================================

service HealthService {
  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);
}

message HealthCheckRequest {
  optional NamespaceId namespace_id = 1; // Namespace for vault health check
  optional VaultId vault_id = 2; // If empty, check node health
}

message HealthCheckResponse {
  HealthStatus status = 1;
  string message = 2;
  map<string, string> details = 3;
}

enum HealthStatus {
  HEALTH_STATUS_UNSPECIFIED = 0;
  HEALTH_STATUS_HEALTHY = 1;
  HEALTH_STATUS_DEGRADED = 2;
  HEALTH_STATUS_UNAVAILABLE = 3;
}

// =============================================================================
// System Discovery Service
// =============================================================================

service SystemDiscoveryService {
  // Get known peers (subset of _system state, lightweight)
  rpc GetPeers(GetPeersRequest) returns (GetPeersResponse);

  // Announce a new or updated peer to the cluster
  rpc AnnouncePeer(AnnouncePeerRequest) returns (AnnouncePeerResponse);

  // Get full system state (nodes + vault registry)
  rpc GetSystemState(GetSystemStateRequest) returns (GetSystemStateResponse);
}

message GetPeersRequest {
  uint32 max_peers = 1; // Limit response size (0 = no limit)
}

message GetPeersResponse {
  repeated PeerInfo peers = 1;
  uint64 system_version = 2; // For cache invalidation
}

message PeerInfo {
  NodeId node_id = 1;
  // IP addresses only (no port). IPv4 or IPv6, e.g., ["10.0.0.1", "fd00::1"].
  // Must be private/WireGuard IPs—public IPs rejected.
  // Connect via: addresses[i] + ":" + grpc_port
  repeated string addresses = 2;
  uint32 grpc_port = 3; // gRPC port (same for all addresses), typically 5000
  google.protobuf.Timestamp last_seen = 4;
}

message AnnouncePeerRequest {
  PeerInfo peer = 1;
}

message AnnouncePeerResponse {
  bool accepted = 1;
}

message GetSystemStateRequest {
  uint64 if_version_greater_than = 1; // Return empty if version <= this (cache optimization)
}

message GetSystemStateResponse {
  uint64 version = 1;
  repeated NodeInfo nodes = 2;
  repeated NamespaceRegistry namespaces = 3; // Routing table: namespace → shard
}

message NodeInfo {
  NodeId node_id = 1;
  // IP addresses only (no port). IPv4 or IPv6, e.g., ["10.0.0.1", "fd00::1"].
  // Must be private/WireGuard IPs—public IPs rejected.
  // Connect via: addresses[i] + ":" + grpc_port
  repeated string addresses = 2;
  uint32 grpc_port = 3; // gRPC port (same for all addresses), typically 5000
  NodeCapabilities capabilities = 4;
  google.protobuf.Timestamp last_heartbeat = 5;
}

message NodeCapabilities {
  bool can_lead = 1;
  uint64 max_vaults = 2;
}

// Routing entry: namespace → shard assignment
message NamespaceRegistry {
  NamespaceId namespace_id = 1;
  ShardId shard_id = 2; // Which Raft group hosts this namespace
  repeated NodeId members = 3; // Nodes in the shard
  optional NodeId leader_hint = 4; // May be stale
  uint64 config_version = 5;
}

// =============================================================================
// Raft Internal Service (inter-node communication)
// =============================================================================

// Internal Raft RPC service for consensus protocol.
// Used for inter-node communication: vote, log replication, snapshots.
service RaftService {
  // Request vote from peer during leader election.
  rpc Vote(RaftVoteRequest) returns (RaftVoteResponse);

  // Replicate log entries to followers.
  rpc AppendEntries(RaftAppendEntriesRequest) returns (RaftAppendEntriesResponse);

  // Install snapshot on a follower that is too far behind.
  rpc InstallSnapshot(RaftInstallSnapshotRequest) returns (RaftInstallSnapshotResponse);
}

// Raft vote (term + node_id + committed flag).
message RaftVote {
  uint64 term = 1;
  uint64 node_id = 2;
  bool committed = 3;
}

// Raft log entry identifier.
message RaftLogId {
  uint64 term = 1;
  uint64 index = 2;
}

// Vote request during leader election.
message RaftVoteRequest {
  RaftVote vote = 1;
  optional RaftLogId last_log_id = 2;
}

// Vote response.
message RaftVoteResponse {
  RaftVote vote = 1;
  bool vote_granted = 2;
  optional RaftLogId last_log_id = 3;
}

// Log replication request.
message RaftAppendEntriesRequest {
  RaftVote vote = 1;
  optional RaftLogId prev_log_id = 2;
  repeated bytes entries = 3; // Serialized log entries
  optional RaftLogId leader_commit = 4;
}

// Log replication response.
message RaftAppendEntriesResponse {
  RaftVote vote = 1;
  bool success = 2;
  bool conflict = 3;
}

// Snapshot installation request.
message RaftInstallSnapshotRequest {
  RaftVote vote = 1;
  RaftSnapshotMeta meta = 2;
  uint64 offset = 3;
  bytes data = 4;
  bool done = 5;
}

// Snapshot installation response.
message RaftInstallSnapshotResponse {
  RaftVote vote = 1;
}

// Snapshot metadata.
message RaftSnapshotMeta {
  optional RaftLogId last_log_id = 1;
  RaftMembership last_membership = 2;
  string snapshot_id = 3;
}

// Raft cluster membership configuration.
message RaftMembership {
  repeated RaftMembershipConfig configs = 1;
}

// Single membership configuration (joint consensus may have multiple).
message RaftMembershipConfig {
  // Map of node_id -> address
  map<uint64, string> members = 1;
}
